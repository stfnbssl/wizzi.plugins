{
    "wizziPackages": [
        {
            "name": "wizzi.plugin.c",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.c",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.c\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.c/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.c\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.c",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "c"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.c\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.c-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.c\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.c",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "c"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "c",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.c\\.wizzi-override\\lib\\wizzi\\schemas\\c.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema c\n\n    e statement\n\t\t# A statement line node with unlimited depth.\n\t\t# Is the schema base node.\n\t\t# In itself works as a comment line.\n\t\ttag //\n\t\tr statement/s\n        any codeline/statements\n\n\te codeline : statement\n\n    e c\n\t\tis-root\n        r statement/s\n        any codeline/statements\n\n\te multilinecomment : statement\n        tag /*\n\n\te plusline : statement\n        tag +\n\n\te param\n\n    e function : statement\n        a rtype\n            # return type\n        r param/s\n\t\n    e return : statement\n\n    $include c/set\n    $include c/control\n    $include c/debug"
                }
            ],
            "artifacts": [
                {
                    "name": "c/document",
                    "schema": "c",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.c\\.wizzi-override\\lib\\artifacts\\c\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.c',\n            name: 'document',\n            schema: 'c',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n        $append main\n            _ md.c\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        async-md( c )\n            _ ctx.w('<c>')\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                {\n                    @ indent true\n                a_cb()\n                    _ ctx.w('</c>')\n                    r_cb()\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n"
                },
                {
                    "name": "c/module",
                    "schema": "c",
                    "artifact": "module",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.c\\.wizzi-override\\lib\\artifacts\\c\\module\\gen\\main.js.ittf",
                    "content": "module\r\n    kind es6\r\n    $\r\n        var md = {\r\n            schema: 'c',\r\n            name: 'module',\r\n            checkSchema: true,\r\n            preprocess: false,\r\n            mainStart: true,\r\n            mainFinish: true,\r\n        }\r\n    \r\n    gen( &md )\r\n        $append imports\r\n            var writers = require('./writers/index')\r\n\r\n        $append main\r\n            \r\n            var item_count = 0\r\n            iife next\r\n                var item = model.statements[item_count++]\r\n                if !item\r\n                    return\r\n                        _ terminate_gen\r\n                            @ model\r\n                            @ ctx\r\n                _ writers.gen\r\n                    @ item\r\n                    @ ctx\r\n                    a_cb()\r\n                        _ next\r\n\r\n        function mainStart\r\n            param model\r\n            param ctx\r\n        \r\n        function mainFinish\r\n            param model\r\n            param ctx"
                }
            ],
            "transformations": [
                {
                    "name": "c/extended",
                    "schema": "c",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.c\\.wizzi-override\\lib\\artifacts\\c\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.c',\n            name: 'extended',\n            schema: 'c',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.css",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.css",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.css\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.css/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.css\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.css",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "css"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.css\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.css-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.css\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.css",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "css"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "css",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.css\\.wizzi-override\\lib\\wizzi\\schemas\\css.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema css\n\n\t# A schema modeling a css3 stylesheet document.\n\n\t# ATTENTION in this model the usual python like comment char sharp(#) is replaced\n\t#           by the minus(-) char, see the comment element.\n\t#           The sharp char(#) is used for the idRule element.\n\n  \t# Preprocess the mTree before loading the wizzi model\n\tmtree-is-preprocessed\n\n\te css\n\t\t# The root element\n\t\tis-root\n\t\t\n\t\ta charset\n        a_flag( useNormalize, use-normalize )\n\t\t\n\t\tr resource/s\n\t\tr rule/s\n\t\tr comment/s\n        r statement/s\n\n\t\tm wzInitialize\n\t\t\tif verify.isObject(this.extends)\n\t\t\t\tvar rule\n\t\t\t\tforeach item in Object.keys(this.extends)\n\t\t\t\t\tset rule = this.findRuleBySelector(item)\n\t\t\t\t\tif rule\n\t\t\t\t\t\t# loog 'rule.wzName, rule.ruleParts, rule.getSelector()', rule.wzName, rule.ruleParts, rule.getSelector(), 'rule.wzParent.wzName', rule.wzParent.wzName, 'rule.wzElement', rule.wzElement\n\t\t\t\t\t\tforeach ext in this.extends[item]\n\t\t\t\t\t\t\t# loog 'ext.wzParent.getSelector()',ext.wzParent.getSelector(),ext.wzParent.wzName\n\t\t\t\t\t\t\t_ rule.addOtherRuleSelector(ext.wzParent.getSelector(), this.wzSourceLineInfo)\n\t\t\t\t\t\tset rule.ruleParts = rule.getAscendingRuleParts()\n\t\t\t\t\t\t# loog 'rule.ruleParts', rule.ruleParts, rule.getSelector()\n\n\t\tm findRuleBySelector\n\t\t\tparam name\n\t\t\tvar ret = null\n\t\t\tforeach item in this.rules\n\t\t\t\tset ret = item.findRuleBySelector(name)\n\t\t\t\tif ret\n\t\t\t\t\treturn ret\n\t\t\treturn ret\n\n\te statement\n        tag +\n\n    e resource\n\t\t# A known resource (a fragment of a stylesheet), stored in a repository,\n\t\t# that must be included in the generated artifact.\n\n\te rule\n\t\t# The base abstract rule.\n\t\t# It has a child relation (one-to-many) with itself so one\n\t\t# can declare a tree of rules with unlimited deep.\n\n\t\tis-abstract\n\n\t\ta -webkit-*\n\t\ta -ms-*\n\t\ta -o-*\n\t\ta -moz-*\n\t\ta --*\n        a v-* \n\t\t\n\t\tr otherRuleSelector/s\n\t\tr otherClassSelector/s\n\t\tr otherAmpersandSelector/s\n\t\tr propert-y/ies\n\t\tr rule/s\n\n\t\tm wzInitialize\n\t\t\t# loog '*** rule.initialize.start', this.wzElement, this.wzName\n\t\t\tset this.parentRuleParts = this.getAscendingRuleParts()\n\t\t\t# loog '*** rule.initialize.end', this.wzElement, this.wzName, 'this.parentRuleParts', this.parentRuleParts.join(',')\n\t\t\tset this.canHaveContent = ['idRule', 'classRule', 'elementRule', 'gtRule', 'ampersand', 'placeholder'].indexOf(this.wzElement) > -1\n\n\t\tm findRuleBySelector\n\t\t\tparam name\n\t\t\tif this.canHaveContent && this.getSelector() === name\n\t\t\t\treturn this\n\t\t\tvar ret = null\n\t\t\tforeach item in this.rules\n\t\t\t\tset ret = item.findRuleBySelector(name)\n\t\t\t\tif ret\n\t\t\t\t\treturn ret\n\t\t\treturn ret\n\t\t\n\t\tm hasContent\n\t\t\tforeach item in this.rules\n\t\t\t\tif item.canHaveContent\n\t\t\t\t\treturn true\n\t\t\treturn this.getProperties().length > 0\n\n\t\tm getSelector\n\t\t\tparam final\n\t\t\tif final && this.wzElement === 'placeholder'\n\t\t\t\treturn this.parentRuleParts.slice(1).join(', ')\n\t\t\telse\n\t\t\t\treturn this.parentRuleParts.join(', ')\n\n\t\tm getProperties\n\t\t\tvar retval = []\n\t\t\tfor var prop in this\n\t\t\t\tif isPropValue(prop, this[prop])\n\t\t\t\t\t_ retval.push({ name: verify.replaceAll(prop, '_', '-'), value: this[prop] })\n\n\t\t\tforeach prop in this.properties\n\t\t\t\tif prop.wzElement === 'property'\n\t\t\t\t\t# generic property ( @ name value )\n\t\t\t\t\tvar p = verify.parseNameValue(prop.wzName, prop)\n\t\t\t\t\tif prop.properties.length > 0\n\t\t\t\t\t\t# Nested properties\n\t\t\t\t\t\tif p.hasValue()\n\t\t\t\t\t\t\t_ retval.push({ name: p.name(), value: p.value() })\n\t\t\t\t\t\tforeach nestedprop in prop.properties\n\t\t\t\t\t\t\tvar p_nested = lineParser.parseNameValueRaw(nestedprop.wzName, nestedprop)\n\t\t\t\t\t\t\t_ retval.push({ name: p.name() + '-' + p_nested.name(), value: p_nested.value() })\n\t\t\t\t\telse\n\t\t\t\t\t\tif p.hasValue()\n\t\t\t\t\t\t\t_ retval.push({ name: p.name(), value: p.value() })\n                        elif prop.styledprop\n                            _ retval.push({ name: p.name(), value: null, styledprop: prop.styledprop })\n\t\t\t\telse\n\t\t\t\t\tif prop.wzElement == 'background_image' || prop.wzElement == 'jscode'\n\t\t\t\t\t\t_ retval.push\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t@ name prop.wzTag\n\t\t\t\t\t\t\t\t@ value prop.wzName\n\t\t\t\t\t\t\t\t@ wzElement prop.wzElement\n\t\t\t\t\t\t\t\t@ prop prop\n                                @ styledprop prop.styledprop\n\t\t\t\t\telif verify.isNotEmpty(prop.wzName)\n                        # loog 'verify.isNotEmpty(prop.wzName)', prop.wzTag, prop.wzName, prop.styledprop\n\t\t\t\t\t\t_ retval.push({ name: prop.wzTag, value: prop.wzName })\n                    else\n                        _ retval.push({ name: prop.wzTag, value: null, styledprop: prop.styledprop })\n\t\t\t\t\tfor var attr in prop\n\t\t\t\t\t\tif isPropValue(attr, prop[attr])\n                            # loog 'if isPropValue(attr, prop[attr])', prop.wzTag, attr\n\t\t\t\t\t\t\t_ retval.push({ name: prop.wzTag + '-' + verify.replaceAll(attr, '_', '-'), value: prop[attr] })\n\t\t\treturn retval\n\n\n\t\tm getAscendingRuleParts\n\t\t\tvar thisRuleParts = []\n\t\t\tif this.wzElement !== 'media'\n\t\t\t\tset thisRuleParts = this.wzName.trim().split(',')\n\t\t\t\tforeach ors in this.otherRuleSelectors\n\t\t\t\t\t_ thisRuleParts.push(ors.wzName)\n\t\t\t# loog '*** thisRuleParts 1', thisRuleParts.join(',')\n\t\t\tif thisRuleParts.length > 0 \n\t\t\t\tif this.wzElement === 'idRule'\n\t\t\t\t\tset thisRuleParts[0] = '#' + thisRuleParts[0]\n\t\t\t\telif this.wzElement === 'classRule'\n\t\t\t\t\tset thisRuleParts[0] = '.' + thisRuleParts[0]\n\t\t\t\telif this.wzElement === 'gtRule'\n\t\t\t\t\tset thisRuleParts[0] = '> ' + thisRuleParts[0]\n\t\t\t\telif this.wzElement === 'placeholder'\n\t\t\t\t\tset thisRuleParts[0] = '%' + thisRuleParts[0]\n\t\t\t\telif this.wzElement === 'ampersand'\n\t\t\t\t\tset thisRuleParts[0] = '&' + thisRuleParts[0]\n\t\t\t# loog '*** thisRuleParts 2', thisRuleParts.join(',')\n\t\t\tif this.wzParent && this.wzParent.getAscendingRuleParts\n\t\t\t\tvar parentRuleParts = this.wzParent.getAscendingRuleParts()\n\t\t\t\t# loog '*** parentRuleParts 3', parentRuleParts.join(',')\n\t\t\t\tif parentRuleParts.length > 0\n\t\t\t\t\tvar ret = []\n\t\t\t\t\tforeach prp in parentRuleParts\n\t\t\t\t\t\tif this.wzElement == 'media'\n\t\t\t\t\t\t\t_ ret.push(prp)\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tforeach rp in thisRuleParts\n\t\t\t\t\t\t\t\tif rp.indexOf('&') > -1\n\t\t\t\t\t\t\t\t\t_ ret.push(verify.replaceAll(rp, '&', prp))\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t_ ret.push(prp + ' ' + rp)\n\t\t\t\t\treturn ret\n\t\t\t\telse\n\t\t\t\t\treturn thisRuleParts\n\t\t\telse\n\t\t\t\treturn thisRuleParts\n\n\te elementRule : rule\n\t\t# The element rule\n\t\t# The wzName contain the selector(s)\n\t\ttag <\n\n\te classRule : rule\n\t\t# The class rule\n\t\t# The wzName contain the selector(s)\n\t\ttag .\n\n\te idRule : rule\n\t\t# The id rule\n\t\t# The wzName contain the selector(s)\n\t\ttag #\n\n\te gtRule : rule\n\t\t# The > rule\n\t\t# The wzName contain the selector(s)\n\t\ttag >\n\n\te ampersand : rule\n\t\ttag &\n\n\te pseudoElementRule : rule\n\t\ttag ::\n\n\te placeholder : rule\n\t\ttag %\n\n\te otherRuleSelector\n\t\t# The wzName contains other selector(s) to add to those of the parent rule.\n\t\t# In case of a rule with many selectors allow the declaration on many nodes.\n\t\t# Rules are joined comma separated.\n\t\t# Example\n\t\t# < td\n\t\t#\t+ span\n\t\t#   + li\n\t\t#   + ...\n\t\t# for: td, span, li, ...\n\t\ttag +\n\n\te otherClassSelector\n\t\t# The wzName contains a class selector to add to those of the parent rule.\n\t\t# Example\n\t\t# . container\n\t\t#\t+. item\n\t\t#   + ...\n\t\t# for: .container, .item ...\n\t\ttag +.\n\n\te otherAmpersandSelector : rule\n\t\ttag +&\n\n\te property\n\t\t# A generic rule property.\n\t\t# You should find a proper schema element that extends this one for every valid css3 property. \n\t\t# In any case this element is not abstract and can fit for missing properties.\n\t\t# In this case must contain a name-value pair separated by a blank: name is\n\t\t# the property name and value the property value.\n\t\t# ittf\n\t\t# . wrapper\n\t\t#     @ webkit-super-exotic quark  \n\t\t# css\n\t\t# .wrapper {\n\t\t#   webkit-super-exotic: quark;\n\t\t# }\n\n\t\ttag @\n\n\t\ta styledprop\n            tag =>\n        \n        r propert-y/ies\n\t\t\t# Nested property\n\n    e styledVar : property\n        tag $\n\t\n    e jscode : property\n        tag js=>\n        include js module\n\n\t$include css/spec-properties\n\n\te media : rule\n\n\te keyframes : rule\n\t\ta vendor\n\t\n\te keyframe : rule\n\t\ta value\n\t\ta % \n\n    e keyframeFrom : rule\n        tag from\n    \n    e keyframeTo : rule\n        tag to\n\t\n\te fontface : rule\n\t\ttag font-face\n\t\ta_tag( fontFamily, font-family )\n\t\ta src\n\t\ta_tag( fontStretch, font-stretch )\n        a_tag( fontFeatureSettings, font-feature-settings )\n        a_tag( fontVariationSettings, font-variation-settings )\n        a_tag( fontVariant, font-variant )\n\t\ta_tag( fontStyle,  font-style )\n\t\ta_tag( fontWeight, font-weight )\n\t\ta_tag( unicodeRange, unicode-range )\n        a_tag( fontDisplay, font-display )\n\t\n\te extend : rule\n\t\ttag extend|extend\n\n\t\tm wzInitialize\n\t\t\tvar root = this.wzRoot()\n\t\t\tif !root.extends\n\t\t\t\tset root.extends = {}\n\t\t\tif !root.extends[this.wzName]\n\t\t\t\tset root.extends[this.wzName] = []\n\t\t\tset root.extends[this.wzName].push(this)\n\n\te import : rule\n\n\te include : rule\n\n\te comment : rule\n\t\t# The wzName is the comment text.\n\t\t\n\t\ttag -\n\n\tdeclare\n\t\t# Global level vars and functions that\n\t\t# will be written in the generated wizzi model type.\n\n\t\tvar noattrs\n\t\t\t[\n\t\t\t\t@ 'wzTag'\n\t\t\t\t@ 'wzName'\n\t\t\t\t@ 'wzElement'\n\t\t\t\t@ 'wzParent'\n\t\t\t\t@ 'wzSourceLineInfo'\n\t\t\t\t@ '___exportName'\n\t\t\t\t@ 'canHaveContent'\n\n\t\tfunction isPropValue\n\t\t\tparam a\n\t\t\tparam v\n\t\t\tif noattrs.indexOf(a) > -1\n\t\t\t\treturn false\n            if a == \"styledprop\"\n                return false\n\t\t\tif v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n\t\t\t\treturn false\n\t\t\treturn true\n\n"
                }
            ],
            "artifacts": [
                {
                    "name": "css/document",
                    "schema": "css",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.css\\.wizzi-override\\lib\\artifacts\\css\\document\\gen\\main.js.ittf",
                    "content": "module wizzi.plugin.css@${wzCtx.version}.lib.artifacts.css.document.gen.main\n    kind es6\n    $include versions\n    $\n        var md = {\n            plugin: 'wizzi.plugin.css',\n            name: 'document',\n            schema: 'css',\n            checkSchema: true,\n            isAsync: true,\n        };\n    +\n    gen( &md )\n        $append imports\n            var included_writers = require('./included_writers')\n            var postcss = require(\"postcss\")\n            var colorFunction = require(\"postcss-color-function\")    \n            var rule = require('./rule')\n            \n\n        $append main\n            _ rule.load(md)\n            _ main_init\n                @ model\n                @ ctx\n            if true\n                set ctx.__comment_level = 0\n                _ md.myGetGenItem\n                    @ ctx\n                    (\n                        @ model\n                        a_cb()\n                            if ctx.artifactGenerationErrors.length > 0\n                                r_cb_err( ctx.artifactGenerationErrors )\n                            else\n                                try\n                                    var postCssResult\n                                        _ postcss\n                                            ._ use\n                                                _ colorFunction\n                                                    { \n                                                        @ preserveCustomProps true\n                                            ._ process\n                                                _ ctx.getContent\n                                            . css\n                                catch ex\n                                    if ex.name === 'CssSyntaxError'\n                                        r_cb(ctx)\n                                _ ctx.hydrate\n                                    {\n                                        [ lines\n                                            {\n                                                @ indentValue 0\n                                                [ text\n                                                    @ postCssResult                        \n                                r_cb(ctx)\n            else\n                _ md.css\n                    @ model\n                    @ ctx\n                    a_cb( )\n                        if ctx.artifactGenerationErrors.length > 0\n                            r_cb_err( ctx.artifactGenerationErrors )\n                        else\n                            # generation OK\n                            r_cb( ctx )\n        async-md( css )\n            _ ctx.w('<css>')\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                {\n                    @ indent true\n                a_cb()\n                    _ ctx.w('</css>')\n                    r_cb()\n        async-md( css )\n            # css is container only\n            if model.charset\n                _ ctx.write('@charset \"' + model.charset + '\";')\n            _ emitResources(model.resources, ctx)\n            _ md.genItems\n                @ model.statements\n                @ ctx\n                {\n                    @ indent false\n                a_cb()\n                    _ md.genItems\n                        @ model.rules\n                        @ ctx\n                        {\n                            @ indent false\n                        @ callback\n\n        async-md( statement )\n            _ ctx.w(model.wzName)\n            r_cb()\n        +\n        set md.myGetGenItem\n            function\n                param ctx\n                return\n                    function\n                        param model\n                        param callback\n                        var stm = md[model.wzElement]\n                        if stm\n                            _ stm\n                                @ model\n                                @ ctx\n                                @ callback\n                        else \n                            # this is an abnormal end\n                            throw ctx.error(myname + '. Unknown tag/element: ' + model.wzTag + '/' + model.wzElement, model)\n        +\n        function main_init\n            param model\n            param ctx\n\n            # loog 'css.document.gen.main, ctx.values', ctx.values, !!ctx.values.noGeneratorComments\n            \n            if (!!ctx.values.noGeneratorComments) == false\n                _ ctx.w('/*')\n                _ ctx.w('    artifact generator: ' + __filename)\n                _ ctx.w('    package: wizzi-web@${versions['wizzi-web@next']}')\n                _ ctx.w('    primary source IttfDocument: ' + model.wzSourceFilepath('f1'))\n                if (!!ctx.values.wzConfigIsPackageDeploy) == false\n                    _ ctx.w('    utc time: ' + new Date().toUTCString())\n                _ ctx.w('*/')\n        +\n        function emitResources\n            param requestedResources\n            param ctx\n\n            if requestedResources.length > 0 && ctx.values.cssResources\n                var resourceRepo = ctx.values.cssResources\n                _ resourceRepo.clearCssDependencies()\n                foreach item in requestedResources\n                    _ resourceRepo.addCssDependency(item.wzName)\n                _ resourceRepo.emitCssDependencies(ctx)\n        +\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        +\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        +\n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n"
                }
            ],
            "transformations": [
                {
                    "name": "css/extended",
                    "schema": "css",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.css\\.wizzi-override\\lib\\artifacts\\css\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.css',\n            name: 'extended',\n            schema: 'css',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ],
            "wizzifiers": [
                {
                    "name": "css",
                    "schema": "css",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.css\\.wizzi-override\\lib\\wizzifiers\\css\\wizzifier.js.ittf",
                    "content": "module\n    $\n        var schemaName = 'css';\n    kind es6\n    basewizzifier()\n        $append imports\n            +\n            var css_parser = require('css')\n            var cleanAST = require('./cleanAST')\n            +\n            function parseInternal\n                param tobeWizzified\n                param options\n                param callback\n                var syntax\n                try\n                    set syntax = css_parser.parse(tobeWizzified)\n                    _ cleanAST(syntax)\n                    r_cb( cloner(syntax) )\n                catch ex\n                    return\n                        _ callback\n                            @ ex\n        \n        var format\n            function \n                param ast\n                param options\n                var formatter = format[ast.type]\n                if verbose\n                    info 'ast.type', ast.type\n                if formatter\n                    return formatter(ast, options)\n                throw \n                    new Error('no formatter for type: ' + ast.type)\n        \n        +\n        function wizzify\n            param tobeWizzified\n            param options\n            param callback\n            set options = options || {};\n            set options.input = tobeWizzified\n            set options.stack = []\n            set options.formatTextNodes = []\n            set options.verbose = true\n            _ parseInternal\n                @ tobeWizzified\n                @ options\n                a_cb( syntax )\n                    # log stringify(syntax, null, 2)\n                    if false\n                        # standard \n                        var root\n                            {\n                                @ tag '${schemaName}'\n                                [ children\n                        _ format(root, syntax, options)\n                        return\n                            _ callback\n                                @ null\n                                @ root\n                    else\n                        # simple format\n                        var root = format(syntax)\n                        # log \"wizziTree\", root\n                        return\n                            _ callback\n                                @ null\n                                @ root                    \n        +\n        $include helper_functions\n        +\n        function isKnownType\n            param type\n            return ['Int', 'Float', 'Boolean', 'String'].indexOf(type) > -1\n        +\n        function getTypeName\n            param type\n            return isKnownType(type) ? type.toLowerCase() : type\n        +\n        f_simple( stylesheet\n            # loog 'stylesheet.ast', ast\n            var ret\n                { \n                    @ tag 'css'\n                    @ children\n                        [ \n            _ ast.stylesheet.rules.map\n                function \n                    param node\n                    _ ret.children.push\n                        _ format(node)\n            return ret\n        \n        f_simple( comment\n            var ret\n                { \n                    @ tag '#'\n                    @ children\n                        [ \n            var lines\n                _ file.splitLines\n                    @ ast.comment\n            if lines.length == 1\n                set ret.name = lines[0]\n            else \n                foreach l in lines\n                    _ ret.children.push\n                        { \n                            @ tag '#'\n                            @ name l\n                            @ children\n                                [ \n            return ret\n        \n        f_simple( rule\n            var ret\n                { \n                    @ tag '<'\n                    @ children\n                        [ \n            var ls = ast.selectors.length\n            for var i = 0; i < ls; i++\n                if i == 0\n                    set ret.name = ast.selectors[i]\n                    if ret.name.trim()[0] === '.'\n                        set ret.tag = '.'\n                        set ret.name = ret.name.trim().substr(1)\n                    elif ret.name.trim()[0] === '#'\n                        set ret.tag = '#'\n                        set ret.name = ret.name.trim().substr(1)\n                else \n                    _ ret.children.push\n                        { \n                            @ tag '+'\n                            @ name ast.selectors[i]\n                            @ children\n                                [ \n            _ ast.declarations.map\n                function \n                    param node\n                    _ ret.children.push\n                        _ format(node)\n            return ret\n        \n        f_simple( declaration\n            var ret\n                { \n                    @ tag ast.property\n                    @ name ast.value\n                    @ children\n                        [ \n            return ret\n        \n        f_simple( media\n            var ret\n                { \n                    @ tag 'media'\n                    @ name ast.media\n                    @ children\n                        [ \n            _ ast.rules.map\n                function \n                    param node\n                    _ ret.children.push\n                        _ format(node)\n            return ret\n        \n        f_simple( font-face\n            var ret\n                { \n                    @ tag 'font-face'\n                    @ children\n                        [ \n            _ ast.declarations.map\n                function \n                    param node\n                    _ ret.children.push\n                        _ format(node)\n            return ret\n        \n        f_simple( keyframes\n            var ret\n                { \n                    @ tag 'keyframes'\n                    @ name ast.name\n                    @ children\n                        [ \n            _ ret.children.push\n                { \n                    @ tag 'vendor'\n                    @ name ast.vendor\n                    @ children\n                        [ \n            _ ast.keyframes.map\n                function \n                    param node\n                    _ ret.children.push\n                        _ format(node)\n            return ret\n        \n        f_simple( keyframe\n            var ret\n                { \n                    @ tag 'keyframe'\n                    @ children\n                        [ \n            var ls = ast.values.length\n            for var i = 0; i < ls; i++\n                if i == 0\n                    set ret.name = ast.values[i]\n                else \n                    _ ret.children.push\n                        { \n                            @ tag 'value'\n                            @ name ast.values[i]\n                            @ children\n                                [ \n            _ ast.declarations.map\n                function \n                    param node\n                    _ ret.children.push\n                        _ format(node)\n            return ret\n        \n        f_simple( import\n            #\n                _ console.log\n                    @ 'import'\n                    _ util.inspect\n                        @ ast\n                        { \n                            @ depth null\n            var ret\n                { \n                    @ tag 'import'\n                    @ name ast.import\n                    @ children\n                        [ \n            return ret\n        \n        f_simple( charset\n            #\n                _ console.log\n                    @ 'charset'\n                    _ util.inspect\n                        @ ast\n                        { \n                            @ depth null\n            var ret\n                { \n                    @ tag 'charset'\n                    @ name ast.charset\n                    @ children\n                        [ \n            return ret\n\n        f_simple( supports\n            _ console.log\n                @ 'supports'\n                _ util.inspect\n                    @ ast\n                    { \n                        @ depth null\n        \n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.docx",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.docx",
            "hasWizziOverride": false,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.docx\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.docx/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.docx\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.docx\\dist",
                        "plugins": [
                            "./wizzi-core/dist/index.js",
                            "./wizzi-js/dist/index.js",
                            "./wizzi-web/dist/index.js"
                        ],
                        "pluginsBaseFolder": "C:\\My\\wizzi\\stfnbssl\\wizzi\\packages",
                        "s_schemas": [
                            "docx"
                        ],
                        "schemas": [
                            "docx"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "docx",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.docx\\.wizzi\\lib\\wizzi\\schemas\\docx.wfschema.ittf",
                    "genConfig": "wizzi.config.js",
                    "content": "wfschema docx\n    $\n        var md = {\n        };\n    \n    preserve-tags true\n    mtree-is-preprocessed true\n    $$ unknown-element-replacer text\n    \n    e node\n        r node/s\n    \n    e docx : node\n        is-root\n    \n    \n    e xname : node\n        tag name\n    e section : node\n    e h1 : node\n    e h2 : node\n    e h3 : node\n    e h4 : node\n    e h5 : node\n    e h6 : node\n    e p : node\n    e break : node\n        tag br\n    e text : node\n        tag +\n    e bold : node\n        tag b\n    e boldProp : node\n        tag bold\n    e italic : node\n        tag i\n    e italicProp : node\n        tag italic\n    e underline : node\n    e emphasisMark : node\n    e strike : node\n    e doubleStrike : node\n    e superScript : node\n    e subScript : node\n    e smallCaps : node\n    e allCaps : node\n    e smallCaps : node\n    e font : node\n    e color : node\n    e fill : node\n    e size : node\n    e width : node\n    e shading : node\n    e highlight : node\n    e xtype : node\n        tag type\n    e table : node\n    e tr : node\n    e td : node\n    e center : node\n    e bullet_0 : node\n    e tabStop : node\n    e position : node\n    e styles : node\n    e style : node\n    e basedOn : node\n    e next : node\n    e paragraphStyles : node\n        tag paragraph-styles\n    e run : node\n    e xdefault : node\n        tag default\n    e styleDef : node\n        tag style-def\n    e space : node\n    e value : node\n    e spacing : node\n    e after : node\n    e before : node\n    e line : node\n    e lineRule : node\n    e alignment : node\n\n    e hyperlinks : node\n    e link : node\n    e linkText : node\n        tag text\n\n    e hyperlinkDef : node\n        tag link-def\n    e hyperlinkRef : node\n        tag link-ref\n\n    e imageDef : node\n        a src\n        a title\n        tag image-def\n    e imageRef : node\n        tag image-ref\n\n    e border : node\n    e top : node\n    e bottom : node\n    e left : node\n    e right : node\n\n    e ul : node\n    e ol : node\n    e li : node\n\n"
                }
            ],
            "artifacts": [
                {
                    "name": "docx/document",
                    "schema": "docx",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.docx\\.wizzi\\lib\\artifacts\\docx\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: '',\n            name: 'document',\n            schema: 'docx',\n            checkSchema: true,\n            isAsync: true,\n        };\n    v08/lib/artifacts/gen(&md)\n        $append imports\n        $append main\n            _ md.docx\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        +\n        const noindent\n            {\n                @ indent false\n        +\n        function respace\n            param text\n            set text = verify.replaceAll(text, '&nbsp;', ' ')\n            return verify.replaceAll(text, '\"', '\\\\\"')\n            \n        +\n        async-md( docx )\n            # log \"ctx.keys\", Object.keys(ctx)\n            # log \"ctx.values property\", ctx.values\n            # log 'tag docx, nodes', model.nodes.length\n\n            set ctx.values.docxStack = []\n            set ctx.values.docxCounter = 0\n            set ctx.values.docxMainObject = 'docx_MainObject'\n            set ctx.values.mainObjectCreated = false\n            set ctx.values.bulletLevel = 0\n            \n            var docxNode = \"docx_doc_\" + (++ctx.values.docxCounter)\n            _ ctx.values.docxStack.push(docxNode)\n            set ctx.values.docxMainInternalObject = docxNode\n            \n            _ ctx.w('const fs = require(\"fs\");')\n            _ ctx.w('const docx = require(\"docx\");')\n            $$ _ ctx.w('const { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType, ShadingType, Table, TableCell, TableRow, TableLayoutType, WidthType } = docx;')\n            _ ctx.w('')\n            _ ctx.w('const ' + docxNode + ' = {};')\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                @ noindent\n                a_cb()\n                    _ ctx.w('')\n                    _ ctx.w('docx.Packer.toBuffer(' + ctx.values.docxMainObject + ').then((buffer) => {')\n                    _ ctx.w('    fs.writeFileSync(\"' + model.wzName + '.docx\", buffer);')\n                    _ ctx.w('    console.log(\"DONE written\")')\n                    _ ctx.w('});')\n                    r_cb()\n\n        +\n        async-md( section )\n            # log 'tag section, value', model.wzName\n            \n            var docxParent = ctx.values.docxStack[ctx.values.docxStack.length-1]\n            var docxNode = \"docx_sect_\" + (++ctx.values.docxCounter)\n            _ ctx.values.docxStack.push(docxNode)\n            _ ctx.w('const ' + docxNode + ' = { properties: {}, children: [] };')\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                @ noindent\n                a_cb()\n                    if ctx.values.mainObjectCreated == false\n                        _ ctx.w('const ' + ctx.values.docxMainObject + ' = new docx.Document(' + ctx.values.docxMainInternalObject + ');')\n                        set ctx.values.mainObjectCreated = true\n                    _ ctx.w(ctx.values.docxMainObject + '.addSection(' + docxNode + ');')\n                    _ ctx.values.docxStack.pop()\n                    r_cb()\n        +\n        objectNode.js( p, docx.Paragraph )   \n            _ ctx.w(docxNode + '.children = [];')\n            _ ctx.w(docxNode + '.tabStops = [];')\n            if !verify.isEmpty(model.wzName)\n                _ ctx.w(docxNode + '.text = \"' + respace(model.wzName) + '\";')\n            $append close\n                _ ctx.w(docxParent + '.children.push(' + docxNode + 'Obj);')\n\n        async-md( imageDef )\n            if ctx.values.mainObjectCreated == false\n                _ ctx.w('const ' + ctx.values.docxMainObject + ' = new docx.Document(' + ctx.values.docxMainInternalObject + ');')\n                set ctx.values.mainObjectCreated = true\n            _ ctx.w('const ' + model.wzName + ' = docx.Media.addImage(')\n            # _ ctx.w('  ' + ctx.values.docxMainObject + ', 300, 300,')\n            _ ctx.w('  ' + ctx.values.docxMainObject + ',')\n            _ ctx.w('  fs.readFileSync(\"' + verify.replaceAll(model.src, '\\\\', '\\\\\\\\') + '\")')\n            _ ctx.w(');')\n            r_cb()\n\n        async-md( imageRef )\n            var docxParent = ctx.values.docxStack[ctx.values.docxStack.length-1]\n            _ ctx.w(docxParent + '.children.push(' + model.wzName + ');')\n            r_cb()\n\n        +\n        headings( 1 )\n        headings( 2 )\n        headings( 3 )\n        headings( 4 )\n        headings( 5 )\n        headings( 6 )\n\n        textNode.js( text ) \n        textNode.js( bold ) \n            _ ctx.w(docxParent + '.bold = true;')\n        textNode.js( italic ) \n            _ ctx.w(docxParent + '.italic = true;')\n        nodeProperty.js( boldProp, bold, true )\n        nodeProperty.js( italicProp, italic, true )\n        nodeProperty.js( emphasisMark, emphasisMark, true )\n        nodeProperty.js( strike, strike, true )\n        nodeProperty.js( doubleStrike, doubleStrike, true )\n        nodeProperty.js( superScript, superScript, true )\n        nodeProperty.js( subScript, subScript, true )\n        nodeProperty.js( smallCaps, smallCaps, true )\n        nodeProperty.js( allCaps, allCaps, true )\n\n        nodeProperty.js( xbreak, break, true )\n        nodeProperty.js( size, size )\n        nodeProperty.js( color, color, string )\n        nodeProperty.js( fill, fill, string )\n        nodeProperty.js( xname, name, string )\n        nodeProperty.js( highlight, highlight, string )\n        nodeProperty.js( style, style, string )\n        nodeProperty.js( next, next, string )\n        nodeProperty.js( basedOn, basedOn, string )\n        nodeProperty.js( before, before )\n        nodeProperty.js( after, after )\n        nodeProperty.js( line, line )\n        nodeProperty.js( link, link, string )\n        nodeProperty.js( linkText, text, string )\n        nodeProperty.js( value, value, string )\n        nodeProperty.js( space, space )\n\n        nodePropertyChoice.js( xtype)\n            if model.wzParent.wzElement == 'shading'\n                _ ctx.w(docxParent + '.type = docx.ShadingType.' + model.wzName + ';')\n            elif model.wzParent.wzElement == 'width'\n                _ ctx.w(docxParent + '.type = docx.WidthType.' + model.wzName + ';')\n            elif model.wzParent.wzElement == 'tabStop'\n                _ ctx.w(docxParent + '.type = docx.TabStopType.' + model.wzName + ';')\n            elif model.wzParent.wzElement == 'underline'\n                _ ctx.w(docxParent + '.type = docx.UnderlineType.' + model.wzName + ';')\n            elif model.wzParent.wzElement == 'hyperlinkDef'\n                if model.wzName && model.wzName.length > 0\n                    _ ctx.w(docxParent + '.type = docx.HyperlinkType.' + model.wzName + ';')\n                else\n                    _ ctx.w(docxParent + '.type = docx.HyperlinkType.EXTERNAL;')\n            else\n                _ ctx.w(docxParent + '.type = \"' + model.wzName + '\";')\n        \n        nodePropertyChoice.js( position )\n            if model.wzParent.wzElement == 'tabStop'\n                if verify.isNumber(model.wzName)\n                    _ ctx.w(docxParent + '.position = ' + model.wzName + ';')\n                else\n                    _ ctx.w(docxParent + '.position = docx.TabStopPosition.' + model.wzName + ';')\n            else\n                _ ctx.w(docxParent + '.position = ' + model.wzName + ';')\n\n        nodePropertyChoice.js( alignment )\n            _ ctx.w(docxParent + '.alignment = docx.AlignmentType.' + model.wzName + ';')\n        \n        nodePropertyChoice.js( hyperlinkRef )\n            _ ctx.w(docxParent + '.children.push(new docx.HyperlinkRef(\"' + model.wzName + '\"));')\n\n        $*\n        async-md( xtype )\n            var docxParent = ctx.values.docxStack[ctx.values.docxStack.length-1]\n            if model.wzParent.wzElement == 'shading'\n                _ ctx.w(docxParent + '.type = docx.ShadingType.' + model.wzName + ';')\n            elif model.wzParent.wzElement == 'width'\n                _ ctx.w(docxParent + '.type = docx.WidthType.' + model.wzName + ';')\n            else\n                _ ctx.w(docxParent + '.type = \"' + model.wzName + '\";')\n            r_cb()\n        *$\n        +\n        async-md( font )\n\n            docxNode.js( fnt )\n            _ ctx.w('const ' + docxNode + ' = {};')\n        \n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                @ noindent\n                a_cb()\n                    _ ctx.w(docxParent + '.font = ' + docxNode + ';')\n                    _ ctx.values.docxStack.pop()\n                    r_cb()\n\n        +\n        async-md( shading )\n\n            docxNode.js( shd )\n            _ ctx.w('const ' + docxNode + ' = {};')\n        \n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                @ noindent\n                a_cb()\n                    _ ctx.w(docxParent + '.shading = ' + docxNode + ';')\n                    _ ctx.values.docxStack.pop()\n                    r_cb()\n\n        objectNode.js( table, docx.Table )   \n            _ ctx.w(docxNode + '.rows = [];')\n            $append close\n                _ ctx.w(docxParent + '.children.push(' + docxNode + 'Obj);')\n\n        objectNode.js( tr, docx.TableRow )   \n            _ ctx.w(docxNode + '.children = [];')\n            _ ctx.w(docxNode + '.layout = docx.TableLayoutType.FIXED;')\n            $append close\n                _ ctx.w(docxParent + '.rows.push(' + docxNode + 'Obj);')\n\n        objectNode.js( td, docx.TableCell )   \n            _ ctx.w(docxNode + '.children = [];')\n            $append close\n                _ ctx.w(docxParent + '.children.push(' + docxNode + 'Obj);')\n\n        objectNode.js( width )   \n            $append close\n                _ ctx.w(docxParent + '.width = ' + docxNode + ';')\n\n        objectNode.js( underline )   \n            $append close\n                _ ctx.w(docxParent + '.underline = ' + docxNode + ';')\n\n        objectNode.js( styles )\n            $append close\n                _ ctx.w(docxParent + '.styles = ' + docxNode + ';')\n\n        objectNode.js( xdefault )\n            $append close\n                _ ctx.w(docxParent + '.default = ' + docxNode + ';')\n\n\n        objectNode.js( run )\n            $append close\n                _ ctx.w(docxParent + '.run = ' + docxNode + ';')\n        \n        objectNode.js( tabStop )\n            $append close\n                _ ctx.w(docxParent + '.tabStops.push(' + docxNode + ');')\n\n        objectNode.js( styleDef )\n            if model.wzParent.wzElement == 'paragraphStyles'\n                _ ctx.w(docxNode + '.id = \"' + model.wzName + '\";')\n            $append close\n                if model.wzParent.wzElement == 'xdefault'\n                    _ ctx.w(docxParent + '.' + model.wzName + ' = ' + docxNode + ';')\n                else\n                    _ ctx.w(docxParent + '.push(' + docxNode + ');')\n\n        objectNode.js( spacing )\n            $append close\n                _ ctx.w(docxParent + '.spacing = ' + docxNode + ';')\n\n        objectNode.js( hyperlinks )\n            $append close\n                _ ctx.w(docxParent + '.hyperlinks = ' + docxNode + ';')\n\n        objectNode.js( hyperlinkDef )\n            $append close\n                _ ctx.w(docxParent + '.' + model.wzName + ' = ' + docxNode + ';')\n\n        objectNode.js( border )\n            $append close\n                _ ctx.w(docxParent + '.border = ' + docxNode + ';')\n\n        $$ objectNodeSimple.js( border )\n        objectNodeSimple.js( top )\n        objectNodeSimple.js( left )\n        objectNodeSimple.js( right )\n        objectNodeSimple.js( bottom )\n\n        arrayNode.js( paragraphStyles )\n            $append close\n                _ ctx.w(docxParent + '.paragraphStyles = ' + docxNode + ';')\n\n\n        async-md( ul )\n            # log 'tag section, value', model.wzName\n            set ctx.values.bulletLevel++\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                @ noindent\n                a_cb()\n                    set ctx.values.bulletLevel--\n                    r_cb()\n\n        async-md( ol )\n            # log 'tag section, value', model.wzName\n            set ctx.values.bulletLevel++\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                @ noindent\n                a_cb()\n                    set ctx.values.bulletLevel--\n                    r_cb()\n\n        objectNode.js( li, docx.Paragraph )\n            _ ctx.w(docxNode + '.children = [];')\n            _ ctx.w(docxNode + '.tabStops = [];')\n            _ ctx.w(docxNode + '.bullet = { level: ' + (ctx.values.bulletLevel-1) + '};')\n            $append close\n                _ ctx.w(docxParent + '.children.push(' + docxNode + 'Obj);')\n"
                }
            ],
            "transformations": [
                {
                    "name": "docx/extended",
                    "schema": "docx",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.docx\\.wizzi\\lib\\artifacts\\docx\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: '',\n            name: 'extended',\n            schema: 'docx',\n            checkSchema: true\n        };\n    v08/lib/artifacts/trans(&md)\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.go",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.go",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.go\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.go/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.go\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.go",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "go"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.go\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.go-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.go\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.go",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "go"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "go",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.go\\.wizzi-override\\lib\\wizzi\\schemas\\go.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema go\n\n    e statement\n\t\t# A statement line node with unlimited depth.\n\t\t# Is the schema base node.\n\t\t# In itself works as a comment line.\n\t\ttag #\n\t\tr statement/s\n\n\te codeline : statement\n\n    e go : statement\n\t\tis-root\n        any codeline/statements\n\n\te param\n\n    e function : statement\n        a rtype\n            # return type\n        r param/s\n        any codeline/statements\n\t\n    e return : statement\n\n    $$ $include go/..."
                }
            ],
            "artifacts": [
                {
                    "name": "go/document",
                    "schema": "go",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.go\\.wizzi-override\\lib\\artifacts\\go\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.go',\n            name: 'document',\n            schema: 'go',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n        $append main\n            _ md.go\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        async-md( go )\n            _ ctx.w('<go>')\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                {\n                    @ indent true\n                a_cb()\n                    _ ctx.w('</go>')\n                    r_cb()\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n"
                },
                {
                    "name": "go/package",
                    "schema": "go",
                    "artifact": "package",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.go\\.wizzi-override\\lib\\artifacts\\go\\package\\gen\\main.js.ittf",
                    "content": "module\r\n    kind es6\r\n    $\r\n        var md = {\r\n            schema: 'go',\r\n            name: 'package',\r\n            checkSchema: true,\r\n            preprocess: false,\r\n            mainStart: true,\r\n            mainFinish: true,\r\n        }\r\n    \r\n    gen( &md )\r\n        $append imports\r\n            var writers = require('./writers/index')\r\n\r\n        $append main\r\n            \r\n            var item_count = 0\r\n            iife next\r\n                var item = model.statements[item_count++]\r\n                if !item\r\n                    return\r\n                        _ terminate_gen\r\n                            @ model\r\n                            @ ctx\r\n                _ writers.gen\r\n                    @ item\r\n                    @ ctx\r\n                    a_cb()\r\n                        _ next\r\n\r\n        function mainStart\r\n            param model\r\n            param ctx\r\n            var name = model.wzName || 'main'\r\n            _ ctx.w('package ' + name)\r\n            _ ctx.w('')\r\n            _ ctx.w('import \"fmt\"')\r\n            _ ctx.w('')\r\n        \r\n        function mainFinish\r\n            param model\r\n            param ctx"
                }
            ],
            "transformations": [
                {
                    "name": "go/extended",
                    "schema": "go",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.go\\.wizzi-override\\lib\\artifacts\\go\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.go',\n            name: 'extended',\n            schema: 'go',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.graphql",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.graphql",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.graphql\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.graphql/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.graphql\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.graphql",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "graphql"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.graphql\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.graphql-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.graphql\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.graphql",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "graphql"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "graphql",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.graphql\\.wizzi-override\\lib\\wizzi\\schemas\\graphql.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema graphql\n    \n    # A schema modeling a graphql client-server implementation\n\n    $$ preserve-tags true\n    mtree-is-preprocessed true\n    $$ unknown-element-replacer text\n\t\n    export-to json\n\n\te text\n        tag +\n        r text/s\n\n    e comment\n\t\ttag #\n        r comment/s\n\t\n\te commentable\n        is-abstract\n\t\tr comment/s\n\n\te basenode : commentable\n        is-abstract\n        r directive/s\n\n    # https://spec.graphql.org/draft/#sec-Document   \n    # Document\n    #  Definitionlist\n    #  Definition\n    #    ExecutableDefinition\n    #    TypeSystemDefinitionOrExtension\n    #  ExecutableDocument\n    #    ExecutableDefinitionlist\n    #  ExecutableDefinition\n    #    OperationDefinition\n    #    FragmentDefinition         \n\n\te graphql : basenode\n\t\tis-root\n        r typeDef/s\n\t\tr operation/s\n        r selectionSet\n            one-to-one\n        r fragment/s\n\n    $include graphql/1_directives\n    $include graphql/2_language\n\t$include graphql/variables\n    $include graphql/typeDefs\n\t$include graphql/fieldDefs\n\t$include graphql/values\n    $include graphql/types\n    $include graphql/objects\n\n"
                }
            ],
            "artifacts": [
                {
                    "name": "graphql/document",
                    "schema": "graphql",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.graphql\\.wizzi-override\\lib\\artifacts\\graphql\\document\\gen\\main.js.ittf",
                    "content": "module wizzi-web@${wzCtx.version}.lib.artifacts.graphql.document.gen.main\r\n\tkind jsfile\r\n\r\n\tvar myname = 'wizzi-web.lib.artifacts.graphql.schema.gen.main';\r\n\t+\r\n\tvar util = require('util')\r\n\tvar async = require('async')\r\n\tvar verify = require('wizzi-utils').verify;\r\n\t+\r\n\tvar lineParser = require('../../../utils/lineParser')\r\n\t+\r\n\tvar md = module.exports = {}\r\n\tset md.stm = {}\r\n\r\n\tset md.gen\r\n\t\tfunction gen\r\n\t\t\t{ model\r\n\t\t\t{ ctx\r\n\t\t\tcallback\r\n\t\t\t# log myname, 'enter', 'ctx.values', ctx.values\r\n\t\t\t# check the model is a wizzi model of type 'graphql'\r\n\t\t\tif model.wzElement !== 'graphql'\r\n\t\t\t\treturn\r\n\t\t\t\t\t_ callback\r\n\t\t\t\t\t\t_ ctx.error\r\n\t\t\t\t\t\t\t@ myname + \" error: the model paramater should be an 'graphql' wizzi model\"\r\n\t\t\t\t\t\t\t@ model\r\n\t\t\t_ md.graphql\r\n\t\t\t\t@ model\r\n\t\t\t\t@ ctx\r\n\t\t\t\ta_cb()\r\n\t\t\t\t\tr_cb( ctx )\r\n\r\n\tasync-md( graphql )\r\n\r\n\t\t# log \"Object.keys(model)\", Object.keys(model), Object.keys(model.selectionSet)\r\n        _ async.mapSeries\r\n\t\t\t@ model.typeDefs\r\n\t\t\t_ md.typeDef\r\n\t\t\t\t@ ctx\r\n\t\t\ta_cb()\r\n\t\t\t\t_ async.mapSeries\r\n\t\t\t\t\t@ model.operations\r\n\t\t\t\t\t_ md.operation\r\n\t\t\t\t\t\t@ ctx\r\n\t\t\t\t\ta_cb()\r\n                        _ async.mapSeries\r\n                            @ model.fragments\r\n                            _ md.fragmentCtx\r\n                                @ ctx\r\n                            a_cb()\r\n                                if model.selectionSet\r\n                                    _ md.selectionSet\r\n                                        @ model.selectionSet\r\n                                        @ ctx\r\n                                        a_cb()\r\n                                            _ ctx.deindent\r\n                                            r_cb()\r\n                                else\r\n                                    r_cb()\r\n\r\n\t$include typeDefs\r\n\t$include executable\r\n\t$include values\r\n\t$include arguments\r\n    $include directives\r\n\r\n\tfunction getArgumentDeclaration\r\n\t\tparam model\r\n\t\tparam callback\r\n\t\tvar p = lineParser.parseNameValueRaw(model.wzName, model)\r\n\t\tvar name = p.name()\r\n\t\tvar value = p.value()\r\n\t\tvar ret = [ name ]\r\n\t\tif value\r\n\t\t\t_ ret.push(' : ')\r\n\t\t\t_ ret.push( value )\r\n\t\t\tr_cb( ret.join('') )\r\n\t\telse\r\n\t\t\tif model.value\r\n\t\t\t\t_ md.value\r\n\t\t\t\t\t@ model.value\r\n\t\t\t\t\t@ ctx\r\n\t\t\t\t\ta_cb( result )\r\n\t\t\t\t\t\t_ ret.push(' : ')\r\n\t\t\t\t\t\t_ ret.push( result )\r\n\t\t\t\t\t\tr_cb( ret.join('') )\r\n\r\n\tfunction getTypedArgumentDeclaration\r\n\t\tparam model\r\n\t\tvar type = model.isList ? '[' + model.type + ']' : model.type\r\n\t\tset type = model.isRequired ? type + '!' : type\r\n\t\tvar ret = [ model.wzName ]\r\n\t\tif model.type\r\n\t\t\t_ ret.push(' : ')\r\n\t\t\t_ ret.push(type)\r\n\t\treturn ret.join('')\r\n\r\n\tfunction getVariableDeclaration\r\n\t\tparam model\r\n\t\tvar name = model.wzName\r\n\t\tvar type = model.type\r\n\t\tvar ret = [ name ]\r\n\t\tif type\r\n\t\t\t_ ret.push(' : ')\r\n\t\t\t_ ret.push(type)\r\n\t\treturn ret.join('')"
                }
            ],
            "transformations": [
                {
                    "name": "graphql/extended",
                    "schema": "graphql",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.graphql\\.wizzi-override\\lib\\artifacts\\graphql\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.graphql',\n            name: 'extended',\n            schema: 'graphql',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ],
            "wizzifiers": [
                {
                    "name": "graphql",
                    "schema": "graphql",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.graphql\\.wizzi-override\\lib\\wizzifiers\\graphql\\wizzifier.js.ittf",
                    "content": "module\n    $\n        var schemaName = 'graphql';\n    kind es6\n    basewizzifier()\n        $append imports\n            var graphql_parser = require('graphql/language/parser')\n            var cleanAST = require('./cleanAST')\n            function parseInternal\n                param tobeWizzified\n                param options\n                param callback\n                var syntax\n                try\n                    set syntax\n                         _ graphql_parser.parse(tobeWizzified)\n                    _ cleanAST(syntax)\n                catch ex\n                    return\n                        _ callback\n                            @ ex\n                return\n                    _ callback\n                        @ null\n                        @ syntax\n        var format\n            function\n                param parent\n                param ast\n                param options\n                if !ast\n                    throw new Error('missing ast. parent is: ' + util.inspect(parent, { depth: 2 }))\n                if parent === null\n                    if options.starter\n                        set options.starter = false\n                    elif options.returnText\n                        # ok\n                    else\n                        _ showstack(options)\n                        throw new Error('parent is null.' + util.inspect(ast, 4))\n                if options.verbose\n                    info 'ast.kind', ast.kind\n                var kind = ast.kind === 'arguments' ? 'xarguments' : ast.kind\n                var formatter = format[kind]\n                if formatter\n                    _ options.stack.push(ast)\n                    var result = formatter(parent, ast, options)\n                    _ options.stack.pop()\n                    return result\n                else\n                    throw new Error('no formatter for kind: ' + ast.kind)\n        function wizzify\n            param tobeWizzified\n            param options\n            param callback\n            set options = options || {};\n            set options.input = tobeWizzified\n            set options.stack = []\n            set options.formatTextNodes = []\n            set options.verbose = true\n            _ parseInternal\n                @ tobeWizzified\n                @ options\n                a_cb( syntax )\n                    log JSON.stringify(syntax, null, 2)\n                    var root\n                        {\n                            @ tag '${schemaName}'\n                            [ children\n                    _ format(root, syntax, options)\n                    return\n                        _ callback\n                            @ null\n                            @ root\n        $include helper_functions\n        function isKnownType\n            param type\n            return ['Int', 'Float', 'Boolean', 'String'].indexOf(type) > -1\n\n        function getTypeName\n            param type\n            return isKnownType(type) ? type.toLowerCase() : type\n\n        f( Name, name )\n            name( value )\n            #\n                # loog 'Name.tag', ret.tag\n                # loog 'Name.name', ret.name\n                # loog 'Name.textified', ret.textified\n\n        f( NonNullType, ! )\n            f_p_temp( type \n            # loog 'NonNullType.p_type', p_type\n            set ret.name = p_type.name\n\n        f( NamedType, namedType )\n            f_p_temp( name\n            # loog 'NamedType.p_name', ret, p_name\n            if isTextualNode(p_name)\n                set ret.name = getTypeName(getNodeText(p_name))\n                set ret.textified = ret.name\n            else\n                _ ret.children.push(p_name)\n\n        f( Document, skip)\n            f_a( definitions )\n\n        f( SchemaDefinition, schema\n            f_a( operationTypes\n            f_a( directives\n\n        f( OperationTypeDefinition, operation-type\n            tag( operation \n            f_p_temp( type \n            if isTextualNode(p_type)\n                set ret.name = getNodeText(p_type)\n            else\n                new Error('InterfaceTypeDefinition. Expected textual name: ' + JSON.stringify(node, null, 2))\n\n        f( ObjectTypeDefinition, {\n            f_p_temp( name \n            if isTextualNode(p_name)\n                set ret.name = getNodeText(p_name)\n            else\n                new Error('InterfaceTypeDefinition. Expected textual name: ' + JSON.stringify(node, null, 2))\n            f_a_temp( interfaces\n            if p_interfaces != null\n                foreach item in p_interfaces.children\n                    set item.tag = '&'\n                    _ ret.children.push(item)\n            f_a( fields\n            f_a( directives\n\n        f( FieldDefinition, field-def\n            f_p_temp( name \n            f_p_temp( type \n            if p_type.tag === 'namedType'\n                if node.arguments.length > 0\n                    set ret.tag = 'm'\n                    set ret.name = p_name.name\n                    _ ret.children.push\n                        {\n                            @ tag 'type'\n                            @ name p_type.name\n                            [ children\n                else\n                    set ret.tag = p_type.name\n                    set ret.name = p_name.name\n            else\n                _ ret.children.push(p_name)\n                _ ret.children.push(p_type)\n            f_a( arguments\n            f_a( directives\n\n        f( ObjectTypeExtension, extend-{\n            f_p_temp( name \n            if isTextualNode(p_name)\n                set ret.name = getNodeText(p_name)\n            else\n                new Error('InterfaceTypeDefinition. Expected textual name: ' + JSON.stringify(node, null, 2))\n            f_a_temp( interfaces\n            if p_interfaces != null\n                foreach item in p_interfaces.children\n                    set item.tag = '&'\n                    _ ret.children.push(item)\n            f_a( fields\n            f_a( directives\n\n        f( InterfaceTypeDefinition, interface\n            f_p_temp( name \n            if isTextualNode(p_name)\n                set ret.name = getNodeText(p_name)\n            else\n                new Error('InterfaceTypeDefinition. Expected textual name: ' + JSON.stringify(node, null, 2))\n            f_a( fields\n            f_a( directives\n\n        f( InterfaceTypeExtension, extend-interface\n            f_p_temp( name \n            if isTextualNode(p_name)\n                set ret.name = getNodeText(p_name)\n            else\n                new Error('InterfaceTypeDefinition. Expected textual name: ' + JSON.stringify(node, null, 2))\n            f_a( fields\n            f_a( directives\n\n        f( UnionTypeDefinition, union\n            f_p_temp( name \n            if isTextualNode(p_name)\n                set ret.name = getNodeText(p_name)\n            else\n                new Error('InputObjectTypeDefinition. Expected textual name: ' + JSON.stringify(node, null, 2))\n            f_a( types\n            foreach item in ret.children\n                if item.tag === 'namedType'\n                    set item.tag = '|'\n            f_a( directives\n\n        f( ListType, [\n            f_p( type \n\n        f( ScalarTypeDefinition, scalar\n            f_p( name \n            f_p( description, false \n            f_a( directives\n\n        f( EnumTypeDefinition, enum\n            f_p( name \n            f_a( values\n            f_a( directives\n\n        f( EnumValueDefinition, @\n            f_p( name \n            f_a( directives\n\n        format( OperationDefinition $$ , oper\n            $*\n            tag( operation \n            f_a( variableDefinitions\n            f_a( directives\n            f_p( selectionSet \n            *$\n            var ret\n            if node.operation == 'query' \n                \\b && arrayIsEmpty(node.variableDefinitions) \n                \\b && arrayIsEmpty(node.directives) \n                set ret = parent\n            else\n                var ret\n                    {\n                        @ tag node.operation\n                        @ name ''\n                        @ isText false\n                        @ textified null\n                        @ source options.input.substring(node.start, node.end)\n                        [ children\n                f_a( variableDefinitions\n                f_a( directives\n            _ format\n                @ ret\n                @ node.selectionSet\n                @ options\n\n        f( SelectionSet, {\n            f_a( selections\n\n        f( InputValueDefinition, input\n            f_p_temp( name \n            f_p_temp( type \n            f_p_temp( defaultValue, false\n            # loog 'InputValueDefinition', p_type, p_name\n            if p_type.tag === 'namedType'\n                set ret.tag = p_type.name\n                set ret.name = p_name.name\n            else\n                _ ret.children.push(p_name)\n                _ ret.children.push(p_type)\n            if p_defaultValue != null\n                set p_defaultValue.tag = 'default'\n                _ ret.children.push(p_defaultValue)\n            f_a( directives\n\n        f( InputObjectTypeDefinition, input\n            f_p_temp( name \n            if isTextualNode(p_name)\n                set ret.name = getNodeText(p_name)\n            else\n                new Error('InputObjectTypeDefinition. Expected textual name: ' + JSON.stringify(node, null, 2))\n            f_a_in_tag( fields, {\n            f_a( directives\n\n        f( Field, .\n            name( name.value\n            f_p_temp( alias, false\n            if p_alias != null\n                set p_alias.tag = 'as'\n                _ ret.children.push(p_alias)\n            \n            f_a( arguments\n            f_p( selectionSet, false\n            f_a( directives\n\n        f( Argument, @\n            f_p_temp( name\n            if isTextualNode(p_name)\n                set ret.name = getNodeText(p_name)\n            f_p( value\n\n        f( IntValue, int\n            name( value )\n\n        f( FloatValue, float\n            name( value )\n\n        f( BooleanValue, boolean\n            name( value )\n\n        f( NullValue, null\n            name( value )\n\n        f( StringValue, string\n            name( value )\n            var lines = ret.name.split(/\\n\\r|\\n|\\r/)\n            if lines.length > 1\n                set ret.name = lines[0]\n                for var i = 1; i<lines.length;i++\n                    _ ret.children.push\n                        {\n                            @ tag '\\\\n'\n                            @ name lines[i]\n                            [ children\n\n        f( ListValue, [\n            f_a( values\n\n        f( ObjectValue, {\n            f_a( fields\n\n        f( ObjectField, @\n            f_p( name \n            f_p( value \n\n        f( FragmentDefinition, fragment\n            f_p( name \n            f_p_tag( typeCondition , on\n            #\n                f_p_temp( typeCondition \n                    if p_typeCondition != null\n                        set p_typeCondition.tag = 'on'\n                        _ ret.children.push(p_typeCondition)\n            f_p( selectionSet, false\n            f_a( directives\n\n        f( FragmentSpread, ...\n            f_p( name \n            f_a( directives\n\n        f( InlineFragment, ...on\n            f_p_temp( typeCondition, false\n            if p_typeCondition != null\n                if isTextualNode(p_typeCondition)\n                    set ret.name = getNodeText(p_typeCondition)\n                    set ret.textified = ret.name\n                else\n                    _ ret.children.push(p_typeCondition)\n            f_p( selectionSet, false\n            f_a( directives\n\n\n        f( VariableDefinition, var-def\n            f_p( variable \n            f_p( type\n\n        f( Variable, var\n            f_p_temp( name\n            if isTextualNode(p_name)\n                set ret.name = getNodeText(p_name)\n                set ret.textified = ret.name\n            else\n                _ ret.children.push(p_name)\n\n        f( DirectiveDefinition, %-def\n            f_p( name\n            f_a( arguments\n            f_a( locations\n\n        f( Directive, %\n            f_p( name \n            f_a( arguments\n\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.html",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.html",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.html\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.html/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.html\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.html",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "html"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.html\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.html-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.html\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.html",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "html"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "html",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.html\\.wizzi-override\\lib\\wizzi\\schemas\\html.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema html\n\n\t# A schema modeling an html document.\n\n\t# ATTENTION in this model the classical python like comment char sharp(#) is replaced\n\t#           by the minus(-) char, see the comment element.\n\t#           The sharp(#) is used for the _sharp extension element.\n\n\t# Preprocess the mTree before loading the wizzi model\n\tmtree-is-preprocessed\n\n\te element\n\t\t# A generic html element.\n\t\t# The wzName, if present becames the first TEXTNODE of the html element.\n\t\t# You should find a proper schema element that extends this one for every valid html element. \n\t\t# In any case this element is not abstract and can be used for eventual missing html elements.\n\t\t# In this case must contain a name-value pair separated by a blank: name is\n\t\t# the html element name and value (optional), if present, is the first TEXTNODE of the element.\n\n\t\ttag <\n\t\t\n\t\t$include html/spec-globals-attributes\n\t\ta aria-*\n\t\ta data-*\n\t\ta ng-*\n\t\ta ui-*\n\t\ta v-*\n\t\ta on*\n\t\ta @*\n\t\ta role\n\t\t\n\t\tr attribute/s\n\t\tr element/s\n\n\te html : element\n\t\t# The root element.\n\t\ta doctype\n\t\ta manifest\n\t\ta version\n\t\tis-root\n\n\t$include html/spec-elements\n\t\n\t#\n\t# Extension element that do not match any tag of the HTML spec.\n\t#\n\n\te attribute\n\t\t# Used for Html element attributes not declared in this schema.\n\t\t# The wzName must contain a name-value pair separated by a blank (value is optional).\n\t\t# Name is the attribute name and value, if not empty, is the attribute value.\n\n\t\ttag @\n\n\te _dot : element\n\t\t# short for <div class='${'$'}{wzName}' [ attributes ]>\n\t\t\n\t\ttag .\n\t\n\te _sharp : element\n\t\t# short for <div id='${'$'}{wzName}' [...]> ...\n\t\t\n\t\ttag #\n\n\te _js : element\n\t\t# When has no children is short for\n\t\t#   html4: <script src=\"${'$'}{wzName}\" type=\"text/javascript\" [ attributes ]></script>\n\t\t#   html5: <script src=\"${'$'}{wzName}\"></script>\n\t\t# When has children is the root of an inline script ( script html element )\n\t\t\n\t\ttag js\n\n\t\tr statement/s\n\n\te_tag( jsBabel, js-babel, element )\n\t\t# When has no children is short for\n\t\t#   html5: <script src=\"${'$'}{wzName}\" type=\"text/babel\"></script>\n\t\t# When has children is the root of an inline script ( script html element )\n\t\t\n\t\tr statement/s\n\n\te json : element\n\t\tinclude json {\n\n\t$include html/js\n\t\n\te _css : element\n\t\t# When has no children is short for <link href=\"${'$'}{wzName}\" rel=\"stylesheet\" [ attributes ]> \n\t\t# When has children is the root of an inline stylesheet ( style html element )\n\t\t\n\t\ttag css\n\n\t\tr rule/s\n\n\t$include html/css\n\n\te _text : element\n\t\t# The wzName becomes a TEXTNODE rewritten inline in the output document.\n\t\t\n\t\ttag +\n\t\n\te _textLF : element\n\t\t# The wzName becomes a TEXTNODE rewritten in the output document followed by a LF char.\n\t\t\n\t\ttag ++\n\t\n\te comment : element\n\t\t# The wzName is the comment text.\n\t\t\n\t\ttag -\n\n\t#\n\t# Disambiguation extension tags that do not match any tag of the HTML spec.\n\t#\n\n\te @title : element\n\t\t# The title html element.\n\t\t# The title tag is ambiguous it can be both a global attribute and a child element.\n\n\te @style : element\n\t\t# The html style element.\n\t\t# The style tag is ambiguous it can be both a global attribute and a child element.\n\t\ta media\n\t\ta nonce\n\t\ta type\n\t\ta scoped\n\t\tinclude css\n\n\te lorem : element\n\t\t# the wzName = count\n\t\ta units\n\t\t\trestrict\n\t\t\t\tenum words\n\t\t\t\tenum sentences\n\t\t\t\tenum paragraphs\n\t\t\tdefault words\n\t\ta minWords\n\t\t\ttag min-words\n\t\t\tdefault 5\n\t\ta maxWords\n\t\t\ttag max-words\n\t\t\tdefault 15\n\t\ta minSentences\n\t\t\ttag min-sentences\n\t\t\tdefault 3\n\t\ta maxSentences\n\t\t\ttag max-sentences\n\t\t\tdefault 7\n\t\ta htmlTag\n\t\t\ttag html-tag\n\t\t\tdefault p\n\n\te ittfPanel : element\n        tag ittf-panel\n\n\te jsPanel : element\n        tag js-panel\n\n\te bashPanel : element\n        tag bash-panel\n\n    $include html/includes"
                }
            ],
            "artifacts": [
                {
                    "name": "html/document",
                    "schema": "html",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.html\\.wizzi-override\\lib\\artifacts\\html\\document\\gen\\main.js.ittf",
                    "content": "module wizzi.plugin.html@${wzCtx.version}.lib.artifacts.html.document.gen.main\n    kind es6\n    $include versions\n    $\n        var md = {\n            plugin: 'wizzi.plugin.html',\n            name: 'document',\n            schema: 'html',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n            var included_writers = require('./included_writers')\n            var utilNode = require('../../../utils/utilNode')\n            var lineParser = require('../../../utils/lineParser')\n            var lorem = require('wizzi-utils').lorem\n            var pretty = require('wizzi-utils').pretty\n            var myname = 'wizzi.plugin.html.artifacts.document.gen.main'\n            var myGenItemsStackCount = 0\n        $append main\n            _ main_init\n                @ model\n                @ ctx\n            if true\n                _ md.myGetGenItem\n                    @ ctx\n                    (\n                        @ model\n                        a_cb( notUsed )\n                            if ctx.artifactGenerationErrors.length > 0\n                                r_cb_err( ctx.artifactGenerationErrors )\n                            else\n                                # generation OK\n                                r_cb( ctx )\n            else\n                _ md.html\n                    @ model\n                    @ ctx\n                    a_cb( )\n                        if ctx.artifactGenerationErrors.length > 0\n                            r_cb_err( ctx.artifactGenerationErrors )\n                        else\n                            # generation OK\n                            r_cb( ctx )\n\n        set md.myGetGenItem\n            function\n                param ctx\n\n                return\n                    function\n                        param model\n                        param callback\n                        # loog 'wizzi-web.artifacts.html.main', model.wzElement\n\n                        if ['_text','_textLF'].indexOf(model.wzElement) >= 0\n                            # model.wzName is a TEXTNODE\n                                \n                            # VIA 22/10/18 see wizzi-mtree.loader.nodifier blank escapes ( \\b )\n                            #     preserve a blank first char (coded between single hyphens)\n                            #     var text = verify.startsWith(model.wzName, \"' '\") ? '&nbsp;' + model.wzName.substr(3) : model.wzName;\n                            var text = model.wzName\n\n                            # loog 'text', text\n                                \n                            if ctx.__iscode || model.wzElement === '_textLF'\n                                _ ctx.w(text)\n                            else\n                                _ ctx.write(text)\n\n                            return\n                                _ md.myGenItems\n                                    @ model.elements\n                                    @ ctx\n                                    {\n                                        @ indent false\n                                    @ callback\n                            \n                        elif ['_style'].indexOf(model.wzElement) >= 0 && model.get_css\n                            # must be here because _style with model.get_css undefined\n                            # has its handler\n                            _ include_writers.writeIncludeCss\n                                @ ctx\n                                @ model\n                                @ callback\n\n                        elif md[model.wzElement]\n                            _ md[model.wzElement]\n                                @ model\n                                @ ctx\n                                a_cb( done )\n                                    if done\n                                        # ok, processed\n                                        return\n                                            _ callback\n                                    else\n                                        return\n                                            _ process.nextTick\n                                                =>\n                                                    _ md.standardElement\n                                                        @ model\n                                                        @ ctx\n                                                        @ callback\n                        else\n                            return\n                                _ process.nextTick\n                                    =>\n                                        _ md.standardElement\n                                            @ model\n                                            @ ctx\n                                            @ callback\n\n        set md.myGenItems\n            function\n                param items\n                param ctx\n                param options\n                param callback\n                var\n                    decl opt = options || {}\n                    decl from = opt.from || 0\n                    decl indent = typeof opt.indent === 'undefined' ? true : opt.indent\n\n                if indent\n                    _ ctx.indent()\n\n                var goitems = []\n                for var i = from; i < items.length; i++\n                    _ goitems.push(items[i])\n\n                set myGenItemsStackCount++\n                _ async.mapSeries\n                    @ goitems\n                    _ md.myGetGenItem\n                        @ ctx\n                    a_cb( notUsed )\n                        if indent\n                            _ ctx.deindent()\n                        set myGenItemsStackCount--\n                        return\n                            _ callback\n\n        async-md( html )\n            _ ctx.w('<html>')\n            _ md.myGenItems\n                @ model.nodes\n                @ ctx\n                {\n                    @ indent true\n                a_cb()\n                    _ ctx.w('</html>')\n                    r_cb()\n        async-md( standardElement )\n            # log myname, 'standardElement', 'model.wzTag', model.wzTag\n            _ preprocess(model, ctx)\n                \n            var voidEl = (model.wzTag in voidElements)\n                \n            _ ctx.write('<' + model.wzTag)\n                \n            foreach a in getAttrs(model)\n                if (a.name in attrsneedsvalue) || (a.value && a.value.length > 0)\n                    _ ctx.write(' ' + a.name + '=\"' + verify.unquote(a.value || '') + '\"')\n                else\n                    _ ctx.write(' ' + a.name)\n                \n            if voidEl\n                _ ctx.w(' />')\n                _ postprocess(model, ctx)\n                return\n                    _ callback\n\n            _ ctx.write('>')\n                \n            # check if the element has text line coded as children of the $. ittf command\n            # FIXME this hack require refactoring\n            var lt\n            if model.wzName === '__TS__'\n                set lt\n                    {\n                        @ text model.wzName\n            else\n                set lt = utilNode.inlinedTextToTextLines(model.wzName)\n                \n            if lt.text\n                # preserve a blank first char (coded between single hyphens)\n                var text = verify.startsWith(lt.text, \"' '\") ? '&nbsp;' + lt.text.substr(3) : lt.text\n                _ ctx.write(text)\n\n            if lt.lines\n                _ ctx.w()\n                var saveIndent\n                if ctx.__iscodeTag\n                    # we are inside a pre element, temporaly reset \n                    # to 0 the indentation depending from the node depth\n                    set saveIndent = ctx.forceIndent(0)\n                else\n                    _ ctx.indent()\n                foreach line in lt.lines\n                    _ ctx.w(line)\n                if ctx.__iscodeTag\n                    # restore indentation\n                    _ ctx.forceIndent(saveIndent);\n                else\n                    _ ctx.deindent()\n\n            if model.elements && model.elements.length > 0\n                if ctx.__iscodeTag && !ctx.__iscodeTag_started\n                    _ ctx.w('')\n                    set ctx.__iscodeTag_started = true\n                    var saveIndent = ctx.forceIndent(0)\n                    _ md.myGenItems\n                        @ model.elements\n                        @ ctx\n                        {\n                            @ indent false\n                        a_cb( notUsed )\n                            _ ctx.forceIndent(saveIndent)\n                            set ctx.__iscodeTag_started = false\n                            _ ctx.w('</' + model.wzTag + '>')\n                            _ postprocess(model, ctx)\n                            return\n                                _ callback\n                else\n                    var noinline = inline.indexOf(model.wzTag) < 0\n                    if noinline\n                        _ ctx.w('')\n                    _ md.myGenItems\n                        @ model.elements\n                        @ ctx\n                        {\n                            @ indent noinline\n                        a_cb( notUsed )\n                            _ ctx.w('</' + model.wzTag + '>')\n                            _ postprocess(model, ctx)\n                            return\n                                _ callback\n            else\n                _ ctx.w('</' + model.wzTag + '>')\n                _ postprocess(model, ctx)\n                return \n                    _ callback\n\n        async-md( html )\n            if !!ctx.values.forVueTemplate == false\n                if model.doctype\n                    _ ctx.w('<!doctype ' + model.doctype + '>')\n                else\n                    _ ctx.w('<!doctype html>')\n                _ ctx.write('<html')\n                foreach a in getAttrs(model)\n                    if a.name != 'doctype'\n                        if (a.name in attrsneedsvalue) || a.value && a.value.length > 0\n                            _ ctx.write(' ' + a.name + '=\"' + verify.unquote(a.value || '') + '\"')\n                        else\n                            _ ctx.write(' ' + a.name)\n                _ ctx.w('>')\n\n            _ async.mapSeries\n                @ model.elements\n                _ md.myGetGenItem\n                    @ ctx\n                a_cb( notUsed )\n                    _ ctx.w()\n                    if !!ctx.values.forVueTemplate == false\n                        _ ctx.w('</html>')\n                    r_cb(true)\n        \n        async-md( jsBabel )\n            if model.statements.length === 0\n                # is link to a js file not a script element\n                return\n                    _ callback(null, false)\n\n            _ ctx.w(\"<script>\")\n            foreach item in model.statements\n                _ js_statement.gen(item, ctx)\n            _ ctx.w(\"</script>\")\n            r_cb(true)\n\n        async-md( lorem )\n            var count = parseInt(model.wzName.trim())\n            var string\n                _ lorem\n                    {\n                        @ count count\n                        @ units model.units\n                        @ htmlTag model.htmlTag\n                        @ sentenceLowerBound model.minWords\n                        @ sentenceUpperBound model.maxWords\n                        @ paragraphLowerBound model.minSentences\n                        @ paragraphUpperBound model.maxSentences\n            _ ctx.w(string)\n            r_cb(true)\n        \n        async-md( ready )\n            _ ctx.w(\"<script>\")\n            _ ctx.indent()\n\n            if model.kind === 'jquery'\n\n                _ ctx.w('$(function() {')\n                _ ctx.indent()\n                foreach item in model.statements\n                    _ js_statement.gen(item, ctx)\n                _ ctx.deindent()\n                _ ctx.w('});')\n            \n            else\n\n                _ ctx.w('window.onload = function() {')\n                _ ctx.indent()\n                foreach item in model.statements\n                    _ js_statement.gen(item, ctx)\n                _ ctx.deindent()\n                _ ctx.w('};')\n\n            _ ctx.deindent()\n            _ ctx.w(\"</script>\")\n\n            r_cb(true)\n\n        async-md( ittfPanel )\n            _ ctx.w(\"<div class='ittf-panel'>\")\n            if model.wzMTreeData.title\n                _ ctx.w(\"<div class='ittf-panel-title'>\" + model.wzMTreeData.title + \"</div>\")\n            _ ctx.w(\"<pre class='prettyprint'><code>\")\n            _ prettifyIttf\n                @ model.wzMTreeData\n                a_cb( result )\n                    _ ctx.w(\"<div>\" + result.ittfPretty + '</div>')\n                    _ ctx.w(\"</code></pre></div>\")\n                    r_cb(true)\n\n        async-md( jsPanel )\n            _ ctx.w(\"<div class='js-panel'>\")\n            if model.wzMTreeData.title\n                _ ctx.w(\"<div class='js-panel-title'>\" + model.wzMTreeData.title + \"</div>\")\n            _ prettifyJs\n                @ model.wzMTreeData\n                a_cb( result )\n                    _ ctx.w('<pre><code class=\"hljs\">' + result.jsPretty + '</code></pre>')\n                    _ ctx.w('</div>')\n                    r_cb(true)\n\n        async-md( bashPanel )\n            _ ctx.w(\"<div class='bash-panel'>\")\n            if model.wzMTreeData.title\n                _ ctx.w(\"<div class='bash-panel-title'>\" + model.wzMTreeData.title + \"</div>\")\n            _ prettifyBash\n                @ model.wzMTreeData\n                a_cb( result )\n                    _ ctx.w('<pre><code class=\"hljs\">' + result.bashPretty + '</code></pre>')\n                    _ ctx.w('</div>')\n                    r_cb(true)\n\n        async-md( comment )\n            if ctx.__iscode\n                _ ctx.w(\"// \" + model.wzName)\n                r_cb(true)\n            \n            if model.elements.length == 0\n                if ctx.__inside_comment\n                    _ ctx.w(model.wzName ? (' ' + model.wzName) : '')\n                else \n                    _ ctx.w(\"<!-- \" + model.wzName + \" -->\")\n                set ctx.__needs_crlf = false\n                r_cb(true)\n\n            var enter_inside_comment = ctx.__inside_comment\n            if !ctx.__inside_comment\n                _ ctx.w('<!-- ')\n            _ ctx.indent()\n            if model.wzName.length > 0\n                _ ctx.w\n                    @ model.wzName\n            set ctx.__inside_comment = true\n            _ md.myGenItems\n                @ model.elements\n                @ ctx\n                { \n                    @ indent false\n                a_cb()\n                    set ctx.__inside_comment = enter_inside_comment\n                    _ ctx.deindent()\n                    if !enter_inside_comment\n                        _ ctx.w(' -->')\n                    set ctx.__needs_crlf = false\n                    r_cb(true)\n\n        +\n        $include includes\n        +\n        function main_init\n            param model\n            param ctx\n            \n            if (!!ctx.values.noGeneratorComments) == false\n                _ ctx.w('<!--')\n                _ ctx.w('    artifact generator: ' + __filename)\n                _ ctx.w('    package: wizzi-web@${versions['wizzi-web@next']}')\n                _ ctx.w('    primary source IttfDocument: ' + model.wzSourceFilepath('f1'))\n                if (!!ctx.values.wzConfigIsPackageDeploy) == false\n                    _ ctx.w('    utc time: ' + new Date().toUTCString())\n                _ ctx.w('-->')\n\n        $include prettifyIttf\n        $include prettifyJs\n        $include prettifyBash\n\n        function preprocess\n            param model\n            param ctx\n            if model.wzTag == '.'\n                set model.wzTag = 'div'\n                set model.class = model.wzName\n                set model.wzName = null\n            elif model.wzTag == '#'\n                set model.wzTag = 'div'\n                set model.id = model.wzName\n                set model.wzName = null\n            elif model.wzTag == '<'\n                var p = lineParser.parseNameValueRaw(model.wzName, model)\n                set model.wzTag = p.name()\n                if p.hasValue()\n                    set model.wzName = p.value()\n                else\n                    set model.wzName = null\n            elif model.wzTag == 'js'\n                set model.wzTag = 'script'\n                set model.src = model.wzName\n                set model.wzName = null\n            elif model.wzTag === 'css'\n                set model.wzTag = 'link'\n                set model.href = model.wzName\n                set model.rel = 'stylesheet'\n                set model.wzName = null\n            elif model.wzTag === '@title'\n                set model.wzTag = 'title'\n            elif model.wzTag === '@style'\n                set model.wzTag = 'style'\n            elif model.wzTag === 'js-babel'\n                set model.wzTag = 'script'\n                set model.src = model.wzName\n                set model.type = 'text/babel'\n            if incode.indexOf(model.wzTag) > -1\n                set ctx.__iscode = true\n            if ['code'].indexOf(model.wzTag) > -1\n                set ctx.__iscodeTag = true\n\n        function postprocess\n            param model\n            param ctx\n            if incode.indexOf(model.wzTag) > -1\n                set ctx.__iscode = false\n            if ['code'].indexOf(model.wzTag) > -1\n                set ctx.__iscodeTag = false\n\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n\n        function getAttrs\n            param e\n            \n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            \n            return retval\n\n        var inline\n            [\n                @ 'a'\n                @ 'img'\n                @ 'input'\n                @ 'li'\n                @ 'textarea'\n        \n        var incode\n            [\n                @ 'js'\n                @ 'css'\n                @ 'script'\n                @ 'style'\n                @ 'ready'\n            \n        var attrsneedsvalue\n            {\n                @ __proto__ null\n\n        var voidElements\n            {\n                @ __proto__  null\n                @ area  true\n                @ base  true\n                @ basefont  true\n                @ br  true\n                @ col  true\n                @ command  true\n                @ embed  true\n                @ frame  true\n                @ hr  true\n                @ img  true\n                @ input  true\n                @ isindex  true\n                @ keygen  true\n                @ link  true\n                @ meta  true\n                @ param  true\n                @ source  true\n                @ track  true\n                @ wbr  true\n\n                # common self closing svg elements\n                @ path  true\n                @ circle  true\n                @ ellipse  true\n                @ line  true\n                @ rect  true\n                @ use  true\n                @ stop  true\n                @ polyline  true\n                @ polygone  true        \n"
                }
            ],
            "transformations": [
                {
                    "name": "html/extended",
                    "schema": "html",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.html\\.wizzi-override\\lib\\artifacts\\html\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.html',\n            name: 'extended',\n            schema: 'html',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ],
            "wizzifiers": [
                {
                    "name": "html",
                    "schema": "html",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.html\\.wizzi-override\\lib\\wizzifiers\\html\\wizzifier.js.ittf",
                    "content": "module\n    $\n        var schemaName = 'html';\n    kind es6\n    basewizzifier()\n        $append imports\n            $$ COPY FROM old\n            +\n            var html_parser = require('./parser')\n\t\t    var cloner = require('./cloner')\n\t\t    var csswizzifier = null\n\t\t    var jswizzifier = null\n\n            $$ COPY FROM old\n            +\n            function parseInternal\n                param tobeWizzified\n                param options\n                param callback\n\n                var html = tobeWizzified\n                \n                if typeof callback === 'undefined'\n                    set callback = options\n                    set options = {}\n                set options = (options || {})\n\n                set options.wizziIncludes = options.wizziIncludes || []\n                \n                var wizziTree\n                    { \n                        @ children\n                            [ \n                var parser\n                    new html_parser.Parser\n                        { \n                            @ onopentag\n                                function \n                                    param tagname\n                                    param attribs\n                                    var ittfTag = tagname\n                                    if options.isForVue\n                                        if tagname.substr(0, 2) !== 'v-'\n                                            if ['router-link', 'router-view'].indexOf(tagname) < 0\n                                                if tagname[0] === tagname[0].toUpperCase() || tagname.indexOf('-') > -1\n                                                    set ittfTag = '< ' + tagname\n                                    else\n                                        if tagname[0] === tagname[0].toUpperCase() || tagname.indexOf('-') > -1\n                                            set ittfTag = '< ' + tagname\n                                    # log \"OpenTag \" + tagname, ittfTag, attribs\n                                    var n\n                                        { \n                                            @ tag ittfTag\n                                            @ name ''\n                                            @ attribs attribs\n                                            @ children\n                                                [ \n                                    set n.parent = wizziTree\n                                    _ wizziTree.children.push(n)\n                                    set wizziTree = n\n                            @ ontext\n                                function \n                                    param text\n                                    # log \"================= Text\", text, wizziTree.tag\n                                    var lines\n                                        _ file.splitLines\n                                            $$ BAX 27/2/21 no trim !!!important _ text.trim()\n                                            @ text\n                                    if wizziTree.swig\n                                        # loog '++++++++++ wizziTree.swig'\n                                        _ lines.forEach\n                                            function \n                                                param l\n                                                var n\n                                                    { \n                                                        @ tag '+'\n                                                        @ name l\n                                                        @ attribs\n                                                            { \n                                                        @ children\n                                                            [ \n                                                _ wizziTree.children.push(n)\n                                    elif 'script' === wizziTree.tag\n                                        var literal = lines.join('\\n')\n                                        # loog 'literal', literal, wizziTree.attribs['lang']\n                                        _ options.wizziIncludes.push\n                                            {\n                                                @ kind wizziTree.attribs['lang'] || wizziTree.attribs['language'] || 'js'\n                                                @ node wizziTree\n                                                @ literal literal\n                                    elif 'style' === wizziTree.tag\n                                        var literal = lines.join('\\n')\n                                        # loog 'literal', literal\n                                        _ options.wizziIncludes.push\n                                            {\n                                                @ kind 'css'\n                                                @ node wizziTree\n                                                @ literal literal\n                                    elif lines.length == 1\n                                        if wizziTree.children.length > 0\n                                            if lines[0].trim().length > 0\n                                                var n\n                                                    { \n                                                        @ tag '+'\n                                                        @ name lines[0]\n                                                        @ attribs\n                                                            { \n                                                        @ children\n                                                            [ \n                                                _ wizziTree.children.push(n)\n                                        else \n                                            set wizziTree.name += lines[0]\n                                    else \n                                        _ lines.forEach\n                                            function \n                                                param l\n                                                if l.trim().length > 0\n                                                    var n\n                                                        { \n                                                            @ tag '++'\n                                                            $$ BAX 27/2/21 no trim !!!important @ name l.trim()\n                                                            @ name l\n                                                            @ attribs\n                                                                { \n                                                            @ children\n                                                                [ \n                                                    _ wizziTree.children.push(n)\n                            @ onclosetag\n                                function \n                                    param tagname\n                                    # loog 'onclosetag', tagname\n                                    if wizziTree.parent != null\n                                        set wizziTree = wizziTree.parent\n                                    else \n                                        _ console.log(\"WARNING overclose \", tagname)\n                            @ onswig\n                                function \n                                    param text\n                                    var \n                                        decl p\n                                            _ lineparser.parseNameValueRaw\n                                                @ text\n                                                { \n                                        decl tag\n                                            _ p.name()\n                                                ._ trim()\n                                                ._ toLowerCase()\n                                        decl text = p.value()\n                                    # log \"OpenSwig \" + tag, text\n                                    if ['for', 'if', 'block', 'autoescape', 'filter', 'macro', 'spaceless', 'raw'].indexOf(tag) >= 0\n                                        var n\n                                            { \n                                                @ tag tag\n                                                @ name text\n                                                @ attribs\n                                                    { \n                                                @ children\n                                                    [ \n                                                @ lines\n                                                    [ \n                                                @ swig true\n                                        set n.parent = wizziTree\n                                        _ wizziTree.children.push(n)\n                                        set wizziTree = n\n                                    elif ['endfor', 'endif', 'endblock', 'endautoescape', 'endfilter', 'endmacro', 'endspaceless', 'endraw'].indexOf(tag) >= 0\n                                        if wizziTree.parent != null\n                                            set wizziTree = wizziTree.parent\n                                        else \n                                            _ console.log(\"WARNING overclose \", tagname)\n                                    elif ['extends', 'include', 'import', 'parent', 'set'].indexOf(tag) >= 0\n                                        var n\n                                            { \n                                                @ tag tag\n                                                @ name text\n                                                @ attribs\n                                                    { \n                                                @ children\n                                                    [ \n                                                @ lines\n                                                    [ \n                                                @ swig true\n                                        _ wizziTree.children.push(n)\n                                    elif ['else', 'elif', 'elseif'].indexOf(tag) >= 0\n                                        if wizziTree.parent != null\n                                            set wizziTree = wizziTree.parent\n                                        else \n                                            _ console.log(\"WARNING overclose \", tagname)\n                                        var n\n                                            { \n                                                @ tag tag\n                                                @ name text\n                                                @ attribs\n                                                    { \n                                                @ children\n                                                    [ \n                                                @ lines\n                                                    [ \n                                                @ swig true\n                                        set n.parent = wizziTree\n                                        _ wizziTree.children.push(n)\n                                        set wizziTree = n\n                                    else \n                                        throw \n                                            new Error('Html.Wizzifier. Wizzi parse onswig unknown tag: ' + tag)\n                var addedWrapper = false\n                try\n                    if html && html.length > 0\n                        log \"parsing html of length: \", html.length\n                        if html.substr(0,'<html>'.length) == '<html>' || html.substr(0,'<!doctype>'.length) == '<!doctype>'\n                            # loog 'html document has root tag html'\n                        else\n                            # log html.substr(0,'<html>'.length), html.substr(0,'<!doctype>'.length)\n                            var i1 = html.indexOf('<')\n                            var i2 = html.indexOf('>')\n                            if i1 > -1 && i2 > -1\n                                var temp = html.substr(i1+1, i2-i1-1)\n                                # loog 'wizzi-tools.htmlparser.addedWrapper.temp', temp\n                                if temp.toLowerCase().indexOf('!doctype') > -1\n                                    set html = '<html>' + html.substr(i2+1) + '</html>'\n                                else\n                                    set html = '<html>' + html + '</html>'\n                                set addedWrapper = true\n                                # loog 'wizzi-tools.htmlparser.addedWrapper.html', html\n                        log \"calling parser.write\"\n                        _ parser.write(html)\n                        log \"parser.write done!\"\n                        _ parser.end()\n                        log \"parser.end done!\"\n                    else\n                        log \"no html to parse\"\n                catch ex\n                    return\n                        _ callback\n                            @ ex\n                while wizziTree.parent != null\n                    set wizziTree = wizziTree.parent\n                if addedWrapper\n                    set wizziTree.children = wizziTree.children[0].children\n                # loog 'wizziTree', wizziTree\n                # loog 'wizzi-tools.htmlparser.wizzify.options.embedTag,wizziTree.children.length', options.embedTag, wizziTree.children.length\n                var synthax\n                if wizziTree.children.length > 1 && typeof (options.embedTag) === 'string'\n                    # loog 'wizzi-tools.htmlparser.wizzify.options.embedTag, wizziTree.children[0]', options.embedTag, wizziTree.children[0]\n                    if options.embedTag === wizziTree.children[0].tag\n                        set synthax = wizziTree.children[0]\n                    else\n                        set synthax =\n                            { \n                                @ tag options.embedTag\n                                @ name ''\n                                @ attribs\n                                    { \n                                @ children\n                                    [ \n                        _ wizziTree.children.forEach\n                            function \n                                param item\n                                _ synthax.children.push(item)\n                else\n                    if wizziTree.children.length == 1\n                        set synthax = wizziTree.children[0]\n                    else\n                        set synthax =\n                            { \n                                @ tag 'html'\n                                @ name '__dummy_root__'\n                                @ attribs\n                                    { \n                                @ children\n                                    [ \n                        _ wizziTree.children.forEach\n                            function \n                                param item\n                                _ synthax.children.push(item)\n                if !synthax\n                    return\n                        _ callback\n                            new Error('Html.Wizzifier.Wizzi parse failed. wizziTree: ' + util.inspect(wizziTree, {depth: 2}))\n                r_cb( synthax )\n\n        $$ END COPY\n        +\n        function wizzify\n            param tobeWizzified\n            param options\n            param callback\n            set options = options || {};\n            set options.input = tobeWizzified\n            set options.stack = []\n            set options.formatTextNodes = []\n            set options.verbose = true\n            _ parseInternal\n                @ tobeWizzified\n                @ options\n                a_cb( syntax )\n                    r_cb( syntax )\n        +\n        $include helper_functions\n        +\n        function isKnownType\n            param type\n            return ['Int', 'Float', 'Boolean', 'String'].indexOf(type) > -1\n        +\n        function getTypeName\n            param type\n            return isKnownType(type) ? type.toLowerCase() : type\n\n        $$ overrides \n        +        \n        set md.getWizzifierIncludes\n            function\n                param options\n                param callback\n            \n                set options.wizziIncludes = options.wizziIncludes || []\n\n                # loog 'options.wizziIncludes', options.wizziIncludes\n\n                _ async.map\n                    @ options.wizziIncludes\n                    function\n                        param item\n                        param callback\n                        if item.kind === 'css'\n                            if !csswizzifier\n                                set csswizzifier = require('../../cssparser/css/wizzifier')\n                            _ csswizzifier.getWizziTree\n                                @ item.literal\n                                {\n                                a_cb_no_throw( ittf )\n                                    # loog 'getWizzifierIncludes.item.ittf', ittf\n                                    if err\n                                        _ item.node.children.push\n                                            {\n                                                @ tag 'error'\n                                                @ name err.message\n                                                [ children\n                                    else\n                                        if options.isForVue\n                                            foreach ittfchild in ittf.children\n                                                _ item.node.children.push\n                                                    @ ittfchild\n                                        else\n                                            _ item.node.children.push\n                                                @ ittf\n                                    r_cb()\n                        elif item.kind === 'ts'\n                            if !jswizzifier\n                                # loog 'jswizzifier import 1'\n                                set jswizzifier = require('../../jsparser/babel/wizzifier')\n                                # loog 'jswizzifier import 2'\n                            # loog 'jswizzifier', jswizzifier\n                            _ jswizzifier.getWizziTree\n                                @ item.literal\n                                {\n                                    @ babel\n                                        {\n                                            @ sourceType 'module'\n                                            @ ts_or_flow 'typescript'\n                                a_cb_no_throw( ittf )\n                                    # loog 'getWizzifierIncludes.item.ittf', ittf\n                                    if err\n                                        _ item.node.children.push\n                                            {\n                                                @ tag 'error'\n                                                @ name err.message\n                                                [ children\n                                    else\n                                        if options.isForVue\n                                            foreach ittfchild in ittf.children\n                                                # skip kind\n                                                if i > 0\n                                                    _ item.node.children.push\n                                                        @ ittfchild\n                                        else\n                                            _ item.node.children.push\n                                                @ ittf\n                                    r_cb()\n                        else\n                            if !jswizzifier\n                                # loog 'jswizzifier import 1'\n                                set jswizzifier = require('../../jsparser/babel/wizzifier')\n                                # loog 'jswizzifier import 2'\n                            # loog 'jswizzifier', jswizzifier\n                            _ jswizzifier.getWizziTree\n                                @ item.literal\n                                {\n                                a_cb_no_throw( ittf )\n                                    # loog 'getWizzifierIncludes.item.ittf', ittf\n                                    if err\n                                        _ item.node.children.push\n                                            {\n                                                @ tag 'error'\n                                                @ name err.message\n                                                [ children\n                                    else\n                                        if options.isForVue\n                                            foreach ittfchild in ittf.children\n                                                # skip kind\n                                                if i > 0\n                                                    _ item.node.children.push\n                                                        @ ittfchild\n                                        else\n                                            _ item.node.children.push\n                                                @ ittf\n                                    r_cb()\n                    @ callback\n\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.ittf",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ittf",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ittf\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.ittf/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ittf\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ittf",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ittf\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.ittf-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ittf\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ittf",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                }
            ],
            "schemas": [],
            "artifacts": [
                {
                    "name": "ittf/document",
                    "schema": "ittf",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ittf\\.wizzi-override\\lib\\artifacts\\ittf\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.ittf',\n            name: 'document',\n            schema: 'ittf',\n            rootElement: '',\n            checkSchema: false,\n            isAsync: true,\n        };\n    \n    gen( &md )\n        $append imports\n            function toIttf\n                param node\n                param ctx\n                var n = node.n || node.name\n                var v = node.v || node.value || ''\n                if n == '---' && v.length == 0\n                    _ ctx.write()\n                elif n == '\\\\---' && v.length == 0\n                    _ ctx.write('---')\n                else\n                    _ ctx.write(n)\n                if node.v && node.v.length > 0\n                    _ ctx.w(' ' + node.v)\n                elif node.value && node.value.length > 0\n                    _ ctx.w(' ' + node.value)\n                else\n                    _ ctx.w()\n                if node.children && node.children.length > 0\n                    _ ctx.indent\n                    foreach child in node.children\n                        _ toIttf\n                            @ child\n                            @ ctx\n                    _ ctx.deindent           \n\n        $append main\n            _ toIttf\n                @ model\n                @ ctx\n            r_cb( ctx )\n"
                },
                {
                    "name": "ittf/tojson",
                    "schema": "ittf",
                    "artifact": "tojson",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ittf\\.wizzi-override\\lib\\artifacts\\ittf\\tojson\\gen\\main.js.ittf",
                    "content": "module\r\n    kind es6\r\n    $\r\n        var md = {\r\n            plugin: 'wizzi.plugin.ittf',\r\n            name: 'tojson',\r\n            schema: 'ittf',\r\n            rootElement: '',\r\n            checkSchema: false,\r\n            isAsync: true,\r\n        };\r\n    \r\n    gen( &md )\r\n        $append imports\r\n            var stringify = require('json-stringify-safe')\r\n            function toJson\r\n                param node\r\n                param json\r\n                var n = node.n || node.name\r\n                var v = node.v || node.value || ''\r\n                if n == '---' && v.length == 0\r\n                elif n == '\\\\---' && v.length == 0\r\n                    set json.name = '---'\r\n                else\r\n                    set json.name = n\r\n                if v.length > 0\r\n                    set json.value = v\r\n                if node.children && node.children.length > 0\r\n                    foreach child in node.children\r\n                        var jsonChild\r\n                            {\r\n                                [ children\r\n                        _ toJson\r\n                            @ child\r\n                            @ jsonChild\r\n                        _ json.children.push\r\n                            @ jsonChild\r\n\r\n        $append main\r\n            var json \r\n                {\r\n                    [ children\r\n            _ toJson\r\n                @ model\r\n                @ json\r\n            _ ctx.w\r\n                _ stringify\r\n                    @ json\r\n                    @ null\r\n                    @ 2\r\n            r_cb( ctx )\r\n"
                }
            ],
            "transformations": [
                {
                    "name": "ittf/extended",
                    "schema": "ittf",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ittf\\.wizzi-override\\lib\\artifacts\\ittf\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.ittf',\n            name: 'extended',\n            schema: 'ittf',\n            rootElement: '',\n            checkSchema: false\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                },
                {
                    "name": "ittf/cheatsheet",
                    "schema": "ittf",
                    "artifact": "cheatsheet",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ittf\\.wizzi-override\\lib\\artifacts\\ittf\\cheatsheet\\trans\\main.js.ittf",
                    "content": "module\r\n    kind es6\r\n    $\r\n        var md = {\r\n            plugin: 'wizzi.plugin.ittf',\r\n            name: 'cheatsheet',\r\n            Name: 'Cheatsheet',\r\n            schema: 'ittf',\r\n            rootElement: '',\r\n            checkSchema: false\r\n        };\r\n    trans( &md )\r\n        $append imports\r\n            var stringify = require('json-stringify-safe')\r\n            var pretty = require('wizzi-utils').pretty\r\n                        \r\n            function loadCheats\r\n                param model\r\n                param workObj\r\n\r\n                foreach itemTop in model.children\r\n                    if itemTop.name !== 'element'\r\n                        set workObj[itemTop.name] = itemTop.value\r\n                            \r\n                foreach itemTop in model.children\r\n                    # loog 'name, value', itemTop.name, itemTop.value\r\n                    if itemTop.name === 'element'\r\n                        var elementResult\r\n                            {\r\n                                @ name itemTop.value\r\n                                [ items\r\n                        foreach itemEl in itemTop.children\r\n                            if itemEl.name === 'item'\r\n                                var itemResult\r\n                                    {\r\n                                        @ schema workObj.schema\r\n                                        @ render 'artifact'\r\n                                foreach item in itemEl.children\r\n                                    if item.name === 'ittf'\r\n                                        # loog 'item.name, toIttf(item.children[0])', item.name, toIttf(item.children[0])\r\n                                        if item.children.length == 1\r\n                                            if (workObj.schema === 'json' && (item.children[0].name === '{' || item.children[0].name === '[')) ||\r\n                                                \\b item.children[0].name === ittfRootFromSchema(workObj.schema) ||\r\n                                                \\b ittfRootFromSchema(workObj.schema) === 'any'\r\n                                                # is already ok, has the correct root\r\n                                                # ??? set itemResult[item.name] = toIttf(item.children[0])\r\n                                                set itemResult[item.name] = toIttf(item.children[0])\r\n                                                set itemResult[item.name + 'Wrapped'] = itemResult[item.name]\r\n                                            else\r\n                                                # wrap it\r\n                                                var ittfNode\r\n                                                    _ wrapperForSchema\r\n                                                        @ workObj.schema\r\n                                                foreach node in item.children\r\n                                                    _ ittfNode.children.push\r\n                                                        @ node\r\n                                                set itemResult[item.name] = toIttf(item.children[0])\r\n                                                set itemResult[item.name + 'Wrapped'] = toIttf(ittfNode)\r\n                                        else\r\n                                            # wrap them\r\n                                            var ittfNode\r\n                                                _ wrapperForSchema\r\n                                                    @ workObj.schema\r\n                                            foreach node in item.children\r\n                                                _ ittfNode.children.push\r\n                                                    @ node\r\n                                            set itemResult[item.name] = toIttf(item.children)\r\n                                            set itemResult[item.name + 'Wrapped'] = toIttf(ittfNode)\r\n                                    else\r\n                                        set itemResult[item.name] = item.value\r\n                                        # log item.name, item.value\r\n                                _ elementResult.items.push\r\n                                    @ itemResult\r\n                                _ workObj._all_items.push\r\n                                    @ itemResult\r\n                            else\r\n                                set elementResult[itemEl.name] = itemEl.value\r\n                        _ workObj.elements.push\r\n                            @ elementResult\r\n                \r\n                var dump\r\n                    _ stringify\r\n                        @ workObj\r\n                        @ null\r\n                        @ 2\r\n                # loog 'loadCheats, _all_items.length', workObj._all_items.length\r\n                # loog 'loadCheats, workObj\\n', dump\r\n                \r\n            function generateArtifacts\r\n                param ctx\r\n                param workObj\r\n                param callback_main\r\n\r\n                var counter = 0\r\n                _ async.mapSeries\r\n                    @ workObj._all_items\r\n                    function\r\n                        param item\r\n                        param callback\r\n                        log 'counter', ++counter\r\n                        _ process.nextTick\r\n                            function\r\n                                _ pretty.prettifyIttfHtmlFromString\r\n                                    @ item.ittfWrapped\r\n                                    a_cb( pretty )\r\n                                        set item.ittfPretty = pretty\r\n                                        # loog 'pretty', pretty\r\n                                        # loog 'ittf.cheatsheet.ctx', ctx\r\n                                        # loog 'counter.prettified', counter\r\n                                        if item.render === 'script'\r\n                                            # loog 'ctx.wizziFactory.loadMTreeBuildupScriptFromText', ctx.wizziFactory.loadMTreeBuildupScriptFromText\r\n                                            _ ctx.wizziFactory.loadMTreeBuildupScriptFromText\r\n                                                @ item.ittfWrapped\r\n                                                {\r\n                                                a_cb_no_throw(script)\r\n                                                    # loog 'counter', --counter\r\n                                                    if err\r\n                                                        set item.generated = '\\n' + verify.htmlEscape(stringify(err, null, 2))\r\n                                                    else\r\n                                                        set item.generated = '\\n' + verify.htmlEscape(script.mTreeBuildupScript)\r\n                                                    _ callback\r\n                                                        @ null\r\n                                        else\r\n                                            # loog 'ctx.wizziFactory.loadModelAndGenerateArtifactFromText', ctx.wizziFactory.loadModelAndGenerateArtifactFromText, artifactNameFromSchema(item.schema)\r\n                                            _ ctx.wizziFactory.loadModelAndGenerateArtifactFromText\r\n                                                @ item.ittfWrapped\r\n                                                {\r\n                                                    { artifactRequestContext\r\n                                                        @ noUseStrict true\r\n                                                        @ noGeneratorComments true\r\n                                                @ artifactNameFromSchema(item.schema)\r\n                                                a_cb_no_throw(artifactText)\r\n                                                    # loog 'err, artifactText', err, artifactText\r\n                                                    # loog 'counter', --counter\r\n                                                    if err\r\n                                                        set item.generated = '\\n' + verify.htmlEscape(stringify(err, null, 2))\r\n                                                    else\r\n                                                        set artifactText = verify.htmlEscape(artifactText)\r\n                                                        set item.generated = '\\n' + artifactText\r\n                                                    _ callback\r\n                                                        @ null\r\n                    a_cb()\r\n                        var dump\r\n                            _ stringify\r\n                                @ workObj\r\n                                @ null\r\n                                @ 2\r\n                        log 'workObj final\\n', dump\r\n                        log 'Ending transform ittf/cheatsheet'\r\n                        _ callback_main\r\n                            @ null\r\n                            {\r\n                                @ schema workObj.schema\r\n                                @ elements workObj.elements\r\n\r\n            function toIttf\r\n                param node\r\n                var buffer\r\n                    [ \r\n                if verify.isArray(node)\r\n                    foreach item in node\r\n                        if item.children\r\n                            _ _toIttfNodeDeep(item, 0, buffer)\r\n                        else\r\n                            _ item.nodes.forEach\r\n                                function \r\n                                    param node\r\n                                    _ _toIttfNodeDeep(node, 0, buffer)\r\n\r\n                else\r\n                    if node && node.children\r\n                        _ _toIttfNodeDeep(node, 0, buffer)\r\n                    else\r\n                        _ node.nodes.forEach\r\n                            function \r\n                                param node\r\n                                _ _toIttfNodeDeep(node, 0, buffer)\r\n                return buffer.join('\\n')\r\n\r\n            function _toIttfNodeDeep\r\n                param node\r\n                param indent\r\n                param buffer\r\n                if node.name\r\n                    _ buffer.push\r\n                        @ spaces(indent * 4) + node.name + ' ' + (node.value || '')\r\n                else\r\n                    _ buffer.push\r\n                        @ spaces(indent * 4) + node.n + ' ' + (node.v || '')\r\n                foreach child in node.children\r\n                    _ _toIttfNodeDeep(child, indent + 1, buffer)\r\n\r\n            function spaces\r\n                param num\r\n                return \r\n                    _ Array(num + 1)\r\n                        ._ join(\" \")\r\n\r\n            function wrapperForSchema\r\n                param schema\r\n                if schema === 'js' || schema === 'jsx'\r\n                    return\r\n                        {\r\n                            @ n 'module'\r\n                            [ children\r\n                                {\r\n                                    @ n 'kind'\r\n                                    @ v 'react'\r\n                                    [ children\r\n                elif schema === 'ts'\r\n                    return\r\n                        {\r\n                            @ n 'module'\r\n                            [ children\r\n                else\r\n                    return\r\n                        {\r\n                            @ n schema\r\n                            [ children\r\n\r\n            var schemaArtifactMap\r\n                {\r\n                    @ js 'js/module'\r\n                    @ jsx 'js/module'\r\n                    @ ts 'ts/module'\r\n                    @ html 'html/document'\r\n                    @ css 'css/document'\r\n                    @ scss 'scss/document'\r\n                    @ svg 'svg/document'\r\n                    @ vtt 'vtt/document'\r\n                    @ md 'md/document'\r\n                    @ vue 'vue/document'\r\n                    @ graphql 'graphql/document'\r\n                    @ json 'json/document'\r\n                    @ yaml 'yaml/document'\r\n                    @ ittf 'ittf/document'\r\n                    @ xml 'xml/document'\r\n                    @ text 'text/document'\r\n\r\n            function artifactNameFromSchema\r\n                param schema\r\n                # loog 'artifactNameFromSchema', schema, schemaArtifactMap[schema]\r\n                return schemaArtifactMap[schema]\r\n\r\n            var schemaIttfRootMap\r\n                {\r\n                    @ js 'module'\r\n                    @ jsx 'module'\r\n                    @ html 'html'\r\n                    @ css 'css'\r\n                    @ scss 'scss'\r\n                    @ svg 'svg'\r\n                    @ md 'md'\r\n                    @ vtt 'vtt'\r\n                    @ vue 'vue'\r\n                    @ graphql 'graphql'\r\n                    @ json '{'\r\n                    @ yaml 'yaml'\r\n                    @ ittf 'any'\r\n                    @ text 'text'\r\n                    @ xml 'xml'\r\n\r\n            function ittfRootFromSchema\r\n                param schema\r\n                # loog 'ittfRootFromSchema', schema, schemaIttfRootMap[schema]\r\n                return schemaIttfRootMap[schema]\r\n\r\n        $append main\r\n            # loog 'Starting transform ittf/cheatsheet'\r\n            var workObj\r\n                {\r\n                    [ elements\r\n                    [ _all_items\r\n\r\n            _ loadCheats\r\n                @ model\r\n                @ workObj\r\n            log 'main.loadCheats.done'\r\n\r\n            _ generateArtifacts\r\n                @ ctx\r\n                @ workObj\r\n                a_cb( result )\r\n                    log 'main.generateArtifacts.result', result\r\n                    _ callback\r\n                        @ null\r\n                        @ result\r\n\r\n    function doitem\r\n        param parent\r\n        param resultObj\r\n        var f = functors[parent.wzElement]\r\n        if f\r\n            _ f\r\n                @ parent\r\n                @ resultObj\r\n    var functors = {}\r\n"
                },
                {
                    "name": "ittf/html-pretty",
                    "schema": "ittf",
                    "artifact": "html-pretty",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ittf\\.wizzi-override\\lib\\artifacts\\ittf\\html-pretty\\trans\\main.js.ittf",
                    "content": "module\r\n    kind es6\r\n    $\r\n        var md = {\r\n            plugin: 'wizzi.plugin.ittf',\r\n            name: 'html-pretty',\r\n            schema: 'ittf',\r\n            rootElement: '',\r\n            checkSchema: false\r\n        };\r\n    trans( &md )\r\n        $append imports\r\n            var HtmlBuilder = require('./htmlbuilder').HtmlBuilder\r\n            +\r\n            var STYLE_DOCS_ITTF_TREE_PANEL = 'docs-ittf-tree-panel'\r\n            var STYLE_DOCS_ITTF_TREE_LINE = 'docs-ittf-tree-line'\r\n            var STYLE_DOCS_ITTF_NODE_LINENUMS = 'docs-ittf-node-linenums'\r\n            var STYLE_DOCS_ITTF_NODE_INDENT = 'docs-ittf-node-indent-'\r\n            var STYLE_DOCS_ITTF_NODE_NAME = 'docs-ittf-node-name'\r\n            var STYLE_DOCS_ITTF_NODE_VALUE = 'docs-ittf-node-value'\r\n            +\r\n            # pretty print\r\n            var STYLE_DOCS_ITTF_TREE_PANEL = 'linenums'\r\n            var STYLE_DOCS_ITTF_TREE_LINE = 'docs-ittf-tree-line'\r\n            var STYLE_DOCS_ITTF_NODE_LINENUMS = 'docs-ittf-node-linenums'\r\n            var STYLE_DOCS_ITTF_NODE_INDENT = 'docs-ittf-node-indent-'\r\n            var STYLE_DOCS_ITTF_NODE_COMMAND = 'kwd'\r\n            var STYLE_DOCS_ITTF_NODE_NAME = 'tag'\r\n            var STYLE_DOCS_ITTF_NODE_VALUE = 'pln'\r\n            var STYLE_DOCS_ITTF_NODE_EXPR = 'expr'\r\n            var STYLE_DOCS_ITTF_NODE_MIX = 'mix'\r\n            +\r\n            function toHtmlPretty\r\n                param node\r\n                param ctx\r\n\r\n                set ctx.__ittfNode.line++\r\n\r\n                var \r\n                    decl name = node.n || node.name\r\n                    decl value = node.v || node.value\r\n                    decl children = node.children\r\n                    decl is_command = name && name.substr(0,1) === '$'\r\n                    decl is_code = name === '$' || name === '$global'\r\n                    decl name_style = STYLE_DOCS_ITTF_NODE_NAME\r\n                    decl value_style = STYLE_DOCS_ITTF_NODE_VALUE\r\n\r\n                if ['$if', '$elif', '$'].indexOf(name) >= 0\r\n                    set value_style = STYLE_DOCS_ITTF_NODE_EXPR\r\n                \r\n                elif ctx.__insideCode\r\n                    set name_style = STYLE_DOCS_ITTF_NODE_EXPR\r\n                    set value_style = STYLE_DOCS_ITTF_NODE_EXPR\r\n\r\n                elif name && name.substr(-1,1) === '('\r\n                    set name_style = STYLE_DOCS_ITTF_NODE_MIX\r\n\r\n                _ ctx.hb.openTag('li')\r\n                _ ctx.hb.writeAttribute('class', 'L' + ('' + ctx.__ittfNode.line).substr(-1,1))\r\n\r\n                _ ctx.hb.openTag('span', { inline: true })\r\n                _ ctx.hb.writeAttribute('class', 'pnl')\r\n                _ ctx.hb.writeText(spaces(ctx.__ittfNode.indent * 4))\r\n                _ ctx.hb.closeTag('span', { inline: true })\r\n\r\n                _ ctx.hb.openTag('span', { inline: true })\r\n                if is_command\r\n                    _ ctx.hb.writeAttribute('class', STYLE_DOCS_ITTF_NODE_COMMAND)\r\n                else\r\n                    _ ctx.hb.writeAttribute('class', name_style)\r\n                _ ctx.hb.writeText(name)\r\n                _ ctx.hb.closeTag('span', { inline: true })\r\n\r\n                _ ctx.hb.openTag('span', { inline: true })\r\n                _ ctx.hb.writeAttribute('class', value_style)\r\n                _ ctx.hb.writeText(' ' + verify.htmlEscape(value))\r\n                _ ctx.hb.closeTag('span', { inline: true })\r\n\r\n                _ ctx.hb.closeTag('li')\r\n\r\n                if is_code\r\n                    set ctx.__insideCode = true\r\n\r\n                set ctx.__ittfNode.indent++\r\n                foreach child in children\r\n                    _ toHtmlPretty\r\n                        @ child\r\n                        @ ctx\r\n                \r\n                set ctx.__ittfNode.indent--\r\n\r\n                if is_code\r\n                    set ctx.__insideCode = false\r\n\r\n            function formatLineNum\r\n                param line\r\n                if line < 10\r\n                    return '00' + line\r\n                if line < 100\r\n                    return '0' + line\r\n                return line\r\n\r\n            function spaces\r\n                param num\r\n                if num < 1\r\n                    return ''\r\n                return Array(num + 1).join(\" \")\r\n\r\n        $append main\r\n            set ctx.__ittfNode\r\n                {\r\n                    @ line 0\r\n                    @ indent 0\r\n            set ctx.hb = new HtmlBuilder()\r\n            \r\n            _ toHtmlPretty\r\n                @ model\r\n                @ ctx\r\n\r\n            _ callback\r\n                @ null\r\n                _ ctx.hb.toLines\r\n\r\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.java",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.java",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.java\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.java/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.java\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.java",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "java"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.java\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.java-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.java\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.java",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "java"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "java",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.java\\.wizzi-override\\lib\\wizzi\\schemas\\java.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema java\n\n    e statement\n\t\t# A statement line node with unlimited depth.\n\t\t# Is the schema base node.\n\t\t# In itself works as a comment line.\n\t\ttag #\n\t\tr statement/s\n\n\te codeline : statement\n\n    e java : statement\n\t\tis-root\n        any codeline/statements\n\n        \n\n    $include java/functions\n    $include java/classes\n    $include java/typesystem\n"
                }
            ],
            "artifacts": [
                {
                    "name": "java/document",
                    "schema": "java",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.java\\.wizzi-override\\lib\\artifacts\\java\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.java',\n            name: 'document',\n            schema: 'java',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n        $append main\n            _ md.java\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        async-md( java )\n            _ ctx.w('<java>')\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                {\n                    @ indent true\n                a_cb()\n                    _ ctx.w('</java>')\n                    r_cb()\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n"
                },
                {
                    "name": "java/module",
                    "schema": "java",
                    "artifact": "module",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.java\\.wizzi-override\\lib\\artifacts\\java\\module\\gen\\main.js.ittf",
                    "content": "module\r\n    kind es6\r\n    $\r\n        var md = {\r\n            schema: 'java',\r\n            name: 'package',\r\n            checkSchema: true,\r\n            preprocess: false,\r\n            mainStart: true,\r\n            mainFinish: true,\r\n        }\r\n    \r\n    gen( &md )\r\n        $append imports\r\n            var writers = require('./writers/index')\r\n\r\n        $append main\r\n            \r\n            var item_count = 0\r\n            iife next\r\n                var item = model.statements[item_count++]\r\n                if !item\r\n                    return\r\n                        _ terminate_gen\r\n                            @ model\r\n                            @ ctx\r\n                _ writers.gen\r\n                    @ item\r\n                    @ ctx\r\n                    a_cb()\r\n                        _ next\r\n\r\n        function mainStart\r\n            param model\r\n            param ctx\r\n            var name = model.wzName || 'main'\r\n        \r\n        function mainFinish\r\n            param model\r\n            param ctx"
                }
            ],
            "transformations": [
                {
                    "name": "java/extended",
                    "schema": "java",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.java\\.wizzi-override\\lib\\artifacts\\java\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.java',\n            name: 'extended',\n            schema: 'java',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.js",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.js",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.js\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.js/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.js\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.js",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "js"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.js\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.js-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.js\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.js",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "js"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.js\\.wizzi-override\\lib\\wizzi\\schemas\\js.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema js\n\t\n\t# A schema modeling a javascript module.\n\n\t$$ export-to json\n\n\tmtree-is-preprocessed\n\n\te statement\n\t\t# The base element for all code nodes, and\n\t\t# a generic code statement that will be emitted as is.\n\t\t# The indentation will depend to the node depth.\n\t\t# Inside an html tag means a text node without line feed.\n\t\ttag +\n\t\t\n\t\tr statement/s\n\t\n\te comment : statement\n\t\ttag #\n\n\te commentmultiline : statement\n\t\ttag ##\n\n\te_tag( xmodule, module, statement)\n\t\t# The root element of the js schema.\n\t\tis-root\n\t\ta kind\n\t\t\tdefault jsfile\n\t\t\trestrict\n\t\t\t\tenum jsfile\n\t\t\t\tenum nodejs.bin\n\t\t\t\tenum react\n\t\t\t\tenum es6\n\t\ta ecma\n\t\t\tdefault es5\n\t\t\trestrict\n\t\t\t\tenum es5\n\t\t\t\tenum es6\n\t\ta no_strict\n\t\t\ttype boolean\n\t\t\tdefault false\n\n\t\tr feature/s\n\n\t\tm wzinitialize\n\t\t\tif this.kind === 'react' || this.kind === 'es6'\n\t\t\t\tset this.ecma = 'es6'\n\t\t\t# referenced in wizzi-codegen.js.es6.module\n\t\t\t# > decl hasClasses = model.wzModelState.hasClasses\n\t\t\t# The 'hasClasses' is set in the 'wzInitialize' method\n\t\t\t# of the 'class' element.\n\t\t\t# loog 'wizzi-js.model.module', this.wzName\n\t\t\tset this.wzModelState = ctx.modelState = {}\n\n\t\tm hasFeature\n\t\t\tparam name\n\t\t\tforeach f in this.features\n\t\t\t\tif f.wzName === name\n\t\t\t\t\treturn true\n\t\t\treturn false\n\n\te feature\n\t\t# A known feature that this module require. The list of available features\n\t\t# is enumerated in the restrict element of the 'kind' attribute.\n\t\t# Most features are autodetected during schema initialization.\n\t\ta kind\n\t\t\trestrict\n\t\t\t\tenum argument-check\n\n\te statementmultiline : statement\n\t\t# Inside an html tag means a text node preceded by a line feed\n\t\ttag ++\n\n\t$include common/parameters\n\t$include common/restrict\n\t$include js/vars\n\t$include js/expressions\n\t$include js/statements\n\t$include js/calls\n\t$include js/objects\n\t$include js/functions\n\t$include js/classes\n\t$include js/template\n\t$include js/react\n\t$include js/html\n\t$include js/wz\n\t$include js/graphql\n\t$include js/handlebar\n\t$include js/debug\n\t$include js/test\n\n\n\tdeclare\n        function isDescendentOf\n            param model\n            param ancestor\n            if !model.wzParent\n                return false\n            if model.wzParent.wzElement == ancestor\n                return true\n            return \n                _ isDescendentOf\n                    @ model.wzParent\n                    @ ancestor"
                }
            ],
            "artifacts": [
                {
                    "name": "js/document",
                    "schema": "js",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.js\\.wizzi-override\\lib\\artifacts\\js\\document\\gen\\main.js.ittf",
                    "content": "module wizzi.plugin.js@${wzCtx.version}.lib.artifacts.js.module.gen.main\n    kind es6\n    \n    $include versions\n\n    $\n        var md = {\n            plugin: 'wizzi.plugin.js',\n            name: 'module',\n            schema: 'js',\n            rootElement: 'xmodule',\n            checkSchema: true,\n            isAsync: true,\n        };\n\n    gen( &md )\n        $append imports\n            var module_es6 = require('./es6/module')\n            var statement = require('./statement')\n            # VIA var wzIife = require('./wziife')\n            var preprocess = require('./preprocess')\n        \n        $append main\n            _ preprocess.exec(model, ctx)\n            \n            set ctx.__jskind = model.kind\n            set ctx.__ecma = model.ecma\n\n            _ main_init\n                @ model\n                @ ctx\n\n            repeater(1, model.statements)\n                _ statement.gen\n                    @ item_1\n                    @ ctx\n                    a_cb()\n                        repeater_increment(1)\n                $append next\n                    _ main_close\n                        @ model\n                        @ ctx\n                    if ctx.artifactGenerationErrors.length > 0\n                        return\n                            _ callback(ctx.artifactGenerationErrors)\n                    else\n                        r_cb( ctx )\n\n        function main_init\n            param model\n            param ctx\n            \n            if model.kind === 'nodejs.bin'\n                _ ctx.w('#!/usr/bin/env node')\n\n            # log myname, 'ctx.values', ctx.values\n            if (!!ctx.values.noGeneratorComments) == false\n                _ ctx.w('/*')\n                _ ctx.w('    artifact generator: ' + __filename)\n                _ ctx.w('    package: wizzi-js@${versions['wizzi.plugin.js@next']}')\n                _ ctx.w('    primary source IttfDocument: ' + model.wzSourceFilepath('f1'))\n                $if wzConfigIsPackageDeploy == false\n                    _ ctx.w('    utc time: ' + new Date().toUTCString())\n                _ ctx.w('*/')\n                \n            _ emitResources\n                @ model.resources\n                @ ctx\n\n            if !model.no_strict && (!!ctx.values.noUseStrict) == false\n                _ ctx.w(\"'use strict';\")\n\n            _ main_es6_module\n                @ model\n                @ ctx\n\n            if model.hasFeature('argument-check') \n                if (!!ctx.values.isLegacy) == false\n                    if (!!ctx.values.isWizziUtilsPackage) == true\n                        _ ctx.w(\"var verify = require('wizzi-helpers').verify;\")\n                    else\n                        _ ctx.w(\"var verify = require('wizzi-utils').verify;\")\n            if ctx.__wzItems && ctx.__wzItems.length > 0\n                _ emit_Iife_WzModule(model, ctx)\n\n        function main_es6_module\n            param model\n            param ctx\n            var\n                decl hasClasses = model.wzModelState.hasClasses\n                decl ecma = model.ecma\n            # loog '==== wizzi-js.artifacts.js.main', model.wzName, model.ecma, model.wzModelState.hasClasses\n            if ecma === 'es5' && hasClasses\n                _ ctx.w('// generated by ' + myname)\n                _ ctx.w(\"function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\")\n                _ ctx.w(\"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\")\n                _ ctx.w(\"var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };\")\n                _ ctx.w()\n\n        function main_close\n            param model\n            param ctx\n            if ctx.__wzModule && ctx.__wzModule.seen\n                _ emit_top_WzModule(model, ctx)\n            if model.hasFeature('argument-check') \n                _ ctx.w('/**')\n                _ ctx.w('  params')\n                _ ctx.w('    string code')\n                _ ctx.w('      # the error name or number')\n                _ ctx.w('    string method')\n                _ ctx.w('    string message')\n                _ ctx.w('      # optional')\n                _ ctx.w('    { innerError')\n                _ ctx.w('      # optional')\n                _ ctx.w('*/')\n                _ ctx.w('function error(code, method, message, innerError) {')\n                _ ctx.w('    var parameter = null;')\n                _ ctx.w('    if (verify.isObject(message)) {')\n                _ ctx.w('        parameter = message.parameter;')\n                _ ctx.w('        message = message.message;')\n                _ ctx.w('    }')\n                # _ ctx.w('    innerError = innerError || new Error(\\'Error created for trace.\\');')\n                _ ctx.w(\"    return verify.error(innerError, {\")\n                _ ctx.w(\"        name: ( verify.isNumber(code) ? 'Err-' + code : code ),\")\n                _ ctx.w(\"        method: '\" + model.wzName + \".' + method,\") \n                _ ctx.w(\"        parameter: parameter,\") \n                _ ctx.w(\"        sourcePath: __filename\")\n                _ ctx.w(\"    }, message || 'Error message unavailable');\")\n                _ ctx.w('}')\n\n        function emitResources\n            param requestedResources\n            param ctx\n\n            if requestedResources && requestedResources.length > 0 && ctx.values.jsResources\n                var resourceRepo = ctx.values.jsResources\n                _ resourceRepo.clearJsDependencies()\n                foreach item in requestedResources\n                    _ resourceRepo.addJsDependency(item.wzName)\n                _ resourceRepo.emitJsDependencies(ctx)\n\n        function emit_top_WzModule\n            param model\n            param ctx\n            _ ctx.w('')\n            _ ctx.w('module.exports = {')\n            _ ctx.indent()\n            \n            var seen = false\n            foreach item in ctx.__wzModule.vars\n                if seen\n                    _ ctx.w(',')\n                var ss = item.wzName.split(' ')\n                _ ctx.write(ss[0] + ': ' + ss[0])\n                set seen = true;\n            \n            foreach item in ctx.__wzModule.consts\n                if seen\n                    _ ctx.w(',')\n                var ss = item.wzName.split(' ')\n                _ ctx.write(ss[0] + ': ' + ss[0])\n                set seen = true;\n\n            foreach item in ctx.__wzModule.functions\n                if seen\n                    _ ctx.w(',')\n                _ ctx.write(item.wzName + ': ' + item.wzName)\n                set seen = true;\n\n            foreach item in ctx.__wzModule.classes\n                if seen\n                    _ ctx.w(',')\n                _ ctx.write(item.wzName + ': ' + item.wzName)\n                set seen = true;\n\n            if seen\n                _ ctx.w('')\n\n            _ ctx.deindent()\n            _ ctx.w('};');\n\n        function emit_Iife_WzModule\n            param model\n            param ctx\n            _ ctx.w('var __wz = (function() {')\n            _ ctx.indent()\n            _ ctx.w('var res = {};')\n            foreach item in ctx.__wzItems\n                foreach require in item.requires\n                    var from = require.from ? require.from : require.wzName\n                    _ ctx.w('res[\"' + require.wzName + '\"] = require(\"' + from + '\");')\n            _ ctx.w('return {');\n            _ ctx.w('    require: function(name) {');\n            _ ctx.w('        return res[name];');\n            _ ctx.w('    }');\n            _ ctx.w('}');\n            _ ctx.deindent()\n            _ ctx.w('})();');\n\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n\n\n    # error changed in v08"
                }
            ],
            "transformations": [
                {
                    "name": "js/extended",
                    "schema": "js",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.js\\.wizzi-override\\lib\\artifacts\\js\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.js',\n            name: 'extended',\n            schema: 'js',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ],
            "wizzifiers": [
                {
                    "name": "js",
                    "schema": "js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.js\\.wizzi-override\\lib\\wizzifiers\\js\\wizzifier.js.ittf",
                    "content": "module\n    $\n        var schemaName = 'js';\n    kind es6\n\n    basewizzifier()\n        $append imports\n            var js_parser = require('@babel/parser')\n            var cleanAST = require('./cleanAST')\n            var CommentManager = require('../utils/commentManager')\n            +\n            var commonPlugins\n                [\n                    @ 'jsx'\n                    @ \"objectRestSpread\"\n                    @ \"classProperties\"\n                    @ \"doExpressions\"\n                    @ ['decorators', { decoratorsBeforeExport: true }]\n                    @ \"classProperties\"\n                    @ \"classPrivateProperties\"\n                    @ \"classPrivateMethods\"\n                    @ \"exportDefaultFrom\"\n                    @ \"exportNamespaceFrom\"\n                    @ \"asyncGenerators\"\n                    @ \"functionBind\"\n                    @ \"functionSent\"\n                    @ \"dynamicImport\"\n                    @ \"numericSeparator\"\n                    @ \"optionalChaining\"\n                    @ \"importMeta\"\n                    @ \"bigInt\"\n                    @ \"optionalCatchBinding\"\n                    @ \"throwExpressions\"\n                    @ \"nullishCoalescingOperator\"\n            +\n            var csswizzifier = null\n\t        var htmlwizzifier = null\n            $if wzConfigIsDocumentation\n                var wzDocs\n                    {\n                        [ AstgNodes\n\n            $include html_tags\n            +\n            function parseInternal\n                param tobeWizzified\n                param options\n                param callback\n                set options = options || {}\n                var plugins\n                try\n                    if options.ts_or_flow === 'typescript'\n                        set plugins\n                            [\n                                @ 'typescript'\n                                ._ concat\n                                    @ commonPlugins\n                    else\n                        set plugins\n                            [\n                                @ 'flow'\n                                ._ concat\n                                    @ commonPlugins\n                    # loog 'jswizzifier.container.options', options\n                    var syntax\n                        _ js_parser.parse\n                            @ tobeWizzified\n                            {\n                                @ sourceType 'module'\n                                @ plugins plugins\n                    r_cb( syntax )\n                catch ex\n                    return\n                        _ callback\n                            @ ex\n        var format\n            function\n                param parent\n                param ast\n                param options\n                if !ast\n                    throw new Error('missing ast. parent is: ' + util.inspect(parent, { depth: 2 }))\n                if parent === null\n                    if options.starter\n                        set options.starter = false\n                    elif options.returnText\n                        # ok\n                    else\n                        _ showstack(options)\n                        throw new Error('parent is null.' + util.inspect(ast, 4))\n\n                if options.verbose\n                    # loog 'ast.type', ast.type\n                if ast.type == 'OptionalMemberExpression'\n                    set ast.type = 'MemberExpression'\n                    set ast.optional = true\n                if ast.type == 'OptionalCallExpression'\n                    set ast.type = 'CallExpression'\n                    set ast.optional = true\n                var formatter = format[ast.type]\n                if formatter\n                    _ options.stack.push(ast)\n                    var result = formatter(parent, ast, options)\n                    _ options.stack.pop()\n                    return result\n                else\n                    throw new Error('no formatter for type: ' + ast.type)\n\n        var formatText\n            function\n                param parent\n                param ast\n                param options\n                param node\n                var saveReturnText = options.returnText\n                set options.returnText = true\n                if node\n                    _ options.formatTextNodes.push(node)\n                var value = format(parent, ast, options)\n                if node\n                    _ options.formatTextNodes.pop(); \n                set options.returnText = saveReturnText\n                return value\n\n        function wizzify\n            param tobeWizzified\n            param options\n            param callback\n            # loog 'options', options\n            set options = options || {};\n            set options.input = tobeWizzified\n            set options.stack = []\n            set options.formatTextNodes = []\n            set options.wizziIncludes = []\n            set options.stateAST = []\n            var startTime = Date.now()\n            var babelOptions = options.babel || {}\n            _ parseInternal\n                @ tobeWizzified\n                @ babelOptions\n                a_cb( syntax\n                    if options.syntaxOutFile\n                        _ file.write\n                            @ options.syntaxOutFile\n                            _ JSON.stringify\n                                _ cleanAST(syntax)\n                                @ null\n                                @ 2\n                    set options.starter = true\n                    set options.commentManager = new CommentManager()\n                    var root\n                        {\n                            @ tag 'module'\n                            [ children\n                    if babelOptions.ts_or_flow !== 'typescript'\n                        _ root.children.push\n                            {\n                                @ tag 'kind'\n                                @ name 'react'\n                                [ children\n                    try\n                        _ format(root, syntax, options)\n                    catch ex\n                        return\n                            _ callback\n                                @ ex\n                    \n                    # log \"wizziTree\", JSON.stringify(root, null, 2)\n                    # loog 'options.wizziIncludes', options.wizziIncludes\n                    _ async.map\n                        @ options.wizziIncludes\n                        function\n                            param item\n                            param callback\n                            if item.kind === 'css'\n                                if !csswizzifier\n                                    set csswizzifier = require('../../cssparser/css/wizzifier')\n                                _ csswizzifier.getWizziTree\n                                    @ item.literal\n                                    {\n                                    a_cb_no_throw( ittf )\n                                        # loog 'getWizzifierIncludes.item.ittf', ittf\n                                        _ item.node.children.push\n                                            @ ittf\n                                        r_cb()\n                            else\n                                if !htmlwizzifier\n                                    set htmlwizzifier = require('../../htmlparser/wizzi/wizzifier')\n                                _ htmlwizzifier.getWizziTree\n                                    @ item.literal\n                                    {\n                                    a_cb_no_throw( ittf )\n                                        # loog 'getWizzifierIncludes.item.ittf', ittf\n                                        _ item.node.children.push\n                                            @ ittf\n                                        r_cb()\n                        a_cb()\n                            try\n                                $if wzConfigIsDocumentation\n                                    _ file.write\n                                        _ path.join\n                                            @ __dirname\n                                            @ \"..\"\n                                            @ \"..\"\n                                            @ \"..\"\n                                            @ \"..\"\n                                            @ \"..\"\n                                            @ \"..\"\n                                            @ \"autodocs\"\n                                            @ \"js-ts.wizzify.json\"\n                                        _ JSON.stringify\n                                            @ wzDocs\n                                            @ null\n                                            @ '\\t'\n                            catch ex\n                            r_cb( root )\n        +\n        set md.getCodeAST\n            function\n                param input\n                param options\n                param callback\n                set options = options || {}\n                set options.input = input\n                set options.stack = []\n                set options.formatTextNodes = []\n                set options.wizziIncludes = []\n                set options.stateAST = []\n                var babelOptions = options.babel || {}\n                var syntax\n                try\n                    set syntax = md.parse(input, babelOptions)\n                catch ex\n                    return\n                        _ callback\n                            @ ex\n                _ cleanAST(syntax)\n                _ callback\n                    @ null\n                    @ syntax\n        +\n        $include helper_functions\n        +\n        function isKnownType\n            param type\n            return ['Int', 'Float', 'Boolean', 'String'].indexOf(type) > -1\n        +\n        function getTypeName\n            param type\n            return isKnownType(type) ? type.toLowerCase() : type\n        +\n\n        f( File, skip\n            f_p( program\n            # TODO VIA f_a( comments\n\n        f( Program, skip\n            # s( sourceType, \"script\" | \"module\"\n            f_a( directives, true, Directive\n            f_a( body\n\n        f( Identifier, @id;is-text\n            name( name\n            # An identifier. Note that an identifier may be an expression or a destructuring pattern.\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    set ret.tag = '('\n                else\n                    set ret.tag = '+'\n            f_p( typeAnnotation, false\n            $* VIA\n            if node.optional\n                set ret.name = ret.name + '?'\n            *$\n            if node.optional\n                _ ret.children.push\n                    {\n                        @ tag ':optional'\n                        @ name ''\n                        [ children\n            if ret.children.length > 0\n                set __isText = false\n                set ret.isText = false\n                set ret.textified = null\n                # set ret.CICCIO = \"MAGIC\"\n            # loog 'Identifier', ret\n\n        f( PrivateName\n            f_p_name( Identifier\n            # A Private Name Identifier.\n\n        f( RegExpLiteral, literal;is-text\n            set ret.name = '/' + node.pattern + '/'\n            if node.flags && node.flags.length > 0\n                set ret.name += node.flags\n                # loog '*************** RegExpLiteral.ret.name', ret.name\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    set ret.tag = '('\n                else\n                    set ret.tag = '+'\n\n        f( NullLiteral, literal;is-text\n            set ret.name = 'null'\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    set ret.tag = '('\n                else\n                    set ret.tag = '+'\n\n        f( StringLiteral, literal;is-text\n            set ret.name = node.extra.raw\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    set ret.tag = '('\n                else\n                    set ret.tag = '+'\n            \n        f( BooleanLiteral, literal;is-text\n            name( value, boolean\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    set ret.tag = '('\n                else\n                    set ret.tag = '+'\n\n        f( NumericLiteral, literal;is-text\n            name( value, numeric\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    set ret.tag = '('\n                else\n                    set ret.tag = '+'\n\n        f( Function, function\n            # A function [declaration](#functiondeclaration) or [expression](#functionexpression).\n            f_p_name(id, Identifier | null\n            f_p( typeParameters, false, ?TypeParameterInstantiation\n            f_a_in_tag( params, params\n            _ processParams(ret)\n            # [ Pattern ]\n            f_p( body )\n            # b( generator\n            # b( async\n            # VIA\n                _ replaceChildrenOfChildWhenText\n                    @ ret\n                    @ getChildPosByTag(ret, 'params')\n                    @ 'param'\n            if node.generator\n                set ret.tag = 'function*'\n            if node.async\n                set ret.tag = 'async-function'\n            \n        f( ExpressionStatement, stm\n            # An expression statement, i.e., a statement consisting of a single expression.\n            f_p( expression )\n            if replaceWithSingleChild(ret, 'set')\n            elif replaceWithSingleChild(ret, '_')\n            else\n                error 'ExpressionStatement.failed.ret', ret\n                throw new Error()\n\n        f( BlockStatement, block;skip\n            f_a( body\n            f_a( directives\n            # A block statement, i.e., a sequence of statements surrounded by braces.\n\n        f( EmptyStatement, ;\n            # An empty statement, i.e., a solitary semicolon.\n\n        f( DebuggerStatement, debugger\n            # A `debugger` statement.\n\n        f( WithStatement, with\n            f_p( object, true, Expression\n            f_p( body\n            # A `with` statement.\n\n        f( ReturnStatement, return\n            f_p( argument, false, Expression | null\n            get_text_from_1_children(  )\n            # loog 'ReturnStatement', ret\n            # loog 'ReturnStatement.parent', parent.children[parent.children.length-1]\n\n        f( LabeledStatement, label\n            f_p_temp( label, true, true, Identifier\n            set ret.name = getNodeText(p_label)\n            f_p( body\n\n        f( BreakStatement, break\n            f_p_name( label, Identifier | null\n\n        f( ContinueStatement, continue\n            f_p_name( label, Identifier | null\n\n        f( IfStatement, if;ret-is-array\n            f_p_tag( test, test\n            _ setNameFromChildByTag(ret, 'test', true)\n            if node.consequent\n                f_p_temp( consequent\n                # loog 'IfStatement', p_consequent\n                if p_consequent.tag && p_consequent.tag.length > 0\n                    _ ret.children.push(p_consequent)\n                else\n                    foreach item in p_consequent.children\n                        _ ret.children.push(item)\n            if node.alternate\n                f_p_temp( alternate\n                var p_else\n                    {\n                        @ tag 'else'\n                        [ children\n                # loog 'IfStatement', p_consequent\n                if p_alternate.tag && p_alternate.tag.length > 0\n                    _ p_else.children.push(p_alternate)\n                else\n                    foreach item in p_alternate.children\n                        _ p_else.children.push(item)\n                set ret = [ret, p_else]\n            else\n                set ret = [ret]\n\n        f( SwitchStatement, switch\n            # A `switch` statement.\n            f_p_temp( discriminant, true, true, Expression\n            if isTextualNode(p_discriminant)\n                set ret.name = p_discriminant.textified || p_discriminant.name\n                set ret.textified = ret.name\n            else\n                _ ret.children.push\n                    @ p_discriminant\n            f_a( cases, true, SwitchCase\n\n        f( SwitchCase, case\n            f_p_temp( test, false, true, Expression | null\n            f_a( consequent, true, Statement\n            # A `case` (if `test` is an `Expression`) or `default` (if `test === null`) clause in the body of a `switch` statement.\n            #\n            if node.test == null\n                set ret.tag = 'default'\n            else\n                if p_test.textified || p_test.isText\n                    set ret.name = p_test.textified || p_test.name\n                    set ret.textified = ret.name\n                else\n                    throw new Error('SwitchCase.test must be textual:' + JSON.stringify(node, null, 2))\n\n        f( ThrowStatement, throw\n            f_p_temp( argument\n            # A `throw` statement.\n            if isTextualNode(p_argument)\n                set ret.name = getNodeText(p_argument)\n            else\n                _ ret.children.push\n                    @ p_argument\n\n        f( TryStatement, try;ret-is-array\n            # loog 'wizzifiers.js.TryStatement', JSON.stringify(node, null, 2)\n            f_p( block, true, BlockStatement\n            f_p_temp( handler, false, true, CatchClause, optional\n            f_p_temp( finalizer, false, true, BlockStatement | null\n            var tempRet = [ ret ]\n            # loog 'TryStatement.p_handler', p_handler\n            # loog 'TryStatement.p_finalizer', p_finalizer\n            if p_handler\n                _ tempRet.push(p_handler)\n            if p_finalizer\n                # loog 'TryStatement', 'p_finalizer', p_finalizer\n                _ tempRet.push\n                    {\n                        @ tag 'finally'\n                        @ name ''\n                        [ children\n                            @ p_finalizer\n            set ret = tempRet\n            # A `try` statement. If `handler` is `null` then `finalizer` must be a `BlockStatement`.\n\n        f( CatchClause, catch\n            # A `catch` clause following a `try` block.\n            f_p_name( param, Pattern | null\n            f_p( body, true, BlockStatement\n            # loog 'CatchClause.ret', ret\n\n        f( WhileStatement, while\n            f_p_tag( test, test, Expression\n            get_text_from_1_children( )\n            f_p( body, true, Statement\n\n        f( DoWhileStatement, do\n            f_p_tag( test, test, Expression\n            get_text_from_1_children( )\n            f_p( body, true, Statement\n\n        f( ForStatement, for\n            f_p_tag( init, init, VariableDeclaration | Expression | null\n            f_p_tag( test, test, Expression | null\n            f_p_tag( update, update, Expression | null\n            # loog 'p_init.textified', p_init.textified\n            var c1 = p_init.isText ? p_init.name : (p_init.textified ? p_init.textified : '')\n            var c2 = p_test.isText ? p_test.name : (p_test.textified ? p_test.textified : '')\n            var c3 = p_update.isText ? p_update.name : (p_update.textified ? p_update.textified : '')\n            set ret.name = c1 + '; ' + c2 + '; ' + c3\n            _ removeChildByTag(ret, 'init')\n            _ removeChildByTag(ret, 'test')\n            _ removeChildByTag(ret, 'update')\n            f_p( body, true, Statement\n\n        f( ForInStatement, for\n            f_p_temp( left, true, true, VariableDeclaration |  Expression\n            f_p_temp( right, true, true, Expression\n            if isTextualNode(p_left)\n                set ret.name = getNodeText(p_left)\n                if isTextualNode(p_right)\n                    set ret.name += ' in ' + getNodeText(p_right)\n                else\n                    _ ret.children.push\n                        {\n                            @ tag 'in'\n                            [ children\n                                @ p_right\n            else\n                _ ret.children.push\n                    {\n                        @ tag 'left'\n                        [ children\n                            @ p_left\n                if isTextualNode(p_right)\n                    _ ret.children.push\n                        {\n                            @ tag 'in'\n                            @ name getNodeText(p_right)\n                            [ children\n                else\n                    _ ret.children.push\n                        {\n                            @ tag 'in'\n                            [ children\n                                @ p_right\n\n            b( await\n            f_p( body, true, Statement\n        \n        f( ForOfStatement, for\n            f_p_temp( left, true, true, VariableDeclaration |  Expression\n            f_p_temp( right, true, true, Expression\n            # loog 'ForOfStatement', isTextualNode(p_left), isTextualNode(p_right)\n            if isTextualNode(p_left)\n                set ret.name = getNodeText(p_left)\n                if isTextualNode(p_right)\n                    set ret.name += ' of ' + getNodeText(p_right)\n                    set ret.textified = ret.name\n                    set ret.isText = true\n                else\n                    _ ret.children.push\n                        {\n                            @ tag 'of'\n                            [ children\n                                @ p_right\n            else\n                _ ret.children.push\n                    {\n                        @ tag 'left'\n                        [ children\n                            @ p_left\n                if isTextualNode(p_right)\n                    _ ret.children.push\n                        {\n                            @ tag 'of'\n                            @ name getNodeText(p_right)\n                            [ children\n                else\n                    _ ret.children.push\n                        {\n                            @ tag 'of'\n                            [ children\n                                @ p_right\n            b( await\n            f_p( body, true, Statement\n        \n        f( FunctionDeclaration, function\n            # A function [declaration](#functiondeclaration) or [expression](#functionexpression).\n            f_p_name(id, Identifier | null\n            f_p( typeParameters, false, ?TypeParameterInstantiation\n            # f_a_in_tag( params, params\n            # _ processParams(ret)\n            f_a_temp( params\n            _ processParams2(ret, p_params)\n            f_p_temp( returnType, false, true\n            if p_returnType\n                # loog 'p_returnType', JSON.stringify(p_returnType)\n                set p_returnType\n                    {\n                        @ tag ':return'\n                        [ children\n                            @ p_returnType\n                _ ret.children.push(p_returnType)\n            f_p( predicate, false\n            f_p( body, true, Statement\n            if node.generator\n                set ret.tag = 'function*'\n            if node.async\n                set ret.tag = 'async-function'\n\n        f( VariableDeclaration, node.kind;tag-is-var\n            # enum \"var\" | \"let\" | \"const\"\n            \n            f_a( declarations, true, VariableDeclarator\n            \n            # loog '=== VariableDeclaration ittf result 1', JSON.stringify(ret, null, 2)\n            \n            get_text_from_1_children(  )\n            \n            # loog '=== VariableDeclaration ittf result 2', ret, 'got_text_1', got_text_1\n            \n            if got_text_1\n                set ret.textified = node.kind + ' ' + ret.textified\n            elif ret.children.length == 1\n                # loog 'VariableDeclaration.ret.children[0].children.length', ret.children[0].children.length\n                if ret.children[0].children.length == 0\n                    set ret.name = ret.children[0].name\n                    set ret.children = []\n                    # no init value\n                elif ret.children[0].children.length == 1\n                    set ret.name = ret.children[0].name\n                    set ret.children[0] = ret.children[0].children[0]\n                    # loog 'ret.name', ret.name\n                    # loog 'ret.children[0]', ret.children[0]\n                    # set ret.textified = node.kind + ' ' + ret.name\n                elif ret.children[0].children.length == 2\n                    var child1 = ret.children[0].children[0]\n                    var child2 = ret.children[0].children[1]\n                    # loog 'ret.name', ret.name\n                    # loog 'ret.children[0].name', ret.children[0].name\n                    # loog 'child1.tag.name', child1.tag, child1.name\n                    # loog 'child2.tag.name', child2.tag, child2.name\n                    if child2.tag === '=' || isTypeReference(child1.tag)\n                        set ret.name = ret.children[0].name\n                        set ret.children = []\n                        _ ret.children.push\n                            @ child1\n                        _ ret.children.push\n                            @ child2\n                    else\n                        if child1.name && child1.name.length > 0 && child1.children.length > 0\n                            set ret.name = child1.name\n                            set ret.children = []\n                            foreach item in child1.children\n                                _ ret.children.push\n                                    @ item\n                            _ ret.children.push\n                                @ child2\n                        else\n                            set ret.name = ret.children[0].name\n                            set ret.children = []\n                            _ ret.children.push\n                                @ child1\n                            _ ret.children.push\n                                @ child2\n                else\n                    error 'Error VariableDeclaration. Case not managed.',\n                    foreach item in ret.children\n                        error 'VariableDeclaration.child', item\n                    throw new Error(\"VariableDeclaration. Case not managed.\")\n            elif ret.children.length > 1\n                var sb = []\n                foreach item in ret.children\n                    if item.textified\n                        _ sb.push(item.textified)\n                    else\n                        set sb = null\n                        break\n                if sb\n                    set ret.textified = node.kind + ' ' + sb.join(', ')\n\n            if node.declare\n                set ret\n                    {\n                        @ tag ':declare'\n                        @ name ''\n                        [ children\n                            @ ret\n            \n\n        f( VariableDeclarator, decl\n            f_p_temp(id, true, true)\n            \n            # loog 'VariableDeclarator,p_id, isTextualNode(p_id)', p_id, isTextualNode(p_id)\n            if isTextualNode(p_id)\n                set ret.name = getNodeText(p_id)\n            else\n                if p_id.tag === '@id'\n                    set ret.name = p_id.name\n                    set ret.children = p_id.children\n                else\n                    _ ret.children.push\n                        @ p_id\n            \n            # loog 'VariableDeclarator 1', ret\n\n            f_p( typeAnnotation, false, ?TypeAnnotation\n\n            f_p_temp( init, false, true, Expression | null\n            \n            # loog 'VariableDeclarator.p_init', p_init\n            \n            if p_init\n                # loog 'VariableDeclarator.p_init', isTextualNode(p_id), 'p_id', p_id, 'p_init', p_init\n                if isTextualNode(p_id)\n                    if isTextualNode(p_init)\n                        set ret.name += ' = ' + getNodeText(p_init)\n                        set ret.textified = ret.name\n                        set ret.isText = true\n                    else\n                        _ ret.children.push\n                            @ p_init\n                    $* VIA\n                    else\n                        # has no init value ( node.init == null )\n                        set ret.textified = ret.name\n                    *$\n                else\n                    $* 27/3/21 waiting for big big damage\n                    if p_id.tag === '@id'\n                        _ ret.children.push\n                            @ p_init\n                    else\n                    *$\n                    if isTextualNode(p_init)\n                        _ ret.children.push\n                            {\n                                @ tag '='\n                                @ name getNodeText(p_init)\n                                [ children\n                    else\n                        _ ret.children.push\n                            {\n                                @ tag '='\n                                [ children\n                                    @ p_init\n            else\n                $* 24/3/21 BIG BIG damage\n                set ret.textified = ret.name\n                set ret.isText = true\n                *$\n\n            # loog 'VariableDeclarator 2 ret', ret\n\n        f( Decorator, @d\n            f_p_temp( expression, true, true, Expression\n            if isTextualNode(p_expression)\n                set ret.name = getNodeText(p_expression)\n            else\n                _ ret.children.push\n                    @ p_expression\n\n        f( Directive, directive\n            if node.value && node.value.value === 'use strict'\n                set ret = null\n            else\n                f_p_temp( value, true, true, DirectiveLiteral\n                if isTextualNode(p_value)\n                    set ret.name = getNodeText(p_value)\n\n        f( DirectiveLiteral\n\n        f( Expression, expr\n            # Any expression node. Since the left-hand side of an assignment may be any expression in general, an expression can also be a pattern.\n\n        f( Super, super;is-text\n            # A `super` pseudo-expression.\n            set ret.name = 'super'\n\n        f( Import, import\n            # A `import` pseudo-expression.\n\n        f( ThisExpression, this;is-text\n            # A `this` expression.\n            set ret.name = 'this'\n\n        f( ArrowFunctionExpression, =>\n            if verify.isArray(node.body) == false\n                set node.body = [node.body]\n            f_a_in_tag( params, params\n            _ processParams(ret)\n            f_p_temp(returnType, false)\n            if p_returnType\n                set p_returnType\n                    {\n                        @ tag ':return'\n                        [ children\n                            @ p_returnType\n                _ ret.children.push(p_returnType)\n            f_a( body, true, BlockStatement | Expression\n            b( expression\n            \n            # loog '*** ArrowFunctionExpression.ret.params', getChildByTag(ret, 'params')\n            # loog '*** ArrowFunctionExpression.ret', ret\n            # A fat arrow function expression, e.g., `let foo = (bar) => { /* body */ }`.\n            \n            if node.async\n                set ret.tag = 'async=>'\n            if node.generator\n                set ret.tag += '*'\n    \n        f( YieldExpression, yield\n            $$ 20/3/21 f_p_tag( argument, argument, Expression | null\n            f_p_temp( argument, true, true, Expression | null\n            # loog 'ObjectProperty.p_value', p_value\n            if isTextualNode(p_argument)\n                set ret.name = getNodeText(p_argument)\n            else\n                _ ret.children.push\n                    @ p_argument\n            $$ get_text_from_1_children(  )\n            b( delegate\n            # A `yield` expression.\n\n        f( AwaitExpression, await\n            f_p( argument, false, Expression | null\n            # A `await` expression.\n\n        f( ArrayExpression, [\n            f_a( elements, true, Expression | SpreadElement | null \n            # An array expression.\n            if options.mustBeText\n                if setTextList(ret, ', ')\n                    set ret.textified = '[' + ret.textified + ']'\n                    # loog '### ArrayExpression', 'name:', ret.name, 'textified', ret.textified, ret.isText\n                else\n                    throw new Error(\"ArrayExpression. Cannot textify node as requested: \" + JSON.stringify(node, null, 2))\n            elif options.couldBeText\n                var tlist = getTextList(ret, ', ')\n                if tlist && tlist.length < 15\n                    set ret.textified = '[' + ret.textified + ']'\n                    # TODO??? set ret.children = []\n                else\n                    set ret.textified = null\n                    foreach item in ret.children\n                        if isTextualNode(item)\n                            set item.tag = '@'\n                            set item.name = getNodeText(item)\n                        elif [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                            set item.tag = '@'\n            else\n                foreach item in ret.children\n                    if isTextualNode(item)\n                        set item.tag = '@'\n                        set item.name = getNodeText(item)\n                    elif [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                        set item.tag = '@'\n            if ret.children.length == 0\n                set ret.textified = '[]'\n\n        f( ObjectExpression, {\n            if options.stateAST[options.stateAST.length-1] === 'JSXExpressionContainer'\n                _ parent.children.pop\n                set ret = parent\n                var __skip = true\n            f_a( properties, true, ObjectProperty | ObjectMethod | SpreadElement\n            if options.mustBeText\n                if setTextList(ret, ', ')\n                    set ret.textified = '{' + ret.textified + '}'\n                    if node.extra && node.extra.parenthesized == true\n                        set ret.textified = '(' + ret.textified + ')'\n                else\n                    throw new Error(\"ObjectExpression. Cannot textify node as requested: \" + JSON.stringify(node, null, 2))\n            else\n                foreach item in ret.children\n                    if item.tag === '...' \n                        # loog 'ObjectExpression, item.tag, item.children.length', item.tag, item.textified, item.children.length\n                        if item.children.length == 0\n                            set item.name = item.textified\n                            set item.tag = '@'\n                        elif item.children.length == 1\n                            if item.children[0].name\n                                set item.children[0].name = '...' + item.children[0].name\n                            if item.textified\n                                set item.children[0].textified = '...' + item.children[0].textified\n                            if item.children[0].name || item.textified\n                                set item.tag = item.children[0].tag\n                                set item.textified = item.children[0].textified\n                                set item.name = item.children[0].name\n                                set item.children = item.children[0].children\n                                # loog 'ObjectExpression length 1', item.tag, item.name, item.textified\n                            else\n                                # go on\n                    if item.tag === '@' && item.name === 'template' \n                        \\b && item.children.length == 1 && item.children[0].tag === '`lit'\n                        # loog 'ObjectExpression', item.tag, item.name, getLiteral(item.children[0])\n                        _ options.wizziIncludes.push\n                            {\n                                @ kind 'html'\n                                @ node item\n                                @ literal getLiteral(item.children[0])\n                        set item.children = []\n\n                if !ret.textified && ret.children.length == 0\n                    if node.extra && node.extra.parenthesized == true\n                        # set ret.name = ret.textified = '({})' // 10/1/19\n                        set ret.textified = '({})'\n                    else\n                        # set ret.name = ret.textified = '{}' // 10/1/19\n                        # set ret.textified = '{}' // 25/3/21\n                else\n                    if node.extra && node.extra.parenthesized == true\n                        var temp\n                            {\n                                @ tag '('\n                                [ children\n                                    @ ret\n                        set ret = temp\n\n        $* interface\n        f( ObjectMember, @\n            f_p( key, true, Expression\n            # b( computed\n            f_a( decorators, false, Decorator \n        *$\n\n        f( ObjectProperty, @\n            # loog 'ObjectProperty enter options.mustBeText', options.mustBeText\n            const save = options.mustBeText\n            set options.mustBeText = true\n            f_p_temp(key, true)\n            # loog 'ObjectProperty.p_key', p_key\n            set options.mustBeText = save\n            \n            if isTextualNode(p_key)\n                set ret.name = getNodeText(p_key)\n                if node.computed\n                    set ret.name = '[' + ret.name + ']'\n            else\n                var p_computed\n                    {\n                        @ tag '@['\n                        [ children\n                            @ p_key\n                _ ret.children.push\n                    @ p_computed\n                set ret = p_computed\n            \n            f_a( decorators, false, Decorator\n\n            # loog 'ObjectProperty.ret.name', ret.name, 'node.value.type', node.value.type\n            if node.value.type === 'AssignmentPattern'\n                f_p_temp( value.left, true, true, Expression\n                f_p_temp( value.right, true, true, Expression\n                # loog 'p_value_left', p_value_left\n                # loog 'p_value_right', p_value_right\n                if node.value.left.type === 'ObjectPattern'\n                    _ ret.children.push\n                        @ p_value_left\n                    if isTextualNode(p_value_right)\n                        _ ret.children.push\n                            {\n                                @ tag '='\n                                @ name getNodeText(p_value_right)\n                                [ children\n                    elif p_value_right.tag === 'none' && verify.isNotEmpty(p_value_right.name)\n                        # FIXME why this?\n                        _ ret.children.push\n                            {\n                                @ tag '='\n                                @ name p_value_right.name\n                                [ children\n                    else\n                        _ ret.children.push\n                            {\n                                @ tag '='\n                                [ children\n                                    @ p_value_right\n                else\n                    if isTextualNode(p_value_right)\n                        if options.mustBeText\n                            set ret.textified = ret.name += ' = ' + getNodeText(p_value_right)\n                        else\n                            _ ret.children.push\n                                {\n                                    @ tag '='\n                                    @ name getNodeText(p_value_right)\n                                    [ children\n                    elif p_value_right.tag === 'none' && verify.isNotEmpty(p_value_right.name)\n                        # FIXME why this?\n                        _ ret.children.push\n                            {\n                                @ tag '='\n                                @ name p_value_right.name\n                                [ children\n                    else\n                        _ ret.children.push\n                            {\n                                @ tag '='\n                                [ children\n                                    @ p_value_right\n            else\n                f_p_temp( value, true, true, Expression\n                # loog 'ObjectProperty.p_value', p_value, isTextualNode(p_value), isTextualNode(p_key)\n                if isTextualNode(p_value)\n                    if isTextualNode(p_key)\n                        if options.mustBeText\n                            if ret.name !== getNodeText(p_value)\n                                set ret.textified = ret.name += ': ' + getNodeText(p_value)\n                            else\n                                set ret.textified = ret.name\n                        else\n                            if ret.name !== getNodeText(p_value)\n                                set ret.name += ' ' + getNodeText(p_value)\n                    else\n                        _ ret.children.push\n                            {\n                                @ tag '+'\n                                @ name getNodeText(p_value)\n                                [ children\n                elif p_value.tag === 'none' && verify.isNotEmpty(p_value.name)\n                    if isTextualNode(p_key)\n                        if ret.name !== p_value.name\n                            set ret.name += ' ' + p_value.name\n                    else\n                        _ ret.children.push\n                            {\n                                @ tag '+'\n                                @ name p_value.name\n                                [ children\n                else\n                    _ ret.children.push\n                        @ p_value\n            \n            # TODO b( shorthand\n            # TODO b( async\n            # TODO b( generator\n            \n\n            if ret.children.length == 1 && ret.children[0].tag === '{'\n                set ret.tag = '{' + ret.tag.substr(1)\n                set ret.children = ret.children[0].children\n            elif ret.children.length == 1 && ret.children[0].tag === '['\n                set ret.tag = '[' + ret.tag.substr(1)\n                set ret.children = ret.children[0].children\n\n        f( ObjectMethod, node.kind;tag-is-var\n            # loog 'ObjectMethod enter options.mustBeText', options.mustBeText\n            # s( kind\n            # enum \"get\" | \"set\" | \"method\"\n            const save = options.mustBeText\n            set options.mustBeText = true\n            f_p_temp(key, true)\n            set ret.name = getNodeText(p_key)\n            set options.mustBeText = save\n            b( async\n            f_a_in_tag( params, params\n            _ processParams(ret)\n            f_p_temp(returnType, false)\n            if p_returnType\n                set p_returnType\n                    {\n                        @ tag ':return'\n                        [ children\n                            @ p_returnType\n                _ ret.children.push(p_returnType)\n            f_p( body, true, Statement\n            set ret.tag = ret.tag == 'constructor' ? 'ctor' : (ret.tag == 'method' ? 'm' : ret.tag)\n            _ setNameFromChildByTag(ret, 'key', true)\n            if ret.tag === 'ctor'\n                set ret.name = ''\n            elif node.computed\n                set ret.name = '[' + ret.name + ']'\n\n        f( FunctionExpression, function\n            f_p_name(id, Identifier | null\n            f_p( typeParameters, false, ?TypeParameterInstantiation\n            f_a_in_tag( params, params\n            _ processParams(ret)\n            f_p_temp(returnType, false)\n            if p_returnType\n                set p_returnType\n                    {\n                        @ tag ':return'\n                        [ children\n                            @ p_returnType\n                _ ret.children.push(p_returnType)\n            f_p( body )\n            \n            if node.async\n                set ret.tag = 'async-function'\n            if node.generator\n                set ret.tag += '*'\n\n        f( UnaryExpression, 'op' + node.operator;tag-is-var\n            # A unary operator expression.\n            # s( operator, UnaryOperator enum \"-\" | \"+\" | \"!\" | \"~\" | \"typeof\" | \"void\" | \"delete\" | \"throw\"\n            # b( prefix\n\n            if ret.tag == 'opdelete'\n                set ret.tag = 'delete'\n            \n            f_p_temp( argument, true, true, Expression\n            if isTextualNode(p_argument)\n                set ret.name = getNodeText(p_argument)\n                const space = ['-','+','!','{'].indexOf(node.operator) > -1 ? '' : ' '\n                set ret.textified = node.operator + space + ret.name\n            else\n                _ ret.children.push\n                    @ p_argument\n\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                if node.extra && node.extra.parenthesized == true\n                    # is the return value of an ArrowExpression\n                    # TODO ...\n                    if isTextualNode(p_argument)\n                        set ret.tag = '('\n                        set ret.name = node.operator + getNodeText(p_argument)\n                        set ret.textified = '(' + node.operator + getNodeText(p_argument) + ')'\n                    else\n                        var temp\n                            {\n                                @ tag '('\n                                [ children\n                                    @ ret\n                        set ret = temp\n                else\n                    # TODO ...\n                    if isTextualNode(p_argument)\n                        set ret.tag = '+'\n                        set ret.name = node.operator + getNodeText(p_argument)\n                    else\n                        var temp\n                            {\n                                @ tag '+'\n                                [ children\n                                    @ ret\n                        set ret = temp\n            \n        f( UpdateExpression, 'op' + node.operator;tag-is-var\n            # An update (increment or decrement) operator expression.\n            # s( operator, UpdateOperator enum \"++\" | \"--\"\n            f_p( argument, true, Expression\n            # b( prefix\n            \n            get_text_from_1_children(  )\n            if got_text_1\n                set ret.tag = 'set'\n                if node.prefix\n                    set ret.name = node.operator + ret.name\n                else\n                    set ret.name = ret.name + node.operator\n                set ret.textified = ret.name\n            \n            if node.prefix\n                set ret.tag = node.operator + 'op'\n\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if got_text_1\n                    if node.extra && node.extra.parenthesized == true\n                        set ret.tag = '('\n                    else\n                        set ret.tag = '+'\n                else\n                    # TODO\n                    # is the return value of an ArrowExpression\n                    if got_text_1\n                        set ret.tag = '('\n                    else\n                        set ret.tag = '(' + ret.tag\n\n        f( BinaryExpression, 'op' + node.operator;tag-is-var\n            # A binary operator token.\n            # s( operator, BinaryOperator\n            # enum \"==\" | \"!=\" | \"===\" | \"!==\" \n                \\b \"<\" | \"<=\" | \">\" | \">=\"\n                \\b | \"<<\" | \">>\" | \">>>\"\n                \\b | \"+\" | \"-\" | \"*\" | \"/\" | \"%\"\n                \\b | \"|\" | \"^\" | \"&\" | \"in\"\n                \\b | \"instanceof\"\n                \\b | \"|>\"\n\n            if node.operator.length > 1\n                set ret.tag = node.operator\n            \n            f_p_temp( left, true, true, Expression\n            # loog 'BinaryExpression.p_left', p_left\n            f_p_temp( right, true, true, Expression\n            # loog 'BinaryExpression.p_right', p_right\n\n            if isTextualNode(p_left) && isTextualNode(p_right)\n                set ret.tag = 'set'\n                set ret.name = getNodeText(p_left) + ' ' + node.operator + ' ' + getNodeText(p_right)\n                set ret.textified = ret.name\n                if node.extra && node.extra.parenthesized == true\n                    set ret.textified = '(' + ret.textified + ')'\n            else\n                if isTextualNode(p_left) || (p_left.children.length == 0 && [$*'@expr',*$ '@id', 'literal'].indexOf(p_left.tag) > -1)\n                    set p_left.tag = '+'\n                    if isTextualNode(p_left)\n                        set p_left.name = getNodeText(p_left)\n                        set p_left.children = []\n                _ ret.children.push\n                    @ p_left\n                if isTextualNode(p_right) || (p_right.children.length == 0 && [$*'@expr',*$ '@id', 'literal'].indexOf(p_right.tag) > -1)\n                    set p_right.tag = '+'\n                    if isTextualNode(p_right)\n                        set p_right.name = getNodeText(p_right)\n                        set p_right.children = []\n                _ ret.children.push\n                    @ p_right\n                if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                    # is the return value of an ArrowExpression\n                    if node.extra && node.extra.parenthesized == true\n                        set ret.tag = '(' + ret.tag\n                    else\n                        # 18/3/21 set ret.tag = '+'\n\n        f( AssignmentExpression, set\n            # loog 'AssignmentExpression enter options.mustBeText', options.mustBeText\n            # An assignment operator expression.\n            # s( operator, AssignmentOperator\n            # enum AssignmentOperator {\n                \\b \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"%=\"\n                \\b | \"<<=\" | \">>=\" | \">>>=\"\n                \\b | \"|=\" | \"^=\" | \"&=\"\n            const save = options.mustBeText\n            set options.mustBeText = true\n            f_p_temp( left, true, true, Pattern | Expression\n            set options.mustBeText = save\n            f_p_temp( right, true, true, Expression\n            \n            if isTextualNode(p_left)\n                set ret.name = getNodeText(p_left) + ' ' + node.operator + ' '\n            else\n                set ret.name = node.operator\n                _ ret.children.push\n                    @ p_left\n            # loog 'AssignmentExpression.isTextualNode(p_right)', isTextualNode(p_right)\n            # loog 'AssignmentExpression.p_right', p_right\n            if isTextualNode(p_left) && isTextualNode(p_right)\n                set ret.name += getNodeText(p_right)\n            else\n                if verify.isEmpty(p_right.tag)\n                    foreach item in p_right.children\n                        _ ret.children.push\n                            @ item\n                else\n                    _ ret.children.push\n                        @ p_right\n            # loog 'AssignmentExpression.ret final', ret\n\n        f( LogicalExpression, 'op' + node.operator;tag-is-var\n            # A logical operator expression.\n            # s( operator, LogicalOperator enum \"||\" | \"&&\" | \"??\"\n            \n            f_p_temp( left, true, true, Expression\n            f_p_temp( right, true, true, Expression\n\n            var parenthesized = node.extra && node.extra.parenthesized\n\n            # loog 'LogicalExpression', isTextualNode(p_left), isTextualNode(p_right)\n            # loog 'LogicalExpression,p_left', p_left\n            # loog 'LogicalExpression,p_right', p_right\n            if isTextualNode(p_left) && isTextualNode(p_right)\n                set ret.tag = '@expr' $$ 27/3/21 'set'\n                set ret.name = parenthesize(getNodeText(p_left) + ' ' + node.operator + ' ' + getNodeText(p_right), parenthesized)\n                set ret.textified = ret.name\n            else\n                set ret.tag = node.operator\n                # loog 'LogicalExpression,isTextualNode(p_left),p_left', isTextualNode(p_left), p_left\n                if isTextualNode(p_left) || [$*'@expr', 27/3/21*$'@id', 'literal','set'].indexOf(p_left.tag) > -1\n                    set p_left.tag = '+'\n                    if isTextualNode(p_left)\n                        set p_left.name = getNodeText(p_left)\n                        set p_left.children = []\n                _ ret.children.push\n                    @ p_left\n                # loog 'LogicalExpression,isTextualNode(p_right),p_right', isTextualNode(p_right), p_right\n                if isTextualNode(p_right) || [$*'@expr', 27/3/21*$'@id', 'literal','set'].indexOf(p_right.tag) > -1\n                    set p_right.tag = '+'\n                    if isTextualNode(p_right)\n                        set p_right.name = getNodeText(p_right)\n                        set p_right.children = []\n                _ ret.children.push\n                    @ p_right\n                if parenthesized\n                    set ret \n                        {\n                            @ tag '('\n                            @ children [ret]\n                $*\n                if isTextualNode(p_left) || ['@id', 'literal'].indexOf(p_left.tag) > -1\n                    set p_left.tag = '+'\n                    if isTextualNode(p_left)\n                        set p_left.name = getNodeText(p_left)\n                        set p_left.children = []\n                _ ret.children.push\n                    @ p_left\n                # loog 'LogicalExpression.p_left', p_left\n                if isTextualNode(p_right) || ['@id', 'literal'].indexOf(p_right.tag) > -1\n                    set p_right.tag = '+'\n                    if isTextualNode(p_right)\n                        set p_right.name = getNodeText(p_right)\n                        set p_right.children = []\n                _ ret.children.push\n                    @ p_right\n                # loog 'LogicalExpression.p_right', p_right\n                *$\n\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    if ret.tag === 'set'\n                        set ret.tag = '('\n                    else\n                        set ret.tag = '(' + ret.tag\n                else\n                    if ret.tag === 'set'\n                        set ret.tag = '+'\n                    else\n                        # TODO Do nothing is OK?\n\n        f( SpreadElement, ...\n            f_p_temp( argument, true, true, Expression\n            # loog 'SpreadElement.p_argument', p_argument\n            if isTextualNode(p_argument)\n                set ret.name = getNodeText(p_argument)\n                set ret.textified = '...' + ret.name\n            else\n                _ ret.children.push\n                    @ p_argument\n                # set ret.textified = p_argument.source\n                # throw new Error('SpreadElement must be textual:' + JSON.stringify(p_argument, null, 2))\n\n        f( MemberExpression, @expr\n            f_p_temp( object\n            f_p_temp( property\n            \n            # b( computed\n            # b( optional, optional\n            # If `computed` is `true`, the node corresponds to a computed (`a[b]`) member expression and `property` is an `Expression`. \n            # If `computed` is `false`, the node corresponds to a static (`a.b`) member expression and `property` is an `Identifier`. \n            # The `optional` flags indicates that the member expression can be called even if the object is null or undefined. \n            # If this is the object value (null/undefined) should be returned.\n            \n            # if p_object.name == 'Promise'\n                # loog 'MemberExpression.p_object', isTextualNode(p_object), p_object\n                # loog 'MemberExpression.p_property', isTextualNode(p_property), p_property\n\n            var qmark = node.optional ? '?' : ''\n\n            if isTextualNode(p_object)\n                var obj = getNodeText(p_object)\n                if isTextualNode(p_property)\n                    var prop = getNodeText(p_property)\n                    set ret.name = node.computed \n                        \\b ? obj + qmark + '[' + prop + ']' \n                        \\b : obj + qmark + '.' + prop\n                    set ret.textified = ret.name\n                    set ret.children = []\n                    # loog 'MemberExpression.textified', ret.textified\n                else\n                    set ret.name = obj + qmark\n                    var link\n                        {\n                            @ tag node.computed ? '.[' : '.'\n                            [ children\n                    _ link.children.push\n                        @ p_property\n                    _ ret.children.push\n                        @ link\n            else\n                log 1011\n                if node.computed\n                    set p_property.tag = '.['\n                else\n                    set p_property.tag = '.'\n                if p_object.tag === '('\n                    # log 2\n                    # 26/3/21 this is the most improbable, waiting for big damage\n                    set p_object.name = p_object.name + qmark\n                    _ ret.children.push\n                        @ p_object\n                    _ ret.children.push\n                        @ p_property\n                else\n                    # log 3, p_object.tag, p_object.name\n                    set ret.tag = p_object.tag\n                    set ret.name = p_object.name + qmark\n                    set ret.source = p_object.source\n                    set ret.children = p_object.children\n                    _ ret.children.push\n                        @ p_property\n\n                # loog 'MemberExpression.tag.name', ret.tag, ret.name\n                foreach item in ret.children\n                    # loog 'MemberExpression.child', i, ret.children[i].tag, ret.children[i].name\n\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    set ret\n                        {\n                            @ tag '('\n                            @ children [ret]\n                else\n                    $$ Whats this ???\n                    set ret\n                        {\n                            @ tag '+'\n                            @ children [ret]\n\n\n        f( BindExpression, bind-expr\n            f_p( object, false, Expression | null\n            f_p( callee, true, Expression\n            # if `object` is `null`, then `callee` should be a `MemberExpression`.\n\n        f( ConditionalExpression, iif\n            # A conditional expression, i.e., a ternary `?`/`:` expression.\n            f_p_tag( test, test\n            f_p_temp( consequent, true, true, Expression\n            f_p_temp( alternate, true, true, Expression\n            \n            # loog 'ConditionalExpression 1', ret.tag\n            _ setNameFromChildByTag(ret, 'test', true)\n            # loog 'ConditionalExpression 2', ret.tag\n\n            _ setOrInlineIfTextualNode\n                @ ret\n                @ p_consequent\n                @ 'then'\n\n            $*\n            if isTextualNode(p_consequent)\n                _ ret.children.push\n                    {\n                        @ tag 'then'\n                        @ name getNodeText(p_consequent)\n                        [ children\n            else\n                _ ret.children.push\n                    {\n                        @ tag 'then'\n                        [ children\n                            @ p_consequent\n            *$\n\n            _ setOrInlineIfTextualNode\n                @ ret\n                @ p_alternate\n                @ 'else'\n\n            $*\n            if isTextualNode(p_alternate)\n                _ ret.children.push\n                    {\n                        @ tag 'else'\n                        @ name getNodeText(p_alternate)\n                        [ children\n            else\n                _ ret.children.push\n                    {\n                        @ tag 'else'\n                        [ children\n                            @ p_alternate\n            *$\n\n            # loog 'ConditionalExpression 3', ret.tag\n\n            $* VIA 29/3/21\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    var temp\n                        {\n                            @ tag '('\n                            [ children\n                                @ ret\n                    set ret = temp\n                else\n                    # TODO do nothing\n            *$\n            if node.extra && node.extra.parenthesized == true\n                set ret\n                    {\n                        @ tag '('\n                        @ name ''\n                        [ children\n                            @ ret\n\n            # loog 'ConditionalExpression 4', ret.tag\n\n        f( CallExpression, _\n            # A function or method call expression.\n\n            f_p( typeParameters, false, ?TypeParameterInstantiation\n            f_p_temp( callee, true, true, | Super | Import\n            f_a_temp( arguments\n\n            var lastCallee = ret\n            # loog 'CallExpression.p_callee', p_callee\n\n            var qmark = node.optional ? '?.' : ''\n            \n            if isTextualNode(p_callee)\n                # loog 'CallExpression',\n                    \\b 'isTextualNode(p_callee)', isTextualNode(p_callee), \n                    \\b 'getNodeText(p_callee)', getNodeText(p_callee), \n                    \\b 'node.typeParameters', node.typeParameters,\n                    \\b 'p_arguments', p_arguments\n                # first of all try to set ret.textified\n\n                set ret.name = getNodeText(p_callee) + qmark\n                \n                if node.typeParameters\n\n                    foreach item in p_arguments.children\n                        if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                            set item.tag = '@'\n                        _ lastCallee.children.push\n                            @ item\n                \n                else\n\n                    # loog 'CallExpression p_arguments', p_arguments\n\n                    if p_arguments && p_arguments.children.length > 0\n                        var tlist = getTextList(p_arguments, ', ')\n                        if tlist\n                            set ret.name += '(' + tlist + ')'\n                            set ret.textified = ret.name\n                            set ret.isText = true\n                        else\n                            foreach item in p_arguments.children\n                                if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                                    set item.tag = '@'\n                                _ lastCallee.children.push\n                                    @ item\n                    else\n                        set ret.name += '()'\n                        set ret.textified = ret.name\n                        set ret.isText = true\n\n                    if ret.textified && node.extra && node.extra.parenthesized == true\n                        set ret.textified = '(' + ret.textified + ')'\n\n                # loog 'CallExpression', 'ret.name,textified', ret.name, ret.textified\n            \n            else\n\n                # TODO implement node.optional\n\n                # loog 'CallExpression', \n                    \\b 'p_callee.tag', p_callee.tag, \n                    \\b 'p_callee.name', p_callee.name,\n                    \\b 'ret.tag', ret.tag\n                \n                foreach item in p_callee.children\n                    # loog 'CallExpression', 'p_callee.children', i, p_callee.children[i].tag, p_callee.children[i].name\n                \n                if p_arguments\n                    foreach item in p_arguments.children\n                        # loog 'CallExpression', 'p_arguments.children', i, p_arguments.children[i].tag, p_arguments.children[i].name\n                \n                if ['[', '{', 'new'].indexOf(p_callee.tag) > -1\n                    set ret.tag = p_callee.tag\n                \n                if ['`lit','iif'].indexOf(p_callee.tag) < 0\n                    set ret.name = p_callee.name\n                    set ret.children = p_callee.children\n\n                    $$ Begin 19/3/21\n                    if p_callee.children.length > 0\n                        # loog 'p_callee.children.length > 0'\n                        set lastCallee = p_callee.children[p_callee.children.length-1]\n                        if p_arguments && p_arguments.children.length > 0\n                            if lastCallee.tag === '.'\n                                set lastCallee.tag = '._'\n                                foreach item in p_arguments.children\n                                    if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                                        set item.tag = '@'\n                                    _ lastCallee.children.push\n                                        @ item\n                            else\n                                var call\n                                    {\n                                        @ tag '('\n                                        [ children\n                                foreach item in p_arguments.children\n                                    if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                                        set item.tag = '@'\n                                    _ call.children.push\n                                        @ item\n                                _ ret.children.push(call)\n                        else\n                            if lastCallee.tag === '.'\n                                set lastCallee.tag = '._'\n                    else\n                        # loog 'p_callee.children.length == 0'\n                        set ret.tag = \"_\"\n                        set ret.name = p_callee.tag\n                        if p_arguments && p_arguments.children.length > 0\n                            foreach item in p_arguments.children\n                                if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                                    set item.tag = '@'\n                                _ ret.children.push\n                                    @ item\n                        # loog 'CallExpression', p_callee, ret\n                    # loog 'node.callee.type', node.callee.type, ret.tag\n                    $$ End 19/3/21\n\n                else\n                    # loog '1203'\n                    var temp = [p_callee]\n                    set lastCallee = p_callee.children[p_callee.children.length-1]\n                    if lastCallee.tag === '.'\n                        set lastCallee.tag = '._'\n                        set p_callee.children.length --\n                        _ temp.push\n                            @ lastCallee\n                    set ret.children = temp\n                    foreach item in p_arguments.children\n                        if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                            set item.tag = '@'\n                        _ lastCallee.children.push\n                            @ item\n\n                    $*\n                    var temp = [p_callee]\n                    if p_callee.children.length > 0\n                        var tempCallee = []\n                        foreach item in p_callee.children\n                            # loog 'item.tag', item.tag\n                            if item.tag == '._'\n                                _ temp.push\n                                    @ item\n                            else\n                                _ tempCallee.push\n                                    @ item\n                        set p_callee.children = tempCallee\n                    set ret.children = temp\n                    *$\n\n                $$ Was here 19/3/21\n                \n                if node.callee.type === 'FunctionExpression' && ret.tag === '_'\n                    # loog 'node.callee.type 2', node.callee.type, ret.tag\n                    set ret.tag = 'iife' // 9/1/19\n\n            if node.extra && node.extra.parenthesized == true && !ret.textified\n                var temp\n                    {\n                        @ tag '('\n                        [ children\n                            @ ret\n                set ret = temp\n\n            # loog 'CallExpression.exit.ret', ret\n\n        f( NewExpression, new;could-be-text\n            f_a_in_tag( arguments, arguments\n            f_p_temp( typeParameters, false, false, TSTypeParameterInstantiation\n            f_p_temp( callee\n\n            if p_callee.isText || p_callee.textified\n                set ret.name = p_callee.textified || p_callee.name\n            else\n                throw new Error('NewExpression.callee must be textual:' + p_callee.children[0].tag)\n\n            var argumentsNode = getChildByTag(ret, 'arguments')\n            set ret.children = []\n\n            # loog 'NewExpression.ret', ret\n            # loog 'NewExpression.p_typeParameters', p_typeParameters\n            # loog 'NewExpression.argumentsNode', argumentsNode\n\n            var tlist\n            if node.arguments && node.arguments.length > 0\n                # log 101\n                if !p_typeParameters\n                    set tlist = getTextList(argumentsNode, ', ')\n                # loog 'NewExpression.tlist', tlist\n                if tlist \n                    set ret.name += '(' + tlist + ')'\n                    set ret.textified = 'new ' + ret.name\n                    set ret.isText = true\n                else\n                    if p_typeParameters\n                        foreach item in p_typeParameters.children\n                            _ ret.children.push\n                                @ item\n                    foreach item in argumentsNode.children\n                        if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                            set item.tag = '@'\n                        _ ret.children.push\n                            @ item\n            else\n                # log 102\n                if p_typeParameters\n                    foreach item in p_typeParameters.children\n                        _ ret.children.push\n                            @ item\n                else\n                    set ret.textified = 'new ' + ret.name + '()'\n            # loog 'NewExpression.ret', ret\n\n        f( SequenceExpression, sequence\n            f_a( expressions, true, Expression \n            # A sequence expression, i.e., a comma-separated sequence of expressions.\n            foreach item in ret.children\n                if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                    set item.tag = 'set'\n\n        f( DoExpression, do\n            f_p( body, true, BlockStatement\n\n        f( TemplateLiteral, `lit\n            f_a_temp( quasis, true, TemplateElement\n            f_a_temp( expressions, true, Expression \n            # loog 'TemplateLiteral', model\n            var i = 0, j\n            for i = 0; i < p_expressions.children.length; i++\n                var q = p_quasis.children[i]\n                for j = 0; j < q.children.length; j++\n                    set item = q.children[j]\n                    _ ret.children.push(item)\n                var e = p_expressions.children[i]\n                # loog 'TemplateLiteral.e', e\n                if ['@expr', '@id', 'literal', 'set'].indexOf(e.tag) > -1\n                    set e.tag = '@'\n                _ ret.children.push(e)\n            if p_quasis.children[i] && p_quasis.children[i].children.length > 0\n                for j = 0; j < p_quasis.children[i].children.length; j++\n                    set item = p_quasis.children[i].children[j]\n                    _ ret.children.push(item)\n\n        f( TaggedTemplateExpression, _`\n            f_p_temp( tag, true, true, Expression\n            if isTextualNode(p_tag)\n                set ret.name = getNodeText(p_tag)\n            else\n                throw new Error('TaggedTemplateExpression.tag must be textual:' + JSON.stringify(node, null, 2))\n            f_p_temp( quasi, true, true, TemplateLiteral\n            foreach item in p_quasi.children\n                _ ret.children.push(item)\n\n        f( TemplateElement, +\n            # b( tail\n            var lines = node.value.raw.split('\\n')\n            foreach line in lines\n                if line[0] === ' '\n                    set line = '&nbsp;' + line.substr(1)\n                if line[line.length-1] === ' '\n                    set line = line.substr(0, line.length -1) + '&nbsp;'\n                _ ret.children.push\n                    {\n                        @ tag '+'\n                        @ name line + (( i < lines.length - 1) ? '&lf;' : '' )\n                        [ children\n            # f_p( value\n            # f_p_p( value, cooked, optional\n            # f_p_p( value, raw\n\n        f( ObjectPattern, {\n            # loog 'ObjectPattern enter options.mustBeText', options.mustBeText\n            f_a( properties, true, AssignmentProperty | RestElement \n            # loog 'wizzifiers.js.ObjectPattern.ret', JSON.stringify(ret, null, 2)\n            if options.mustBeText\n                if setTextList(ret, ', ') && !!node.typeAnnotation == false\n                    set ret.textified = '{' + ret.textified + '}'\n                    if node.extra && node.extra.parenthesized == true\n                        set ret.textified = '(' + ret.textified + ')'\n                else\n                    throw new Error(\"ObjectPattern. Cannot textify node as requested: \" + JSON.stringify(node, null, 2))\n            else\n                f_p( typeAnnotation, false\n                if ret.children.length == 0\n                    if node.extra && node.extra.parenthesized == true\n                        set ret.name = ret.textified = '({})'\n                    else\n                        set ret.name = ret.textified = '{}'\n                else\n                    if node.extra && node.extra.parenthesized == true\n                        var temp\n                            {\n                                @ tag '('\n                                [ children\n                                    @ ret\n                        set ret = temp\n\n        f( ArrayPattern\n            f_a( elements, false, Pattern | null\n            if setTextList(ret, ', ')\n                set ret.textified = '[' + ret.textified + ']'\n                # loog '*** ArrayPattern len, textified: ', ret.children.length, ret.textified\n            else\n                throw new Error('ArrayPattern must be textual: ' + JSON.stringify(node, null, 2))\n\n        f( RestElement, ...$$;is-text\n            f_p(argument, true , Pattern\n            get_text_from_1_children(  )\n            f_p( typeAnnotation, false\n            $$ set ret.name = '...' + ret.name\n            $$ set ret.textified = ret.name\n            set ret.textified = '...' + ret.name\n            # loog 'RestElement', ret.tag, ret.name, ret.textified\n\n        f( AssignmentPattern, node.operator||'=';tag-is-var\n            f_p_temp( left, true, true, Pattern | Expression\n            f_p_temp( right, true, true, Expression\n            # loog 'AssignmentPattern.p_left', JSON.stringify(p_left, null, 2)\n            # loog 'AssignmentPattern.p_right', JSON.stringify(p_right, null, 2)\n            if isTextualNode(p_left)\n                set ret.name = getNodeText(p_left) \n                if isTextualNode(p_right)\n                    set ret.name += ' ' + (node.operator || '=') + ' ' + getNodeText(p_right)\n                else\n                    _ ret.children.push\n                        {\n                            @ tag node.operator || '='\n                            @ children [p_right]\n            else\n                _ ret.children.push\n                    @ p_left\n                _ ret.children.push\n                    @ p_right\n            # loog 'AssignmentPattern', JSON.stringify(ret, null, 2)\n\n        f( Class, class\n            f_p_name(id, Identifier | null\n            f_p_temp(superClass, false, true, Expression | null\n            if p_superClass\n                if isTextualNode(p_superClass)\n                    _ ret.children.push\n                        {\n                            @ tag 'super'\n                            @ name getNodeText(p_superClass)\n                else\n                    throw new Error('Class. superClass must be textual: ' + JSON.stringify(node, null, 2))\n            f_a( decorators, false, Decorator \n            f_p(body, true, ClassBody\n\n        f( ClassBody, skip\n            f_a( body, true, ClassMethod | ClassPrivateMethod | ClassProperty | ClassPrivateProperty \n\n        f( ClassMethod, node.kind;tag-is-var\n            f_p_tag(key, key, Expression\n            \n            # s( kind\n            # enum \"constructor\" | \"method\" | \"get\" | \"set\"\n            # b( computed\n\n            b( static\n            b( async\n            b( generator\n            \n            if node.accessibility\n                _ ret.children.push\n                    {\n                        @ tag ':' + node.accessibility\n                        @ name ''\n                        [ children\n            \n            f_a( decorators, false, Decorator \n            f_a_in_tag( params, params\n            _ processParams(ret)\n            f_p_temp(returnType, false)\n            if p_returnType\n                set p_returnType\n                    {\n                        @ tag ':return'\n                        [ children\n                            @ p_returnType\n                _ ret.children.push(p_returnType)\n\n            f_p( body, true, Statement\n            set ret.tag = ret.tag == 'constructor' ? 'ctor' : (ret.tag == 'method' ? 'm' : ret.tag)\n            _ setNameFromChildByTag(ret, 'key', true)\n            if ret.tag === 'ctor'\n                set ret.name = ''\n            elif node.computed\n                set ret.name = '[' + ret.name + ']'\n            \n            # VIA\n                _ replaceChildrenOfChildWhenText\n                    @ ret\n                    @ getChildPosByTag(ret, 'params')\n                    @ 'param'\n\n        f( ClassPrivateMethod, node.kind;tag-is-var\n            f_p( key, true, PrivateName\n            # s( kind, \"method\" | \"get\" | \"set\"\n            b( static\n            f_a( decorators, false, Decorator \n            f_a_in_tag( params, params\n            \n            set ret.tag = ret.tag == 'method' ? 'm' : ret.tag\n            _ processParams(ret)\n            f_p_temp(returnType, false)\n            if p_returnType\n                set p_returnType\n                    {\n                        @ tag ':return'\n                        [ children\n                            @ p_returnType\n                _ ret.children.push(p_returnType)\n            f_p( body, true, Statement\n\n        f( ClassProperty, p\n            f_p_name(key, Expression\n            f_p_temp(value, false, true, Expression\n            f_p_temp(typeAnnotation, false, true, ?TypeAnnotation\n\n            if node.optional\n                set ret.name = ret.name + '?'\n\n            b( static\n            if node.readonly\n                _ ret.children.push\n                    {\n                        @ tag ':readonly'\n                        @ name ''\n                        [ children\n            if node.accessibility\n                _ ret.children.push\n                    {\n                        @ tag ':' + node.accessibility\n                        @ name ''\n                        [ children\n            \n            $*\n            if p_value && p_value.tag === '=>'\n                set ret.tag = p_value.tag\n                if p_typeAnnotation\n                    _ ret.children.push\n                        {\n                            @ tag ':return'\n                            @ name ''\n                            @ children [p_typeAnnotation]\n                    foreach item in p_value.children\n                        _ ret.children.push\n                            @ item\n                else\n                    set ret.children = p_value.children\n            else\n            *$\n            if p_typeAnnotation\n                _ ret.children.push\n                    @ p_typeAnnotation\n            if node.computed\n                set ret.name = '[' + ret.name + ']'\n            elif p_value && p_value.tag\n                if ['@id', '@expr', 'literal'].indexOf(p_value.tag) > -1\n                    set p_value.tag = '='\n                _ ret.children.push\n                    @ p_value\n            else\n                # do nothing\n            f_a( decorators, false, Decorator \n\n        f( ClassPrivateProperty, p\n            f_p( key, true, PrivateName\n            f_p( value, false, Expression\n            b( static\n            f_a( decorators, false, Decorator \n\n        f( ClassDeclaration, class\n            f_p_name( id, Identifier\n            b( abstract, :abstract\n            f_p( typeParameters, false, ?TypeParameterInstantiation\n            f_p_temp(superClass, false, true, Expression | null\n            f_p_temp(superTypeParameters, false, true, TypeParameterInstantiation | null\n            var p_super\n            if p_superClass\n                if isTextualNode(p_superClass)\n                    set p_super\n                        {\n                            @ tag 'super'\n                            @ name getNodeText(p_superClass)\n                            [ children\n                    _ ret.children.push\n                        @ p_super\n                elif p_superClass.text === 'null'\n                    # OK\n                else\n                    throw new Error('Class. superClass must be textual: ' + JSON.stringify(node, null, 2))\n            if p_superTypeParameters\n                if p_super\n                    foreach item in p_superTypeParameters.children\n                        if item.tag !== ':param'\n                            _ p_super.children.push\n                                {\n                                    @ tag ':param'\n                                    @ name ''\n                                    [ children\n                                        @ item\n                        else\n                            _ p_super.children.push\n                                @ item\n                else\n                    set p_superTypeParameters.tag = ':super-type-params'\n                    _ ret.children.push\n                        @ p_superTypeParameters\n            f_a_temp( implements, false\n            if p_implements\n                foreach item in p_implements.children\n                    set item.tag = ':implements'\n                    _ ret.children.push\n                        @ item\n            f_a( decorators, false, Decorator \n            f_p( body )\n\n            if node.declare\n                set ret\n                    {\n                        @ tag ':declare'\n                        @ name ''\n                        [ children\n                            @ ret\n\n        f( ClassExpression, class\n            f_p_name( id, Identifier\n            f_p_temp(superClass, false, true, Expression | null\n            f_p_temp(superTypeParameters, false, true\n            if p_superClass\n                if isTextualNode(p_superClass)\n                    # loog 'p_superTypeParameters', p_superTypeParameters\n                    var superchildren = p_superTypeParameters ? p_superTypeParameters.children : []\n                    _ ret.children.push\n                        {\n                            @ tag 'super'\n                            @ name getNodeText(p_superClass)\n                            @ children superchildren\n                else\n                    throw new Error('Class. superClass must be textual: ' + JSON.stringify(node, null, 2))\n            f_p( body )\n\n        f( MetaProperty, meta\n            f_p( meta, true, Identifier\n            f_p( property, true, Identifier\n            get_text_from_2_children( c1 + '.' + c2 )\n\n        f( ModuleDeclaration, module\n            # A module `import` or `export` declaration.\n\n        $* interface\n        f( ModuleSpecifier\n            f_p( local, true, Identifier\n            # A specifier in an import or export declaration.\n        *$\n\n        f( ImportDeclaration, import\n            f_a( specifiers, true, ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier\n            f_p_tag( source, from\n            # An import declaration, e.g., `import foo from \"mod\"`.\n            #\n            var xdefault = getChildByTag(ret, 'default')\n            if xdefault\n                set ret.name = xdefault.name\n                _ removeChildByTag(ret, 'default')\n            if ret.children.length == 1 && ret.children[0].tag === 'from'\n                if ret.name && ret.name.length > 0\n                    set ret.name += ' from'\n                set ret.name += ' '\t+ ret.children[0].name\n                _ removeChildByTag(ret, 'from')\n            if node.importKind === 'type'\n                set ret.tag = ':import-type'\n\n        f( ImportSpecifier, @\n            f_p( local, true, Identifier\n            f_p_name( imported, true, Identifier\n\n            # f_p( local, true, Identifier\n            # An imported variable binding, e.g., `{foo}` in `import {foo} from \"mod\"` or `{foo as bar}` in `import {foo as bar} from \"mod\"`. \n            # The `imported` field refers to the name of the export imported from the module. \n            # The `local` field refers to the binding imported into the local module scope. \n            # If it is a basic named import, such as in `import {foo} from \"mod\"`, both `imported` and `local` are equivalent `Identifier` nodes in this case an `Identifier` node representing `foo`. \n            # If it is an aliased import, such as in `import {foo as bar} from \"mod\"`, the `imported` field is an `Identifier` node representing `foo`, \n            # and the `local` field is an `Identifier` node representing `bar`.\n            \n            if ret.children[0].name !== ret.name\n                set ret.children[0].tag = 'as'\n            else\n                set ret.children = []\n\n            if node.importKind === 'type'\n                set ret.tag = ':type'\n\n        f( ImportDefaultSpecifier, default\n            f_p_name( local, Identifier\n            # A default import specifier, e.g., `foo` in `import foo from \"mod.js\"`.\n\n        f( ImportNamespaceSpecifier, as \n            f_p( local, true, Identifier\n            # A namespace import specifier, e.g., `* as foo` in `import * as foo from \"mod.js\"`.\n            get_text_from_1_children()\n\n        f( ExportNamedDeclaration, export\n            f_p( declaration, false, Declaration | null\n            f_a( specifiers, true, ExportSpecifier\n            f_p_tag( source, from\n\n\n            var xdefault = getChildByTag(ret, 'default')\n            if xdefault\n                set ret.name = xdefault.name\n                _ removeChildByTag(ret, 'default')\n            \n            # An export named declaration, e.g., `export {foo, bar}`, `export {foo} from \"mod\"`, `export var foo = 1` or `export * as foo from \"bar\"`.\n            # _Note, Having `declaration` populated with non-empty `specifiers` or non-null `source` results in an invalid state._\n            \n            if node.exportKind === 'type'\n                # VIA 18/03/21 set ret.tag = ':export-type'\n\n        f( ExportSpecifier, @\n            f_p( exported, true, Identifier\n            f_p_name( local, true, Identifier\n            \n            # An exported variable binding, e.g., `{foo}` in `export {foo}` or `{bar as foo}` in `export {bar as foo}`. The `exported` field refers to the name exported in the module. \n            # The `local` field refers to the binding into the local module scope. If it is a basic named export, such as in `export {foo}`, both `exported` and `local` are equivalent `Identifier` nodes \n            # in this case an `Identifier` node representing `foo`. \n            # If it is an aliased export, such as in `export {bar as foo}`, the `exported` field is an `Identifier` node representing `foo`, \n            # and the `local` field is an `Identifier` node representing `bar`.\n            \n            if ret.children[0].name !== ret.name\n                set ret.children[0].tag = 'as'\n            else\n                set ret.children = []\n\n        f( ExportDefaultSpecifier, default\n            f_p_temp( exported, true, true, OptFunctionDeclaration | OptClassDeclaration | Expression\n            if isTextualNode(p_exported)\n                set ret.name = getNodeText(p_exported)\n            else\n                _ ret.children.push\n                    @ p_exported\n\n        f( ExportDefaultDeclaration, export-default\n            # An export default declaration, e.g., `export default function () {}` or `export default 1`.\n            f_p_temp( declaration, true, true, OptFunctionDeclaration | OptClassDeclaration | Expression\n            if isTextualNode(p_declaration)\n                set ret.name = getNodeText(p_declaration)\n            else\n                _ ret.children.push\n                    @ p_declaration\n\n        f( ExportNamespaceSpecifier, as\n            f_p_temp( exported, true, true, OptFunctionDeclaration | OptClassDeclaration | Expression\n            if isTextualNode(p_exported)\n                set ret.name = getNodeText(p_exported)\n            else\n                _ ret.children.push\n                    @ p_exported\n        \n        f( ExportAllDeclaration, export\n            set ret.name = '*'\n            f_p_tag( source, from\n\n        f( CommentBlock, #\n            var values = verify.replaceAll(node.value, '\\r\\n', '\\n').split('\\n')\n            # loog 'options.replaceds', options.replaceds\n            foreach value in values\n                # var v = codeReplacer.restore(value, options.replaceds)\n                _ ret.children.push\n                    {\n                        @ tag '#'\n                        @ name value\n                        [ children\n        \n        f( CommentLine, #\n            # loog 'options.replaceds', options.replaceds\n            # var v = codeReplacer.restore(node.value, options.replaceds)\n            set ret.name = node.value\n\n        f( JSXAttribute, @\n            _ options.stateAST.push\n                @ 'JSXAttribute'\n            f_p_temp( name, true, true, JSXnamespacedName\n            f_p_temp( value, false, true, JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer\n\n            if isTextualNode(p_name)\n                set ret.name = getNodeText(p_name)\n            else\n                throw new Error('JSXAttribute.name must be textual:' + JSON.stringify(node, null, 2))\n\n            # loog 'JSXAttribute.p_value', p_value, isTextualNode(p_value)\n\n            if p_value\n                if isTextualNode(p_value)\n                    set ret.name += ' ' + getNodeText(p_value)\n                elif p_value != null && p_value.text !== 'null'\n                    _ ret.children.push\n                        @ p_value\n            _ options.stateAST.pop\n\n        f( JSXClosingElement, jsx-close\n            # name JSXIdentifier | JSXMemberExpression\n\n        f( JSXElement, jsx-element\n            f_p_temp( openingElement, true, true, JSXOpeningElement\n            # f_p( closingElement, true, JSXClosingElement\n            f_a_temp( children, true, JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment\n            # loog 'p_openingElement', p_openingElement\n            # loog 'p_children', p_children\n            if p_openingElement.name && p_openingElement.name.length > 0\n                var char = p_openingElement.name[0]\n                if char == char.toUpperCase() || html_supported_tags.indexOf(p_openingElement.name) < 0\n                    set ret.tag = '< ' + p_openingElement.name\n                else\n                    set ret.tag = p_openingElement.name\n                set ret.children = p_openingElement.children\n            else\n                set ret.tag = '<'\n                set ret.children = p_openingElement.children\n            \n            # loog 'JSXElement.ret', ret\n            var\n                decl isStyle = ret.tag === 'style'\n            \n            foreach item in p_children.children\n                # loog 'JSXElement.children.item', item\n                if !(item.tag === '+' && item.name.trim().length == 0)\n                    if isStyle\n                        # loog 'isStyle', isStyle, item.children\n                        foreach c in item.children\n                            if c.tag === '`lit'\n                                set ret.tag = \"style-jsx\"\n                                _ options.wizziIncludes.push\n                                    {\n                                        @ kind 'css'\n                                        @ node ret\n                                        @ literal getLiteral(c)\n                                # loog 'JSXElement.children.item.lit', c, getLiteral(c)\n                        if ret.tag !== \"style-jsx\"\n                            _ ret.children.push\n                                @ item\n                    else\n                        _ ret.children.push\n                            @ item\n                            \n            if ret.tag === \"style-jsx\"\n                var children = ret.children\n                set ret.children = []\n                foreach item in children\n                    if item.tag === '{'\n                    elif item.tag === '@' && item.name === 'jsx'\n                    elif item.tag === '@' && item.name === 'global'\n                        _ ret.children.push\n                            {\n                                @ tag 'global'\n                                [ children\n                    else\n                        _ ret.children.push\n                            @ item\n            elif [\"style\",\"title\"].indexOf(ret.tag) > -1\n                set ret.name = ret.tag\n                set ret.tag = '<'\n\n        f( JSXEmptyExpression, skip\n            f_a( innerComments\n\n        f( JSXExpressionContainer\n            #\n                _ options.stateAST.push\n                    @ 'JSXExpressionContainer'\n            f_p_temp( expression\n            # loog 'JSXExpressionContainer.p_expression', p_expression, isTextualNode(p_expression)\n            if isTextualNode(p_expression)\n                set ret.tag = '+'\n                set ret.name = '{' + getNodeText(p_expression) + '}'\n                set ret.textified = ret.name\n            else\n                # loog 'JSXExpressionContainer.options.stateAST', options.stateAST\n                # loog 'JSXExpressionContainer.options.p_expression', p_expression\n                # loog 'options.stateAST[options.stateAST.length-1]', options.stateAST[options.stateAST.length-1]\n                $* 24/3/21 waiting for BIG damage but we must manage this*$\n                set p_expression.textified = null\n                if options.stateAST[options.stateAST.length-1] === 'JSXAttribute'\n                    var __skip = true\n                    _ parent.children.push\n                        @ p_expression\n                else\n                    set ret.tag = '{'\n                    _ ret.children.push\n                        @ p_expression\n            #\n                _ options.stateAST.pop\n\n        f( JSXSpreadChild\n            f_p_temp( expression, true, true, Expression\n            set ret.tag = p_expression.tag\n            set ret.name = '...' + p_expression.name\n            set ret.children = p_expression.children\n    \n        f( JSXIdentifier, jsx-ident;is-text\n            name( name\n\n        f( JSXMemberExpression\n            f_p(object, true, JSXMemberExpression | JSXIdentifier\n            f_p(property, true, JSXIdentifier\n            get_text_from_2_children( c1 + '.' + c2 )\n\n        f( JSXNamespacedName\n            # namespace JSXIdentifier\n            # name JSXIdentifier\n\n        f( JSXOpeningElement, jsx-open\n            f_p_temp( name, true, true, JSXIdentifier | JSXMemberExpression\n            \n            # selfClosing boolean\n\n            # loog 'JSXOpeningElement p_name', p_name\n            if isTextualNode(p_name)\n                set ret.name = getNodeText(p_name)\n            elif isTextualCommentedNode(p_name)\n                set ret.name = getNodeText(p_name)\n                set ret.children = p_name.children\n            else\n                foreach item in p_name.children\n                    if item.tag === 'jsx-ident'\n                        set ret.name = item.name\n                    else\n                        _ ret.children.push\n                            @ item\n            \n            f_p_temp( typeParameters, false, true, TSTypeParameterInstantiation\n            if p_typeParameters\n                foreach item in p_typeParameters.children\n                    _ ret.children.push\n                        @ item\n            # TODO ??? ts here ???\n            f_a_temp( parameters, parameters, TypeParameterInstantiation | TSTypeParameterInstantiation\n            if p_parameters\n                foreach item in p_parameters.children\n                    _ ret.children.push\n                        @ item\n            \n            f_a_temp( attributes, attributes, JSXAttribute | JSXSpreadAttribute\n            if p_attributes\n                foreach item in p_attributes.children\n                    _ ret.children.push\n                        @ item\n\n        f( JSXSpreadAttribute, @\n            f_p( argument, true, Expression\n            get_text_from_1_children( '{...' + c1 + \"}\" )\n\n        f( JSXText, +\n            # if node.value.trim().length == 0 || node.value === '\\n' // 11/1/19\n            var nametrimmed = node.value.trim()\n            if nametrimmed == 0\n                set ret = null\n            else\n                set ret.name = verify.replaceAll(nametrimmed, '\\n', '&lf;')\n                $* 24/3/21\n                if ret.name[0] === ' '\n                    set ret.name = '&nbsp;' + ret.name.substr(1)\n                if ret.name[ret.name.length-1] === ' '\n                    set ret.name = ret.name.substr(0, ret.name.length-1) + '&nbsp;'\n                *$\n\n        f( JSXFragment, <\n            # openingFragment JSXOpeningFragment\n            # closingFragment JSXClosingFragment\n            # children JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment\n            set ret.name = 'React.Fragment'\n            f_a( children )\n\n        f( JSXOpeningFragment, fragment-open\n            # aliases: [\"JSX\", \"Immutable\"],\n\n        f( JSXClosingFragment, fragment-close\n            # aliases: [\"JSX\", \"Immutable\"]\n\n        $$ VIA $include flow\n        $$ VIA $include typescript"
                }
            ]
        },
        {
            "name": "wizzi.plugin.json",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.json",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.json\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.json/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.json\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.json",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "json"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.json\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.json-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.json\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.json",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "json",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.json\\.wizzi\\lib\\wizzi\\schemas\\json.wfschema.ittf",
                    "genConfig": "wizzi.config.js"
                }
            ],
            "artifacts": [
                {
                    "name": "json/document",
                    "schema": "json",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.json\\.wizzi-override\\lib\\artifacts\\json\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.json',\n            name: 'document',\n            schema: 'json',\n            rootElement: '',\n            checkSchema: false,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n            var stringify = require('json-stringify-safe')\n        $append main\n            delete model.___exportName\n            _ ctx.w\n                _ stringify(model, null, 4)\n            r_cb(ctx)\n\n"
                },
                {
                    "name": "json/export",
                    "schema": "json",
                    "artifact": "export",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.json\\.wizzi-override\\lib\\artifacts\\json\\export\\gen\\main.js.ittf",
                    "content": "module\r\n    kind es6\r\n    $\r\n        var md = {\r\n            plugin: 'wizzi.plugin.json',\r\n            name: 'export',\r\n            schema: 'json',\r\n            rootElement: '',\r\n            checkSchema: false,\r\n            isAsync: true,\r\n        };\r\n    gen( &md )\r\n        $append imports\r\n            var stringify = require('json-stringify-safe')\r\n        $append main\r\n            var json\r\n            if model.toJson\r\n                set json\r\n                    _ model.toJson()\r\n            else\r\n                return\r\n                    _ callback\r\n                        _ error\r\n                            @ 'The model has no toJson method'\r\n            _ ctx.w\r\n                _ stringify(json, null, 4)\r\n            r_cb(ctx)"
                },
                {
                    "name": "json/toml",
                    "schema": "json",
                    "artifact": "toml",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.json\\.wizzi-override\\lib\\artifacts\\json\\toml\\gen\\main.js.ittf",
                    "content": "module\r\n    kind es6\r\n    $\r\n        var md = {\r\n            plugin: 'wizzi.plugin.json',\r\n            name: 'toml',\r\n            schema: 'json',\r\n            rootElement: '',\r\n            checkSchema: false,\r\n            isAsync: true,\r\n        };\r\n        \r\n    gen( &md )\r\n        $append imports\r\n        $append main\r\n            # loog 'model', model\r\n            delete model.___exportName\r\n            foreach key in Object.keys(model)\r\n                var item = model[key]\r\n                # loog 'key', key\r\n                if verify.isObject(item)\r\n                    _ ctx.w\r\n                        @ '[' + key + ']'\r\n                    _ writeObject\r\n                        @ item\r\n                        @ ctx\r\n                        @ true\r\n                elif verify.isArray(item)\r\n                    _ ctx.w\r\n                        @ key + ' = [' + writeArray(item, ctx) + ']'\r\n                else\r\n                    # loog 'key', key, 'value', verify.isString(item) ? '\"' + item + '\"' : item\r\n                    _ ctx.w\r\n                        @ key + ' = ' + (verify.isString(item) ? ('\"' + item + '\"') : item)\r\n            r_cb(ctx)\r\n\r\n    function writeArray\r\n        param arr\r\n        param ctx\r\n        var first = true\r\n        foreach item in arr\r\n            if !first\r\n                _ ctx.w(', ')\r\n            if verify.isObject(item)\r\n                _ ctx.w\r\n                    @ '{' + writeObject(item, ctx) + '}'\r\n            elif verify.isArray(item)\r\n                _ ctx.w\r\n                    @ '[' + writeArray(item, ctx) + ']'\r\n            else\r\n                _ ctx.w\r\n                    @ verify.isString(item) ? '\"' + item + '\"' : item\r\n            set first = false\r\n\r\n    function writeObject\r\n        param obj\r\n        param ctx\r\n        param top\r\n        if top\r\n            foreach key in Object.keys(obj)\r\n                var item = obj[key]\r\n                if verify.isObject(item)\r\n                    _ ctx.w\r\n                        @ key + ' = '\r\n                    _ writeObject\r\n                        @ item\r\n                        @ ctx\r\n                        @ false\r\n                elif verify.isArray(item)\r\n                    _ ctx.w\r\n                        @ key + ' = [' + writeArray(item, ctx) + ']'\r\n                else\r\n                    _ ctx.w\r\n                        @ key + ' = ' + (verify.isString(item) ? ('\"' + item + '\"') : item)\r\n\r\n"
                },
                {
                    "name": "json/toyaml",
                    "schema": "json",
                    "artifact": "toyaml",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.json\\.wizzi-override\\lib\\artifacts\\json\\toyaml\\gen\\main.js.ittf",
                    "content": "module\r\n    kind es6\r\n    $\r\n        var md = {\r\n            plugin: 'wizzi.plugin.json',\r\n            name: 'toyaml',\r\n            schema: 'json',\r\n            rootElement: '',\r\n            checkSchema: false,\r\n            isAsync: true,\r\n        };\r\n\r\n    gen( &md )\r\n        $append imports\r\n            var yaml = require('js-yaml')\r\n        $append main\r\n            delete model.___exportName\r\n            _ ctx.w\r\n                _ yaml.dump\r\n                    @ model\r\n                    {\r\n                        @ flowLevel 100\r\n                        { styles\r\n                            @ '!!null' 'camelcase' \r\n            r_cb(ctx)\r\n\r\n"
                }
            ],
            "transformations": [
                {
                    "name": "json/extended",
                    "schema": "json",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.json\\.wizzi-override\\lib\\artifacts\\json\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.json',\n            name: 'extended',\n            schema: 'json',\n            rootElement: '',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ],
            "wizzifiers": [
                {
                    "name": "json",
                    "schema": "json",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.json\\.wizzi-override\\lib\\wizzifiers\\json\\wizzifier.js.ittf",
                    "content": "module\n    $\n        var schemaName = 'json';\n    kind es6\n    basewizzifier()\n        $append imports\n            var json_parser = require('./parser')\n            var cloner = require('./cloner')\n            +\n            function parseInternal\n                param tobeWizzified\n                param options\n                param callback\n                \n                if typeof callback === 'undefined'\n                    set callback = options\n                    set options = {}\n                set options = (options || {})\n\n                var wizziTree\n                    { \n                        @ children\n                            [ \n                _ json_parser.parse\n                    @ tobeWizzified\n                    { \n                        @ onObject\n                            function \n                                param open\n                                # log  'onObject', open\n                                if open\n                                    var n\n                                        { \n                                            @ tag '{'\n                                            @ name ''\n                                            @ children\n                                                [ \n                                    set n.parent = wizziTree\n                                    _ wizziTree.children.push(n)\n                                    set wizziTree = n\n                                else\n                                    # log  \"onObject wizziTree.tag\", wizziTree.tag\n                                    set wizziTree = wizziTree.parent\n                                    # log  \"onObject wizziTree.tag\", wizziTree.tag\n                        @ onArray\n                            function\n                                param open\n                                # log  'onArray', open\n                                if open\n                                    var n\n                                        { \n                                            @ tag '['\n                                            @ name ''\n                                            @ children\n                                                [ \n                                    set n.parent = wizziTree\n                                    _ wizziTree.children.push(n)\n                                    set wizziTree = n\n                                else\n                                    # FIXME\n                                    # log  \"onArray wizziTree.tag\", wizziTree.tag\n                                    set wizziTree = wizziTree.parent\n                                    # log  \"onArray wizziTree.tag\", wizziTree.tag\n                        @ onPropName\n                            function \n                                param name\n                                # log  \"onPropName\", name\n                                var n\n                                    { \n                                        @ tag name\n                                        @ name ''\n                                        @ children\n                                            [ \n                                set n.parent = wizziTree\n                                _ wizziTree.children.push(n)\n                                # log  wizziTree.tag\n                                set wizziTree = n\n                                # log  wizziTree.tag\n                        @ onProp\n                            function \n                                param name\n                                param value\n                                # log  \"onProp\", name, value\n                                var n\n                                    { \n                                        @ tag name\n                                        @ name value\n                                        @ children\n                                            [ \n                                set n.parent = wizziTree\n                                _ wizziTree.children.push(n)\n                        @ onObjectProp\n                            function \n                                param name\n                                # log  \"onObjectProp\", name\n                                var n\n                                    { \n                                        @ tag '{'\n                                        @ name name\n                                        @ children\n                                            [ \n                                set n.parent = wizziTree\n                                _ wizziTree.children.push(n)\n                                set wizziTree = n\n                        @ onArrayProp\n                            function \n                                param name\n                                # log  \"onObjectProp\", name\n                                var n\n                                    { \n                                        @ tag '['\n                                        @ name name\n                                        @ children\n                                            [ \n                                set n.parent = wizziTree\n                                _ wizziTree.children.push(n)\n                                set wizziTree = n\n                        @ onClosePropName\n                            function\n                                # log  'onClosePropName'\n                                set wizziTree = wizziTree.parent\n                        @ onArrayValue\n                            function \n                                param value\n                                # log  \"onArrayValue\", value\n                                var n\n                                    { \n                                        @ tag value\n                                        @ name ''\n                                        @ children\n                                            [ \n                                _ wizziTree.children.push(n)\n                        @ onHandlebar\n                            function \n                                param hb\n                                # log  \"onHandlebar\", hb\n                                var n\n                                    { \n                                        @ tag '{{'\n                                        @ name hb\n                                        @ children\n                                            [ \n                                _ wizziTree.children.push(n)\n                    a_cb( result )\n                        while wizziTree.parent != null\n                            set wizziTree = wizziTree.parent\n                        # log  'wizziTree\\n', wizziTree\n                        var synthax = wizziTree.children[0]\n                        if !synthax\n                            return\n                                _ callback\n                                    new Error('Json.Wizzifier.Wizzi parse failed. wizziTree: ' + util.inspect(wizziTree, {depth: 2}))\n                        r_cb( synthax )\n\n\n        +\n        function wizzify\n            param tobeWizzified\n            param options\n            param callback\n            set options = options || {}\n            set options.input = tobeWizzified\n            set options.stack = []\n            set options.verbose = false\n            _ parseInternal\n                @ tobeWizzified\n                @ options\n                @ callback\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.md",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.md",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.md\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.md/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.md\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.md",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "md"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.md\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.md-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.md\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.md",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "md"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "md",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.md\\.wizzi-override\\lib\\wizzi\\schemas\\md.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema md\n\t\n\t# A schema modeling a markdown document\n\t# using an html-like sinthax\n\n\te attribute\n\t\ttag @\n\n\te comment\n\t\ttag #\n\t\n    e element\n\t\ttag <\n\t\tr attribute/s\n\t\tr element/s\n\n\te md\n        is-root\n\t\t# The root element of the markdown schema.\n        r element/s\n\t\t# Comments allowed at root level only\n        r comment/s\n\t\n    e frontmatter : element\n\t\tr attribute/s\n\n\te h1 : element\n\te h2 : element\n\te h3 : element\n\te h4 : element\n\te h5 : element\n\te h6 : element\n\n\te a : element\n\t\ta href\n\t\ta title\n\t\n\te i : element\n\te b : element\n\te p : element\n\t\n    e span : element\n\n\te ul : element\n\te ol : element\n\te li : element\n\n\te img : element\n\t\ta src\n\t\ta title\n\n\te codeBlock : element\n\t\tis-abstract\n\te js : codeBlock\n\te html : codeBlock\n\te css : codeBlock\n\te bash : codeBlock\n\te sh : codeBlock\n\te py : codeBlock\n\te code : codeBlock\n\n\te plus : element\n\t\ttag +\n\n\te table : element\n    e thead : element\n\te tbody : element\n    e th : element\n\te tr : element\n\te td : element\n\n\te quote : element\n\te hr : element\n\n\te br : element\n\n\te video : element\n\t\ta id\n\t\ta alt\n\n\te aRef : element\n\t\ttag r-a\n\t\ta alt\n\n\te imgRef : element\n\t\ttag r-img\n\t\ta alt\n\n\te ref : element\n\t\ta href\n\t\ta title\n\n    e htmlInclude : element\n        tag ::html\n        include html html\n\n    e cssInclude : element\n        tag ::css\n        include css css\n\n"
                }
            ],
            "artifacts": [
                {
                    "name": "md/document",
                    "schema": "md",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.md\\.wizzi-override\\lib\\artifacts\\md\\document\\gen\\main.js.ittf",
                    "content": "module wizzi.plugin.md@${wzCtx.version}.lib.artifacts.md.document.gen.main\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.md',\n            name: 'document',\n            schema: 'md',\n            checkSchema: true,\n            isAsync: true,\n        };\n    \n    gen( &md )\n        $append imports\n            var included_writers = require('./included_writers')\n        $append main\n            _ md.md\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        async-md( md )\n            _md_gen_items( elements )\n                r_cb()\n        \n        async-md( frontmatter )\n            _ ctx.w(\"---\")\n            foreach a in model.attributes\n                var nv = verify.parseNameValue(a.wzName, a)\n                _ ctx.w\n                    @ nv.name() + \": \" + nv.value()\n            _md_gen_items( elements )\n                _ ctx.w(\"---\")\n                r_cb()\n\n        async-md( propertyOrValue )\n            var p = verify.parseNameValue(model.wzName, model)\n            _ ctx.w\n                @ p.name() + \": \" + p.value()\n            r_cb()\n\n        async-md( element )\n            _ md.writeHtml(model.wzName, model, ctx, callback)\n\n        async-md( div )\n            _ md.writeHtml('div', model, ctx, callback)\n\n        async-md( h1 )\n            if ctx.isHtml || (!ctx.isCode && model.elements.length > 0)\n                _ md.writeHtml\n                    @ 'h1'\n                    @ model\n                    @ ctx\n                    @ callback\n            else\n                _ ctx.w(\"# \" + model.wzName)\n                r_cb()\n    \n        async-md( h2 )\n            if ctx.isHtml || (!ctx.isCode && model.elements.length > 0)\n                _ md.writeHtml\n                    @ 'h2'\n                    @ model\n                    @ ctx\n                    @ callback\n            else\n                _ ctx.w(\"## \" + model.wzName)\n                r_cb()\n    \n        async-md( h3 )\n            if ctx.isHtml || (!ctx.isCode && model.elements.length > 0)\n                _ md.writeHtml\n                    @ 'h3'\n                    @ model\n                    @ ctx\n                    @ callback\n            else\n                _ ctx.w(\"### \" + model.wzName)\n                r_cb()\n    \n        async-md( h4 )\n            if ctx.isHtml || (!ctx.isCode && model.elements.length > 0)\n                _ md.writeHtml\n                    @ 'h4'\n                    @ model\n                    @ ctx\n                    @ callback\n            else\n                _ ctx.w(\"#### \" + model.wzName)\n                r_cb()\n    \n        async-md( h5 )\n            if ctx.isHtml || (!ctx.isCode && model.elements.length > 0)\n                _ md.writeHtml('h5', model, ctx, callback)\n            else\n                _ ctx.w(\"##### \" + model.wzName)\n                r_cb()\n    \n        async-md( h6 )\n            if ctx.isHtml || (!ctx.isCode && model.elements.length > 0)\n                _ md.writeHtml('h6', model, ctx, callback)\n            else\n                _ ctx.w(\"##### \" + model.wzName)\n                r_cb()\n    \n        async-md( a )\n            if ctx.isHtml || (!ctx.isCode && model.elements.length > 0)\n                _ md.writeHtml('a', model, ctx, callback)\n            else\n                _ ctx.write('[' + model.wzName + ']')\n                _ ctx.write('(' + model.href)\n                if verify.isString(model.title)\n                    _ ctx.write(' \"' + model.title + '\"')\n                _ ctx.w(')')\n                r_cb()\n\n        async-md( ul )\n            _ md.genItems(model.elements, ctx, callback)\n\n        async-md( li )\n            _ ctx.write('* ')\n            if model.wzName && model.wzName.length > 0\n                _ ctx.write(model.wzName + ' ' )\n            _md_gen_items( elements)\n                _ ctx.w('')\n                r_cb()\n    \n        async-md( ol )\n            _md_gen_items( elements)\n                r_cb()\n\n        async-md( img )\n            if ctx.isHtml || (!ctx.isCode && model.elements.length > 0)\n                _ md.writeHtml('img', model, ctx, callback)\n            else\n                _ ctx.write('![' + model.wzName + ']')\n                _ ctx.write('(' + model.src)\n                if verify.isString(model.title)\n                    _ ctx.write(' \"' + model.title + '\"')\n                _ ctx.w(')')\n                r_cb()\n\n        async-md( video )\n            r_cb()\n\n        async-md( table )\n            _ ctx.w\n            _ ctx.w('<table>')\n            _md_gen_items( elements )\n                _ ctx.w('</table>')\n                _ ctx.w\n                r_cb()\n\n        async-md( thead )\n            _ ctx.w('<thead>')\n            _md_gen_items( elements )\n                _ ctx.w('</thead>')\n                r_cb()\n\n        async-md( tbody )\n            _ ctx.w('<tbody>')\n            _md_gen_items( elements )\n                _ ctx.w('</tbody>')\n                r_cb()\n\n\n        async-md( tr )\n            _ ctx.w('<tr>')\n            _md_gen_items( elements )\n                _ ctx.w('</tr>')\n                r_cb()\n\n        async-md( td )\n            _ ctx.write('<td>')\n            if model.wzName\n                _ ctx.write(model.wzName)\n            if model.elements && model.elements.length > 0\n                _ ctx.w()\n                _md_gen_items( elements )\n                    r_cb()\n            else\n                _ ctx.w('</td>')\n                r_cb()\n\n        async-md( th )\n            _ ctx.write('<th>')\n            if model.wzName\n                _ ctx.write(model.wzName)\n                r_cb()\n            if model.elements && model.elements.length > 0\n                _ ctx.w()\n                _md_gen_items( elements )\n                    r_cb()\n            else\n                _ ctx.w('</th>')\n                r_cb()\n\n        async-md( quote )\n            r_cb()\n\n        async-md( hr )\n            _ ctx.w('* * *')\n            r_cb()\n\n        async-md( p )\n            if ctx.isHtml || (!ctx.isCode && model.elements.length > 0)\n                _ md.writeHtml('p', model, ctx,callback)\n            else\n                _ ctx.w(model.wzName)\n                if ctx.isCode\n                    _ ctx.indent()\n                _md_gen_items( elements )\n                    if ctx.isCode\n                        _ ctx.deindent()\n                    _ ctx.w('')\n                    r_cb()\n    \n        async-md( span )\n            _ ctx.write\n                _ verify.replaceAll(model.wzName, '&nbsp;', ' ')\n            _md_gen_items( elements )\n                r_cb()\n\n        async-md( br )\n            _ ctx.w()\n            r_cb()\n    \n        async-md( i )\n            _ ctx.write('*' + model.wzName)\n            _md_gen_items( elements )\n                _ ctx.write('*')\n                r_cb()\n    \n        async-md( b )\n            _ ctx.write('**' + model.wzName)\n            _md_gen_items( elements )\n                _ ctx.write('**')\n                r_cb()\n    \n        async-md( blank )\n            _ ctx.write(' ' + model.wzName)\n            _md_gen_items( elements )\n                r_cb()\n    \n        async-md( plus )\n            if ctx.isCode\n                _ ctx.w(model.wzName)\n            else\n                _ ctx.w(\"`\" + model.wzName + \"`\")\n            _ ctx.indent\n            _md_gen_items( elements )\n                _ ctx.deindent\n                r_cb()\n\n        async-md( js )\n            _ ctx.w(\"```javascript\")\n            set ctx.isCode = true\n            _md_gen_items( elements )\n                set ctx.isCode = false\n                _ ctx.w(\"```\")\n                r_cb()\n\n        async-md( html )\n            _ ctx.w(\"```html\")\n            set ctx.isCode = true\n            _md_gen_items( elements )\n                set ctx.isCode = false\n                _ ctx.w(\"```\")\n                r_cb()\n\n        async-md( css )\n            _ ctx.w(\"```css\")\n            set ctx.isCode = true\n            _md_gen_items( elements )\n                set ctx.isCode = false\n                _ ctx.w(\"```\")\n                r_cb()\n\n        async-md( bash )\n            _ ctx.w(\"```bash\")\n            set ctx.isCode = true\n            _md_gen_items( elements )\n                set ctx.isCode = false\n                _ ctx.w(\"```\")\n                r_cb()\n\n        async-md( sh )\n            _ ctx.w(\"```sh\")\n            set ctx.isCode = true\n            _md_gen_items( elements )\n                set ctx.isCode = false\n                _ ctx.w(\"```\")\n                r_cb()\n\n        async-md( code )\n            _ ctx.w(\"```\" + model.wzName)\n            set ctx.isCode = true\n            _md_gen_items( elements )\n                set ctx.isCode = false\n                _ ctx.w(\"```\")\n                r_cb()\n\n        async-md( imgRef )\n            _ ctx.write('![' + model.alt + ']')\n            _ ctx.w('[' + model.wzName + ']')\n            r_cb()\n\n        async-md( ref )\n            _ ctx.write('[' + model.wzName + ']')\n            _ ctx.write(' ' + model.href)\n            _ ctx.w(' \"' + model.title + '\"')\n            r_cb()\n\n        async-md( comment )\n            _ ctx.write('')\n            _ ctx.write('[comment]: # ' + model.wzName)\n            r_cb()\n\n        +\n        set md.writeHtml\n            function\n                param tag\n                param model\n                param ctx\n                param callback\n                var saveIsHtml = ctx.isHtml\n                var saveIsCode = ctx.isCode\n                set ctx.isHtml = true\n                if !saveIsHtml\n                    _ ctx.w\n                _ ctx.write('<' + tag)\n                foreach a in getAttributes(model)\n                    var nv = verify.parseNameValue(a.wzName, a)\n                    _ ctx.write(' ' + nv.name() + '=\"' + nv.value() + '\"')\n                if model.wzElement != 'element' && model.wzName.length > 0\n                    _ ctx.write('>' + model.wzName)\n                else\n                    _ ctx.write('>')\n                set ctx.isCode = true\n                _md_gen_items( elements )\n                    _ ctx.write('</' + tag + '>')\n                    if !saveIsHtml\n                        _ ctx.w\n                        _ ctx.w\n                    set ctx.isHtml = saveIsHtml \n                    set ctx.isCode = saveIsCode\n                    r_cb()\n\n        +\n        function isLineTag\n            param model\n            return ['p', 'br'].indexOf(model.wzElement) > -1;\n\n        +\n        var knownAttributes\n            [\n                @ 'href'\n                @ 'src'\n                @ 'title'\n                @ 'id'\n                @ 'alt'\n\n        +\n        function getAttributes\n            param model\n            var ret = []\n            foreach a in model.attributes\n                _ ret.push(a)\n            foreach name in knownAttributes\n                if typeof model[name] !== 'undefined'\n                    _ ret.push\n                        {\n                            @ wzName name + ' ' + model[name]\n            return ret\n\n        $include includes\n        \n        +\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        \n        +\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        +\n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n"
                },
                {
                    "name": "md/tocss",
                    "schema": "md",
                    "artifact": "tocss",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.md\\.wizzi-override\\lib\\artifacts\\md\\tocss\\gen\\main.js.ittf",
                    "content": "module wizzi.plugin.md@${wzCtx.version}.lib.artifacts.md.tocss.gen.main\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.md',\n            name: 'tocss',\n            schema: 'md',\n            checkSchema: true,\n            isAsync: true,\n        };\n    \n    gen( &md )\n        $append imports\n            var included_writers = require('./included_writers')\n        $append main\n            _ md.md\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        \n        async-md( md )\n            _ async.mapSeries\n                @ model.elements\n                =>\n                    param childmodel\n                    param callback\n                    if childmodel.wzElement == 'cssInclude'\n                        _ md.cssInclude\n                            @ childmodel\n                            @ ctx\n                            @ callback\n                    else\n                        r_cb()\n                a_cb()\n                    r_cb()\n    \n    async-md( cssInclude )\n        if model.get_css\n            _ included_writers.writeIncludeCss\n                @ ctx\n                @ model\n                a_cb( notUsed )\n                    r_cb( true )\n        else\n            r_cb( true )\n\n"
                },
                {
                    "name": "md/tohtml",
                    "schema": "md",
                    "artifact": "tohtml",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.md\\.wizzi-override\\lib\\artifacts\\md\\tohtml\\gen\\main.js.ittf",
                    "content": "module wizzi.plugin.md@${wzCtx.version}.lib.artifacts.md.document.gen.main\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.md',\n            name: 'tohtml',\n            schema: 'md',\n            checkSchema: true,\n            isAsync: true,\n        };\n    \n    gen( &md )\n        $append imports\n            const wizzi = require('wizzi')\n            const createDOMPurify = require('dompurify')\n            const { JSDOM } = require('jsdom')\n            var marked = require('marked')\n        $append main\n            log '=====================> generateCssDocument'\n            _ generateCssDocument\n                @ model\n                a_cb( cssArtifactText )\n                    log '=====================> generateMdDocument'\n                    _ generateMdDocument\n                        @ model\n                        a_cb( mdArtifactText )\n                            try\n                                const window = new JSDOM('').window\n                                const DOMPurify = createDOMPurify(window);\n                                const clean\n                                    _ DOMPurify.sanitize\n                                        _ marked.parse\n                                            @ mdArtifactText\n                                _ ctx.w \n                                    _ generateHtml\n                                        @ cssArtifactText\n                                        @ clean\n                                r_cb( ctx )\n                            catch ex\n                                _ callback\n                                    @ ex\n\n    function generateHtml\n        param css\n        param body\n        var sb = []\n        _ sb.push('<html>')\n        _ sb.push('<head>')\n        _ sb.push('<style>')\n        _ sb.push(css)\n        _ sb.push('</style>')\n        _ sb.push('</head>')\n        _ sb.push('<body>')\n        _ sb.push(body)\n        _ sb.push('</body>')\n        _ sb.push('</html>')\n        return sb.join('\\n')\n    \n    function createWizziFactory\n        param callback\n        _ wizzi.fsFactory\n            {\n                { plugins\n                    [ items\n                        @ './wizzi.plugin.md/index'\n                        @ './wizzi.plugin.html/index'\n                        @ './wizzi.plugin.css/index'\n                        @ './wizzi.plugin.svg/index'\n                    @ pluginsBaseFolder\n                        _ path.resolve\n                            @ __dirname\n                            @ '..'\n                            @ '..'\n                            @ '..'\n                            @ '..'\n                            @ '..'\n                            @ '..'\n            @ callback\n\n    function generateMdDocument\n        param model\n        param callback\n        var artifactRequestContext\n            {\n        _ createWizziFactory\n            a_cb( wf )\n                _ wf.generateArtifact\n                    @ model\n                    @ 'from artifact md/tohtml'\n                    @ 'md/document'\n                    @ artifactRequestContext\n                    a_cb( artifactText )\n                        # loog 'md/tohtml.artifactText', artifactText\n                        r_cb( artifactText )\n\n    function generateCssDocument\n        param model\n        param callback\n        var artifactRequestContext\n            {\n        _ createWizziFactory\n            a_cb( wf )\n                _ wf.generateArtifact\n                    @ model\n                    @ 'from artifact md/tohtml'\n                    @ 'md/tocss'\n                    @ artifactRequestContext\n                    a_cb( artifactText )\n                        # loog 'md/tocss.artifactText', artifactText\n                        r_cb( artifactText )                        "
                }
            ],
            "transformations": [
                {
                    "name": "md/extended",
                    "schema": "md",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.md\\.wizzi-override\\lib\\artifacts\\md\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.md',\n            name: 'extended',\n            schema: 'md',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ],
            "wizzifiers": [
                {
                    "name": "md",
                    "schema": "md",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.md\\.wizzi-override\\lib\\wizzifiers\\md\\wizzifier.js.ittf",
                    "content": "module\n    $\n        var schemaName = 'md';\n    kind es6\n    basewizzifier()\n        $append imports\n            var md_parser = require('marked')\n            var md_Lexer = require('marked').Lexer\n            var cleanAST = require('./cleanAST')\n            +\n            function parseInternal\n                param tobeWizzified\n                param options\n                param callback\n                try\n                    var syntax \n                        _ md_Lexer.lex\n                            @ tobeWizzified\n                    return\n                        _ callback\n                            @ null\n                            @ syntax\n                catch ex\n                    return\n                        _ callback\n                            @ ex\n        +\n        function wizzify\n            param tobeWizzified\n            param options\n            param callback\n            set options = options || {};\n            set options.input = tobeWizzified\n            set options.stack = []\n            set options.formatTextNodes = []\n            set options.verbose = true\n            _ parseInternal\n                @ tobeWizzified\n                @ options\n                a_cb( syntax )\n                    # log stringify(syntax, null, 2)\n                    var root\n                        {\n                            @ tag '${schemaName}'\n                            [ children\n                    foreach item in syntax\n                        _ format(root, item, options)\n\n                    r_cb( root )\n        +\n        var format\n            function\n                param parent\n                param ast\n                param options\n                if !ast\n                    throw new Error('missing ast. parent is: ' + util.inspect(parent, { depth: 2 }))\n                if parent === null\n                    if options.starter\n                        set options.starter = false\n                    elif options.returnText\n                        # ok\n                    else\n                        _ showstack(options)\n                        throw new Error('parent is null.' + util.inspect(ast, 4))\n                if options.verbose\n                    info 'ast.type', ast.type\n                var type = ast.type === 'arguments' ? 'xarguments' : ast.type\n                var formatter = format[type]\n                if formatter\n                    if !options.stack\n                        log \"options.stack\", options\n                    _ options.stack.push(ast)\n                    var result = formatter(parent, ast, options)\n                    _ options.stack.pop()\n                    return result\n                else\n                    throw new Error('no formatter for type: ' + ast.type)\n        \n        f( blockquote, quote )\n            # \"tokens\": [\n            foreach item in node.tokens\n                _ format(ret, item, options)\n        f( code )\n            if verify.isNotEmpty(node.codeBlockStyle)\n                _ format.style\n                    @ ret\n                    {\n                        @ text node.codeBlockStyle\n                    @ options\n            if verify.isNotEmpty(node.lang)\n                _ format.lang\n                    @ ret\n                    {\n                        @ text node.lang\n                    @ options\n            _ format.text\n                @ ret\n                {\n                    @ text node.text\n                    @ tokens node.tokens\n                @ options\n        f( codespan, code )\n            # \"text\": \"\"\n            set ret.name = node.text\n        f( del )\n            # \"tokens\": [\n            foreach item in node.tokens\n                _ format(ret, item, options)\n        f( em )\n            # \"tokens\": [\n            foreach item in node.tokens\n                _ format(ret, item, options)\n        f( escape )\n        f( heading )\n            # \"depth\": 1\n            # \"tokens\": [\n            set ret.tag = 'h' + node.depth\n            foreach item in node.tokens\n                _ format(ret, item, options)\n        f( hr )\n        f( html )\n            set ret.name = node.text\n        f( image, img )\n            _ format.href\n                @ ret\n                {\n                    @ text node.href\n                @ options\n            _ format.title\n                @ ret\n                {\n                    @ text node.title\n                @ options\n        f( link, a )\n            # \"href\": \"\"\n            # \"title\": null\n            # \"tokens\": [\n            _ format.href\n                @ ret\n                {\n                    @ text node.href\n                @ options\n            _ format.title\n                @ ret\n                {\n                    @ text node.title\n                @ options\n            foreach item in node.tokens\n                _ format(ret, item, options)\n        f( list, ul )\n            # \"ordered\": false\n            # \"start\": \"\"\n            # \"loose\": false\n            # \"items\": [\n            if node.ordered\n                _ format.ordered\n                    @ ret\n                    {\n                    @ options\n            if node.loose\n                _ format.loose\n                    @ ret\n                    {\n                    @ options\n            if verify.isNotEmpty(node.start)\n                _ format.start\n                    @ ret\n                    {\n                        @ text node.start\n                    @ options\n            foreach item in node.items\n                _ format(ret, item, options)\n        f( list_item, li )\n            # \"task\": false\n            # \"loose\": false\n            # \"tokens\": [\n            if verify.isNotEmpty(node.task)\n                _ format.task\n                    @ ret\n                    {\n                        @ text node.task\n                    @ options\n            if node.ordered\n                _ format.ordered\n                    @ ret\n                    {\n                    @ options\n            foreach item in node.tokens\n                _ format(ret, item, options)\n        f( paragraph, p )\n            # tokens [\n            # text \"\"\n            foreach item in node.tokens\n                _ format(ret, item, options)\n        f( space, br )\n        f( strong, b )\n            # tokens [\n            foreach item in node.tokens\n                _ format(ret, item, options)\n        f( table )\n            foreach item in node.header\n                _ format\n                    @ ret\n                    {\n                        @ type \"th\"\n                        @ item item\n                    @ options\n            foreach item in node.rows\n                _ format\n                    @ ret\n                    {\n                        @ type \"tr\"\n                        @ items item\n                    @ options\n        f( tr )\n            foreach item in node.items\n                _ format\n                    @ ret\n                    {\n                        @ type \"td\"\n                        @ item item\n                    @ options\n        f( td )\n            log 'td.node.item', node.item\n            set node.item.type = node.item.type || 'text'\n            _ format(ret, node.item, options)\n        f( th )\n            log 'th.node.item', node.item\n            set node.item.type = node.item.type || 'text'\n            _ format(ret, node.item, options)\n        f( text, +;ret-is-array )\n            if node.tokens\n                foreach item in node.tokens\n                    _ format(ret, item, options)\n                set ret = ret.children \n            else\n                var retcontainer\n                    {\n                        [ children\n                var ss = node.text.split('\\n')\n                set ret.name = ss[0]\n                set retcontainer.children.push(ret)\n                if ss.length > 1\n                    for var i=1; i<ss.length; i++\n                        _ format.text\n                            @ retcontainer\n                            {\n                                @ text ss[i]\n                            @ options\n                set ret = retcontainer.children\n        f( href )\n            set ret.name = node.text\n        f( lang )\n            set ret.name = node.text\n        f( loose )\n        f( ordered )\n        f( start )\n            set ret.name = node.text\n        f( style )\n            set ret.tag = node.text\n        f( task )\n            set ret.name = node.text\n        f( title )\n            set ret.name = node.text\n        +\n        $include helper_functions\n        +\n        function isKnownType\n            param type\n            return ['Int', 'Float', 'Boolean', 'String'].indexOf(type) > -1\n        +\n        function getTypeName\n            param type\n            return isKnownType(type) ? type.toLowerCase() : type\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.org",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.org",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.org\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.org/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.org\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.org",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "org"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.org\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.org-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.org\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.org",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "org"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "org",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.org\\.wizzi-override\\lib\\wizzi\\schemas\\org.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema org\n    \n    export-to json\n    \n    e org\n        is-root\n        r item/s\n        r ittfPanel/s\n    \n    e item\n        r item/s\n        a value\n    \n    e profile : item\n\n    e task : item\n\n    e unit : item\n\n    e ittfPanel\n        tag ittf-panel\n        has-mtree-data\n"
                }
            ],
            "artifacts": [
                {
                    "name": "org/document",
                    "schema": "org",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.org\\.wizzi-override\\lib\\artifacts\\org\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.org',\n            name: 'document',\n            schema: 'org',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n        $append main\n            _ md.org\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        async-md( org )\n            _ ctx.w('<org>')\n            _ md.genItems\n                @ model.items\n                @ ctx\n                {\n                    @ indent true\n                a_cb()\n                    _ ctx.w('</org>')\n                    r_cb()\n"
                }
            ],
            "transformations": [
                {
                    "name": "org/extended",
                    "schema": "org",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.org\\.wizzi-override\\lib\\artifacts\\org\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.org',\n            name: 'extended',\n            schema: 'org',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n                    [ profiles\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n\n    var functors = {}\n\n    $include profile"
                }
            ]
        },
        {
            "name": "wizzi.plugin.pdf",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.pdf",
            "hasWizziOverride": false,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.pdf\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.pdf/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.pdf\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.pdf\\dist",
                        "plugins": [
                            "./wizzi-core/dist/index.js",
                            "./wizzi-js/dist/index.js",
                            "./wizzi-web/dist/index.js"
                        ],
                        "pluginsBaseFolder": "C:\\My\\wizzi\\stfnbssl\\wizzi\\packages",
                        "schemas": [
                            "pdf"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "pdf",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.pdf\\.wizzi\\lib\\wizzi\\schemas\\pdf.wfschema.ittf",
                    "genConfig": "wizzi.config.js",
                    "content": "wfschema pdf\n    $\n        var md = {\n        };\n    \n    preserve-tags true\n    mtree-is-preprocessed true\n    unknown-element-replacer text\n    \n    e node\n        r node/s\n    \n    e pdf : node\n        is-root\n    \n    e xname : node\n        tag name\n    e section : node\n    e h1 : node\n    e h2 : node\n    e color : node\n    e fill : node\n    e size : node\n    e width : node\n    e height : node\n    e shading : node\n    e highlight : node\n    e xtype : node\n        tag type\n    e center : node\n    e bullet_0 : node\n    e tabStop : node\n    e position : node\n    e basedOn : node\n    e next : node\n\n    #\n    #\n    # Styles\n    #\n    e defaultStyleDef : node\n        tag default-style-def\n    e styleDef : node\n        tag style-def\n    e styles : node\n    e style : node\n\n    #\n    #\n    # Layout\n    #\n    e pageSize : node\n        tag page-size\n        # '4A0', '2A0', 'A0', 'A1', 'A2', 'A3', 'A4', 'A5', 'A6', 'A7', 'A8', 'A9', 'A10',\n        # 'B0', 'B1', 'B2', 'B3', 'B4', 'B5', 'B6', 'B7', 'B8', 'B9', 'B10',\n        # 'C0', 'C1', 'C2', 'C3', 'C4', 'C5', 'C6', 'C7', 'C8', 'C9', 'C10',\n        # 'RA0', 'RA1', 'RA2', 'RA3', 'RA4',\n        # 'SRA0', 'SRA1', 'SRA2', 'SRA3', 'SRA4',\n        # 'EXECUTIVE', 'FOLIO', 'LEGAL', 'LETTER', 'TABLOID'\n\n    e pageOrientation : node\n        tag page-orientation\n        # portrait, landscape\n  \n    e pageMargins : node\n        tag page-margins\n        # [left, top, right, bottom] or [horizontal, vertical] or just a number for equal margins\n        m wzinitialize\n            var ss = this.wzName.split(/[\\s,]+/)\n            set this.wzName = ss.join(',')\n\n    e margin : node\n        m wzinitialize\n            var ss = this.wzName.split(/[\\s,]+/)\n            if ss.length == 1\n                set this.wzName = ss[0] + ',' + ss[0] + ',' + ss[0] + ',' + ss[0] \n            elif ss.length == 2\n                set this.wzName = ss[0] + ',' + ss[1] + ',' + ss[0] + ',' + ss[1] \n            elif ss.length == 3\n                set this.wzName = ss[0] + ',' + ss[1] + ',' + ss[2] + ',0'\n            else\n                set this.wzName = ss[0] + ',' + ss[1] + ',' + ss[2] + ',' + ss[3]\n            log 'margin', this.wzName\n\n    #\n    #\n    # Tables\n    #\n    e table : node\n    e tr : node\n    e td : node\n    e headerRows : node\n        tag header-rows\n    e widths : node\n        m wzinitialize\n            var ss = this.wzName.split(/[\\s,]+/)\n            set this.wzName = ss.join(',')\n    e layout : node\n        # noBorders\n        # headerLineOnly\n        # lightHorizontalLines\n\n    #\n    #\n    # Columns\n    #\n    e columns : node\n    e columnGap : node\n        tag column-gap\n\n    #\n    #\n    # Text\n    #\n    e text : node\n        tag +\n    \n    e emphasisMark : node\n    \n    e strike : node\n    \n    e doubleStrike : node\n    \n    e superScript : node\n    \n    e subScript : node\n    \n    e smallCaps : node\n    \n    e allCaps : node\n    \n    e smallCaps : node\n\n    e font : node\n        # string: name of the font\n    \n    e fontSize : node\n        tag font-size\n        # number: size of the font in pt\n    \n    e fontFeatures : node\n        tag font-features\n        # string[]: array of advanced typographic features supported in TTF fonts (supported features depend on font file)\n    \n    e lineHeight : node\n        tag line-height\n        # number: the line height (default: 1)\n\n    e bold : node\n        tag b\n    e boldProp : node\n        tag bold\n    \n    e italics : node\n        tag i\n    \n    e italicsProp : node\n        tag italics\n    \n    e underline : node\n        tag u\n    e underlineProp : node\n        tag underline\n    \n    e alignment : node\n        # string: (left or center or right) the alignment of the text\n    \n    e characterSpacing : node\n        tag character-spacing\n        # number: size of the letter spacing in pt\n    \n    e color : node\n        # string: the color of the text (color name e.g., blue or hexadecimal color e.g., #ff5500)\n    \n    e background : node\n        # string the background color of the text\n    \n    e markerColor : node\n        tag marker-color\n        # string: the color of the bullets in a buletted list\n    \n    e decoration : node\n        # string: the text decoration to apply (underline or lineThrough or overline)\n    \n    e decorationStyle : node\n        tag decoration-style\n        # string: the style of the text decoration (dashed or dotted or double or wavy)\n\n    e noWrap : node\n        tag no-wrap\n\n    #\n    #\n    # Paragraph\n    #\n    e p : node\n        # subitems are \"+/text\" nodes\n    e stack : node\n        # subitems are \"p\" nodes\n    e break : node\n        tag br\n\n    #\n    #\n    # Lists\n    #\n    e ul : node\n    e ol : node\n\n    #\n    #\n    # Images\n    #\n    e image : node\n\n    e imageDef : node\n        a src\n        a title\n        tag image-def\n    \n    e imageRef : node\n        tag image-ref"
                }
            ],
            "artifacts": [
                {
                    "name": "pdf/document",
                    "schema": "pdf",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.pdf\\.wizzi\\lib\\artifacts\\pdf\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: '',\n            name: 'document',\n            schema: 'pdf',\n            checkSchema: true,\n            isAsync: true,\n        };\n    v08/lib/artifacts/gen(&md)\n        $append imports\n        $append main\n            _ md.pdf\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        +\n        const noindent\n            {\n                @ indent false\n        +\n        function respace\n            param text\n            set text = verify.replaceAll(text, '&nbsp;', ' ')\n            return verify.replaceAll(text, '\"', '\\\\\"')\n            \n        +\n        async-md( pdf )\n            # log \"ctx.keys\", Object.keys(ctx)\n            # log \"ctx.values property\", ctx.values\n            # log 'tag pdf, nodes', model.nodes.length\n\n            set ctx.values.pdfStack = []\n            set ctx.values.pdfCounter = 0\n            set ctx.values.pdfMainObject = 'pdf_MainObject'\n            set ctx.values.mainObjectCreated = false\n            set ctx.values.bulletLevel = 0\n            \n            var pdfNode = \"pdf_doc_\" + (++ctx.values.pdfCounter)\n            set ctx.values.pdfMainDocumentDefinition = pdfNode\n            _ ctx.values.pdfStack.push\n                {\n                    @ node pdfNode\n                    @ arrayName null\n            set ctx.values.pdfMainInternalObject = pdfNode\n            \n            _ ctx.w('const fs = require(\"fs\");')\n            _ ctx.w('const pdfmake = require(\"pdfmake\");')\n            _ ctx.w('')\n            _ ctx.w('const ' + pdfNode + ' = { content: [], styles: {} };')\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                @ noindent\n                a_cb()\n                    _ ctx.w('')\n                    _ ctx.w('// Make Pdf')\n                    _ ctx.w('')\n                    _ ctx.w('// Build document definition')\n                    _ ctx.w('var now = new Date();')\n                    _ ctx.w('var documentDefinition = ' + ctx.values.pdfMainDocumentDefinition + ';')\n                    _ ctx.w('pdf_MainObject.sections.forEach(section => {')\n                    _ ctx.w('    section.content.forEach(contentItem => {')\n                    _ ctx.w('        documentDefinition.content.push(contentItem);')\n                    _ ctx.w('    });')\n                    _ ctx.w('    Object.assign({}, documentDefinition.styles, section.styles);')\n                    _ ctx.w('});')\n                    $if wzConfigIsDevelopment\n                        _ ctx.w('')\n                        _ ctx.w('// Dump for test')\n                        _ ctx.w('    fs.writeFileSync(__dirname + \"/' + model.wzName + '.json\", JSON.stringify(documentDefinition, null, \"\\t\"));')\n                    _ ctx.w('')\n                    _ ctx.w('// Set fonts')\n                    _ ctx.w('var fonts = {')\n                    _ ctx.w('\tRoboto: {')\n                    _ ctx.w('\t\tnormal: __dirname + \"/fonts/Roboto-Regular.ttf\",')\n                    _ ctx.w('\t\tbold: __dirname + \"/fonts/Roboto-Medium.ttf\",')\n                    _ ctx.w('\t\titalics: __dirname + \"/fonts/Roboto-Italic.ttf\",')\n                    _ ctx.w('\t\tbolditalics: __dirname + \"/fonts/Roboto-MediumItalic.ttf\"')\n                    _ ctx.w('\t}')\n                    _ ctx.w('};')\n                    _ ctx.w('')\n                    _ ctx.w('// Create document')\n                    _ ctx.w('var printer = new pdfmake(fonts);')\n                    _ ctx.w('var pdfDoc = printer.createPdfKitDocument(documentDefinition);')\n                    _ ctx.w('pdfDoc.pipe(fs.createWriteStream(__dirname + \"/' + (model.wzName || 'created') + '.pdf\"));')\n                    _ ctx.w('pdfDoc.end();')\n                    _ ctx.w('console.log(\"DONE written\", new Date() - now)')\n                    r_cb()\n\n        +\n        async-md( section )\n            # log 'tag section, value', model.wzName\n            \n            var pdfParent = ctx.values.pdfStack[ctx.values.pdfStack.length-1]\n            var pdfNode = \"pdf_sect_\" + (++ctx.values.pdfCounter)\n            _ ctx.values.pdfStack.push\n                {\n                    @ node pdfNode\n                    @ arrayName \"content\"\n            _ ctx.w('const ' + pdfNode + ' = { content: [], styles: {} };')\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                @ noindent\n                a_cb()\n                    if ctx.values.mainObjectCreated == false\n                        # _ ctx.w('const ' + ctx.values.pdfMainObject + ' = new pdf.Document(' + ctx.values.pdfMainInternalObject + ');')\n                        _ ctx.w('const ' + ctx.values.pdfMainObject + ' = { sections : [] };')\n                        set ctx.values.mainObjectCreated = true\n                    _ ctx.w(pdfNode + \".content.push({ text: ' ', pageBreak: 'after'});\")\n                    _ ctx.w(ctx.values.pdfMainObject + '.sections.push(' + pdfNode + ');')\n                    _ ctx.values.pdfStack.pop()\n                    r_cb()\n        +\n        objectNode.js( p, text )   \n            _ ctx.w(pdfNode + '.text = [];')\n            if !verify.isEmpty(model.wzName)\n                _ ctx.w(pdfNode + '.text.push(\"' + respace(model.wzName) + '\");')\n            $append close\n                _ ctx.w(pdfParent + '[\"' + pdfParentArrayName + '\"].push(' + pdfNode + ');')\n\n        objectNode.js( columns, columns )   \n            _ ctx.w(pdfNode + '.columns = [];')\n            $append close\n                _ ctx.w(pdfParent + '[\"' + pdfParentArrayName + '\"].push(' + pdfNode + ');')\n\n        objectNode.js( stack, stack )   \n            _ ctx.w(pdfNode + '.stack = [];')\n            $append close\n                _ ctx.w(pdfParent + '[\"' + pdfParentArrayName + '\"].push(' + pdfNode + ');')\n\n        objectNode.js( image )\n            _ ctx.w(pdfNode + '.image = \"' + model.wzName + '\";')\n            $append close\n                _ ctx.w(pdfParent + '[\"' + pdfParentArrayName + '\"].push(' + pdfNode + ');')\n\n        async-md( imageDef )\n            if ctx.values.mainObjectCreated == false\n                _ ctx.w('const ' + ctx.values.pdfMainObject + ' = new pdf.Document(' + ctx.values.pdfMainInternalObject + ');')\n                set ctx.values.mainObjectCreated = true\n            _ ctx.w('const ' + model.wzName + ' = pdf.Media.addImage(')\n            # _ ctx.w('  ' + ctx.values.pdfMainObject + ', 300, 300,')\n            _ ctx.w('  ' + ctx.values.pdfMainObject + ',')\n            _ ctx.w('  fs.readFileSync(\"' + verify.replaceAll(model.src, '\\\\', '\\\\\\\\') + '\")')\n            _ ctx.w(');')\n            r_cb()\n\n        async-md( imageRef )\n            var pdfParent = ctx.values.pdfStack[ctx.values.pdfStack.length-1]\n            _ ctx.w(pdfParent + '.children.push(' + model.wzName + ');')\n            r_cb()\n\n        +\n        headings( 1 )\n        headings( 2 )\n        headings( 3 )\n        headings( 4 )\n        headings( 5 )\n        headings( 6 )\n\n        textNode.js( text )\n        \n        textNode.js( bold )\n            _ ctx.w(pdfNode + '.bold = true;')\n        textNode.js( italics ) \n            _ ctx.w(pdfNode + '.italics = true;')\n        textNode.js( underline ) \n            _ ctx.w(pdfNode + '.underline = true;')\n        \n        \n        nodeProperty.js( pageOrientation, pageOrientation, string )\n        nodeProperty.js( pageSize, pageSize, string )\n        nodeProperty.js( pageMargins, pageMargins, array )\n        nodeProperty.js( boldProp, bold, true )\n        nodeProperty.js( italicsProp, italics, true )\n        nodeProperty.js( underlineProp, underline, true )\n        nodeProperty.js( emphasisMark, emphasisMark, true )\n        nodeProperty.js( strike, strike, true )\n        nodeProperty.js( doubleStrike, doubleStrike, true )\n        nodeProperty.js( superScript, superScript, true )\n        nodeProperty.js( subScript, subScript, true )\n        nodeProperty.js( smallCaps, smallCaps, true )\n        nodeProperty.js( allCaps, allCaps, true )\n        nodeProperty.js( font, font, string )\n        nodeProperty.js( fontSize, fontSize )\n\n        nodeProperty.js( xbreak, break, true )\n        nodeProperty.js( size, size )\n        nodeProperty.js( color, color, string )\n        nodeProperty.js( background, background, string )\n        nodeProperty.js( fill, background, string )\n        nodeProperty.js( xname, name, string )\n        nodeProperty.js( highlight, highlight, string )\n        nodeProperty.js( style, style, string )\n        nodeProperty.js( next, next, string )\n        nodeProperty.js( basedOn, basedOn, string )\n        nodeProperty.js( before, before )\n        nodeProperty.js( after, after )\n        nodeProperty.js( line, line )\n        nodeProperty.js( link, link, string )\n        nodeProperty.js( linkText, text, string )\n        nodeProperty.js( value, value, string )\n        nodeProperty.js( space, space )\n        nodeProperty.js( height, height )\n        nodeProperty.js( margin, margin, array )\n        nodeProperty.js( width, width )\n        nodeProperty.js( widths, table.widths, array )\n        nodeProperty.js( headerRows, table.headerRows )\n        nodeProperty.js( layout, layout, string )\n        nodeProperty.js( noWrap, noWrap, true )\n        nodeProperty.js( columnGap, columnGap )\n        \n        nodePropertyChoice.js( xtype)\n            if model.wzParent.wzElement == 'shading'\n                _ ctx.w(pdfParent + '.type = pdf.ShadingType.' + model.wzName + ';')\n            elif model.wzParent.wzElement == 'width'\n                _ ctx.w(pdfParent + '.type = pdf.WidthType.' + model.wzName + ';')\n            elif model.wzParent.wzElement == 'tabStop'\n                _ ctx.w(pdfParent + '.type = pdf.TabStopType.' + model.wzName + ';')\n            elif model.wzParent.wzElement == 'underline'\n                _ ctx.w(pdfParent + '.type = pdf.UnderlineType.' + model.wzName + ';')\n            elif model.wzParent.wzElement == 'hyperlinkDef'\n                if model.wzName && model.wzName.length > 0\n                    _ ctx.w(pdfParent + '.type = pdf.HyperlinkType.' + model.wzName + ';')\n                else\n                    _ ctx.w(pdfParent + '.type = pdf.HyperlinkType.EXTERNAL;')\n            else\n                _ ctx.w(pdfParent + '.type = \"' + model.wzName + '\";')\n        \n        nodePropertyChoice.js( position )\n            if model.wzParent.wzElement == 'tabStop'\n                if verify.isNumber(model.wzName)\n                    _ ctx.w(pdfParent + '.position = ' + model.wzName + ';')\n                else\n                    _ ctx.w(pdfParent + '.position = pdf.TabStopPosition.' + model.wzName + ';')\n            else\n                _ ctx.w(pdfParent + '.position = ' + model.wzName + ';')\n\n        nodePropertyChoice.js( alignment )\n            _ ctx.w(pdfParent + '.alignment = \"' + model.wzName + '\";')\n        \n        nodePropertyChoice.js( hyperlinkRef )\n            _ ctx.w(pdfParent + '.children.push(new pdf.HyperlinkRef(\"' + model.wzName + '\"));')\n\n        $*\n        async-md( xtype )\n            var pdfParent = ctx.values.pdfStack[ctx.values.pdfStack.length-1]\n            if model.wzParent.wzElement == 'shading'\n                _ ctx.w(pdfParent + '.type = pdf.ShadingType.' + model.wzName + ';')\n            elif model.wzParent.wzElement == 'width'\n                _ ctx.w(pdfParent + '.type = pdf.WidthType.' + model.wzName + ';')\n            else\n                _ ctx.w(pdfParent + '.type = \"' + model.wzName + '\";')\n            r_cb()\n        *$\n        +\n        async-md( font )\n\n            pdfNode.js( fnt )\n            _ ctx.w('const ' + pdfNode + ' = {};')\n        \n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                @ noindent\n                a_cb()\n                    _ ctx.w(pdfParent + '.font = ' + pdfNode + ';')\n                    _ ctx.values.pdfStack.pop()\n                    r_cb()\n\n        +\n        async-md( shading )\n\n            pdfNode.js( shd )\n            _ ctx.w('const ' + pdfNode + ' = {};')\n        \n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                @ noindent\n                a_cb()\n                    _ ctx.w(pdfParent + '.shading = ' + pdfNode + ';')\n                    _ ctx.values.pdfStack.pop()\n                    r_cb()\n\n        objectNode.js( table, body )\n            _ ctx.w(pdfNode + '.table = { body: [] };')\n            $append close\n                _ ctx.w(pdfParent + '[\"' + pdfParentArrayName + '\"].push(' + pdfNode + ');')                \n\n        objectNode.js( tr, tds )   \n            _ ctx.w(pdfNode + '.tds = [];')\n            $append close\n                _ ctx.w(pdfParent + '.table.body.push(' + pdfNode + '.tds);')\n\n        objectNode.js( underline )   \n            $append close\n                _ ctx.w(pdfNode + '.underline = ' + pdfNode + ';')\n\n        objectNode.js( styles )\n            $append close\n                _ ctx.w(pdfParent + '.styles = ' + pdfNode + ';')\n\n        objectNode.js( xdefault )\n            $append close\n                _ ctx.w(pdfParent + '.default = ' + pdfNode + ';')\n\n        objectNode.js( run )\n            $append close\n                _ ctx.w(pdfParent + '.run = ' + pdfNode + ';')\n        \n        objectNode.js( tabStop )\n            $append close\n                _ ctx.w(pdfParent + '.tabStops.push(' + pdfNode + ');')\n\n        objectNode.js( styleDef )\n            if model.wzParent.wzElement == 'paragraphStyles'\n                _ ctx.w(pdfNode + '.id = \"' + model.wzName + '\";')\n            $append close\n                if model.wzParent.wzElement == 'xdefault'\n                    _ ctx.w(pdfParent + '.' + model.wzName + ' = ' + pdfNode + ';')\n                else\n                    _ ctx.w(pdfParent + '.styles[\"' + model.wzName + '\"] = ' + pdfNode + ';')\n\n        objectNode.js( defaultStyleDef )\n            $append close\n                _ ctx.w(pdfParent + '.defaultStyle = ' + pdfNode + ';')\n\n        objectNode.js( spacing )\n            $append close\n                _ ctx.w(pdfParent + '.spacing = ' + pdfNode + ';')\n\n        objectNode.js( hyperlinks )\n            $append close\n                _ ctx.w(pdfParent + '.hyperlinks = ' + pdfNode + ';')\n\n        objectNode.js( hyperlinkDef )\n            $append close\n                _ ctx.w(pdfParent + '.' + model.wzName + ' = ' + pdfNode + ';')\n\n        objectNode.js( border )\n            $append close\n                _ ctx.w(pdfParent + '.border = ' + pdfNode + ';')\n\n\n        $$ objectNodeSimple.js( border )\n        objectNodeSimple.js( top )\n        objectNodeSimple.js( left )\n        objectNodeSimple.js( right )\n        objectNodeSimple.js( bottom )\n\n        arrayNode.js( paragraphStyles )\n            $append close\n                _ ctx.w(pdfParent + '.paragraphStyles = ' + pdfNode + ';')\n\n        objectNode.js( ul, ul )\n            _ ctx.w(pdfNode + '.ul = [];')\n            $append close\n                _ ctx.w(pdfParent + '[\"' + pdfParentArrayName + '\"].push(' + pdfNode + ');')\n\n        objectNode.js( ol, ol )\n            _ ctx.w(pdfNode + '.ul = [];')\n            $append close\n                _ ctx.w(pdfParent + '[\"' + pdfParentArrayName + '\"].push(' + pdfNode + ');')\n\n        objectNode.js( li, text )\n            _ ctx.w(pdfNode + '.text = [];')\n            $append close\n                _ ctx.w(pdfParent + '.children.push(' + pdfNode + 'Obj);')\n                _ ctx.w(pdfParent + '[\"' + pdfParentArrayName + '\"].push(' + pdfNode + ');')                \n"
                }
            ],
            "transformations": [
                {
                    "name": "pdf/extended",
                    "schema": "pdf",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.pdf\\.wizzi\\lib\\artifacts\\pdf\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: '',\n            name: 'extended',\n            schema: 'sample',\n            checkSchema: true\n        };\n    v08/lib/artifacts/trans(&md)\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.ppt",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ppt",
            "hasWizziOverride": false,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ppt\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.ppt/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ppt\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ppt\\dist",
                        "plugins": [
                            "./wizzi-core/dist/index.js",
                            "./wizzi-js/dist/index.js",
                            "./wizzi-web/dist/index.js"
                        ],
                        "pluginsBaseFolder": "C:\\My\\wizzi\\stfnbssl\\wizzi\\packages",
                        "schemas": [
                            "ppt"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "ppt",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ppt\\.wizzi\\lib\\wizzi\\schemas\\ppt.wfschema.ittf",
                    "genConfig": "wizzi.config.js",
                    "content": "wfschema ppt\n    $\n        var md = {\n        };\n    \n    preserve-tags true\n    mtree-is-preprocessed true\n    unknown-element-replacer text\n    \n    e node\n        r node/s\n    \n    e comment : node\n        tag # \n\n    e ppt : node\n        is-root\n        a author\n        a company\n        a revision\n        a subject\n        a title\n        a_flag( rtlMode , rtl-mode )\n\n    e shading : node\n    e highlight : node\n    e center : node\n\n    #\n    #\n    # Common properties\n    #\n    e xname : node\n        tag name\n    e xtype : node\n        tag type\n    e width : node\n    e w : node\n    e height : node\n    e h : node\n    e fill : node\n    e size : node\n    e x : node\n    e y : node\n    e path : node\n\n    #\n    #\n    # Slide\n    #\n    e slide : node        \n    e number : node        \n\n    #\n    #\n    # links\n    #\n    e link : node\n    e href : node\n    e slideHref : node\n        tag slide-href\n    e title : node\n\n    #\n    #\n    # Styles\n    #\n    e defaultStyleDef : node\n        tag default-style-def\n    e styleDef : node\n        tag style-def\n    e styles : node\n    e style : node\n\n    #\n    #\n    # Layout\n    #\n    e layout : node\n        # LAYOUT_16x9 (default) : 10 x 5.625 inches\n        # LAYOUT_16x10          : 10 x 6.25 inches\n        # LAYOUT_4x3            : 10 x 7.5 inches\n        # LAYOUT_WIDE           : 13.3 x 7.5 inches\n        # <custom> see layoutDef\n\n    e layoutDef : node\n        tag layout-def\n        # name (wzName), width, height\n\n    e pageMargins : node\n        tag page-margins\n        # [left, top, right, bottom] or [horizontal, vertical] or just a number for equal margins\n        m wzinitialize\n            var ss = this.wzName.split(/[\\s,]+/)\n            set this.wzName = ss.join(',')\n\n    e margin : node\n        m wzinitialize\n            var ss = this.wzName.split(/[\\s,]+/)\n            if ss.length == 1\n                set this.wzName = ss[0] + ',' + ss[0] + ',' + ss[0] + ',' + ss[0] \n            elif ss.length == 2\n                set this.wzName = ss[0] + ',' + ss[1] + ',' + ss[0] + ',' + ss[1] \n            elif ss.length == 3\n                set this.wzName = ss[0] + ',' + ss[1] + ',' + ss[2] + ',0'\n            else\n                set this.wzName = ss[0] + ',' + ss[1] + ',' + ss[2] + ',' + ss[3]\n            log 'margin', this.wzName\n\n    #\n    #\n    # Tables\n    #\n    e table : node\n    e tr : node\n    e td : node\n    e layout : node\n        # noBorders\n        # headerLineOnly\n        # lightHorizontalLines\n    e colW : node\n        tag col-w\n    e rowH : node\n        tag row-h\n    # cells\n    e autoPageCharWeight : node\n        tag auto-page-char-weight\n        # Auto-paging line weight\n        # - adjusts how many lines are used before slides wrap\n        # - range: -1.0 to 1.0\n        # @see https://gitbrent.github.io/PptxGenJS/docs/api-tables.html\n    e autoPageLineWeight : node\n        tag auto-page-line-weight\n\t# border : node\n    e colspan : node\n    e rowspan : node\n\t# fill\n    # margin\n\n    #\n    #\n    # Columns\n    #\n    e columns : node\n    e columnGap : node\n        tag column-gap\n\n    #\n    #\n    # Text\n    #\n    e text : node\n        tag +\n    \n    e emphasisMark : node\n    \n    e strike : node\n    \n    e doubleStrike : node\n    \n    e superScript : node\n    \n    e subScript : node\n    \n    e smallCaps : node\n    \n    e allCaps : node\n    \n    e smallCaps : node\n\n    e font : node\n        # string: name of the font\n    \n    e fontSize : node\n        tag font-size\n        # number: size of the font in pt\n    \n    e fontFeatures : node\n        tag font-features\n        # string[]: array of advanced typographic features supported in TTF fonts (supported features depend on font file)\n    \n    e lineHeight : node\n        tag line-height\n        # number: the line height (default: 1)\n\n    e bold : node\n        tag b\n    e boldProp : node\n        tag bold\n    \n    e italic : node\n        tag i\n    \n    e italicProp : node\n        tag italic\n    \n    e underline : node\n        tag u\n    e underlineProp : node\n        tag underline\n    \n    e align : node\n        # string: (left or center or right) the alignment of the text\n\n    e alignment : node\n        # string: (left or center or right) the alignment of the text\n    \n    e valign : node\n        # string: (top or middle or bottom) the vertical alignment of the text\n\n    e valignment : node\n        # string: (top or middle or bottom) the vertical alignment of the text\n\n    e charSpacing : node\n        tag char-spacing\n        # number: size of the letter spacing in pt\n\n    e characterSpacing : node\n        tag character-spacing\n        # number: size of the letter spacing in pt\n    \n    e color : node\n        # string: the color of the text (color name e.g., blue or hexadecimal color e.g., #ff5500)\n    \n    e bkgd : node\n    e background : node\n        # string the background color of the text\n    \n    e markerColor : node\n        tag marker-color\n        # string: the color of the bullets in a buletted list\n    \n    e decoration : node\n        # string: the text decoration to apply (underline or lineThrough or overline)\n    \n    e decorationStyle : node\n        tag decoration-style\n        # string: the style of the text decoration (dashed or dotted or double or wavy)\n\n    e noWrap : node\n        tag no-wrap\n\n    #\n    #\n    # Html-like text paragraph\n    #\n    e h1 : node\n    e h2 : node\n\n    #\n    #\n    # Paragraph\n    #\n    e p : node\n        # has no \"p\" or \"+/text\" child nodes\n    e pStack : node\n        # has \"p\" or '+/text' child nodes\n        tag p-stack\n    e break : node\n        tag br\n\n    #\n    #\n    # Lists\n    #\n    e ul : node\n    e ol : node\n    e bullet : node\n    e bulletObj : node\n        tag bullet-obj\n    e code : node\n    e indent : node\n    e indentLevel : node\n        tag indent-level\n    e charCode : node\n        tag char-code\n    e characterCode : node\n        tag character-code\n\n    #\n    #\n    # Images\n    #\n    e image : node\n    # e hyperlink : node\n    e placeholder : node\n        # string // 'body' | 'title' | etc.\n    e rotate : node\n        # rotation (degrees) - range: -360 to 360\n    e rounding : node\n        # Enable image rounding - boolean\n\te sizing : node\n        # type: 'contain' | 'cover' | 'crop'\n        # w h x y\n\n    e imageDef : node\n        a src\n        a title\n        tag image-def\n    \n    e imageRef : node\n        tag image-ref\n\n    #\n    #\n    # Border\n    #\n    e border : node\n    e top : node\n    e right : node\n    e bottom : node\n    e left : node\n    e pt : node\n\n    #\n    #\n    # Shadow\n    #\n    e shadow : node\n    # type: 'outer' | 'inner' | 'none' (*)\n    e opacity : node\n        # (0-100%)\" in PPT\n    e blur : node\n        # range: 0-100\n    e angle : node\n        # (degrees) - range: 0-359\n    e offset : node \n        # shadow offset (points) - range: 0-200\n    # color\n\n    $include ppt/shapes\n\t"
                }
            ],
            "artifacts": [
                {
                    "name": "ppt/document",
                    "schema": "ppt",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ppt\\.wizzi\\lib\\artifacts\\ppt\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: '',\n            name: 'document',\n            schema: 'ppt',\n            checkSchema: true,\n            isAsync: true,\n        };\n    v08/lib/artifacts/gen(&md)\n        $append imports\n        $append main\n            _ md.ppt\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        +\n        const noindent\n            {\n                @ indent false\n        +\n        function respace\n            param text\n            set text = verify.replaceAll(text, '&nbsp;', ' ')\n            return verify.replaceAll(text, '\"', '\\\\\"')\n            \n        function numOrPerc\n            param text\n            if text[text.length-1] == '%'\n                return '\"' + text + '\"'\n            else\n                return text\n\n        +\n        async-md( ppt )\n            # log \"ctx.keys\", Object.keys(ctx)\n            # log \"ctx.values property\", ctx.values\n            # log 'tag ppt, nodes', model.nodes.length\n\n            set ctx.values.pptStack = []\n            set ctx.values.pptCounter = 0\n            set ctx.values.pptMainObject = 'ppt_MainObject'\n            set ctx.values.mainObjectCreated = false\n            \n            var pptNode = \"ppt_doc_\" + (++ctx.values.pptCounter)\n            set ctx.values.pptMainInstance = pptNode\n            _ ctx.values.pptStack.push\n                {\n                    @ node pptNode\n                    @ arrayName null\n            set ctx.values.pptMainInternalObject = pptNode\n            \n            _ ctx.w('const fs = require(\"fs\");')\n            _ ctx.w('const pptx = require(\"pptxgenjs\");')\n            _ ctx.w('')\n            _ ctx.w('const ' + ctx.values.pptMainInstance + ' = new pptx();')\n            _ ctx.w('const ' + ctx.values.pptMainInstance + '_debug = { defaultStyle: {}, styles: {}, slides: [] };')\n            _ ctx.w('const defaultStyle = { content: {} };')\n            _ ctx.w('const styles = {};')\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                @ noindent\n                a_cb()\n                    $if wzConfigIsDevelopment\n                        _ ctx.w('')\n                        _ ctx.w('// Dump for test')\n                        _ ctx.w('    fs.writeFileSync(__dirname + \"/' + model.wzName + '.ppt.json\", JSON.stringify(' + ctx.values.pptMainInstance + '_debug, null, \"\\t\"));')\n                    _ ctx.w('')\n                    _ ctx.w('// Make Ppt')\n                    _ ctx.w('')\n                    _ ctx.w('var now = new Date();')\n                    _ ctx.w('')\n                    _ ctx.w(ctx.values.pptMainInstance + '.writeFile(')\n                    _ ctx.w('    __dirname + \"/' + (model.wzName || 'created') + '.ppt\"')\n                    _ ctx.w(').then(fileName => {')\n                    _ ctx.w('    console.log(`created file: ${fileName}`);')\n                    _ ctx.w('    console.log(\"DONE written\", new Date() - now)')\n                    _ ctx.w('});')\n                    r_cb()\n\n        async-md( comment )\n            _ ctx.w('// ' + model.wzName)\n            r_cb()\n        +\n        async-md( slide )\n            var master = verify.isEmpty(model.wzName) == false ? '\"' + model.wzName + '\"' : ''\n            # log 'tag slide, master', master\n\n            \n            var pptParent = ctx.values.pptStack[ctx.values.pptStack.length-1]\n            var pptNode = \"ppt_slide_\" + (++ctx.values.pptCounter)\n            _ ctx.values.pptStack.push\n                {\n                    @ node pptNode\n                    @ arrayName null\n            _ ctx.w('const ' + pptNode + ' = ' + ctx.values.pptMainInstance + '.addSlide(' + master + ');')\n            _ ctx.w('const ' + pptNode + '_debug = { items: [] };')\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                @ noindent\n                a_cb()\n                    _ ctx.w(ctx.values.pptMainInstance + '_debug.slides.push(' + pptNode + '_debug);')\n                    _ ctx.values.pptStack.pop()\n                    r_cb()\n        +\n        objectNode.js( number )\n            $append close\n                _ ctx.w(pptParent + '.number = ' + pptNode + ';')\n\n        objectNode.js( p, true )   \n            _ ctx.w('const ' + pptNode + '_text = \"' + respace(model.wzName) + '\";')\n            $append close\n                if model.wzParent.wzElement == 'slide'\n                    _ ctx.w(pptNode + '.isTextBox = true;')\n                    _ ctx.w(pptParent + '.addText(' + pptNode + '_text, ' + pptNode + ');')\n                elif model.wzParent.wzElement == 'pStack'\n                    _ ctx.w(pptParent + '_items.push({ text: ' + pptNode + '_text, options: ' + pptNode + ' });')\n                else\n                    _ ctx.w(pptParent + '.content = { text: ' + pptNode + '_text, options: ' + pptNode + ' };')\n                $if wzConfigIsDevelopment\n                    if model.wzParent.wzElement == 'slide'\n                        _ ctx.w(pptParent + '_debug.items.push({ text: ' + pptNode + '_text, options: ' + pptNode + ' });')\n\n        arrayNode.js( pStack ) \n            _ ctx.w('const ' + pptNode + '_items = [];')\n            $append close\n                if model.wzParent.wzElement == 'slide'\n                    _ ctx.w(pptNode + '.isTextBox = true;')\n                    _ ctx.w(pptParent + '.addText(' + pptNode + '_items, ' + pptNode + ');')\n                else\n                    _ ctx.w(pptParent + '.content = { text: ' + pptNode + '_items, options: ' + pptNode + ' };')\n                $if wzConfigIsDevelopment\n                    if model.wzParent.wzElement == 'slide'\n                        _ ctx.w(pptParent + '_debug.items.push({ pStack: ' + pptNode + '_items, options: ' + pptNode + ' });')\n\n\n        objectNode.js( image )\n            if verify.isEmpty(model.wzName) == false\n                _ ctx.w(pptNode + '.path = \"' + model.wzName + '\";')\n            $append close\n                if model.wzParent.wzElement == 'slide'\n                    _ ctx.w(pptParent + '.addImage(' + pptNode + ');')\n                else\n                    throw new Error(\"Image not child of slide not managed\")\n                $if wzConfigIsDevelopment\n                    if model.wzParent.wzElement == 'slide'\n                        _ ctx.w(pptParent + '_debug.items.push({ image: ' + pptNode + ' });')\n\n        objectNode.js( shape )\n            $append close\n                if model.wzParent.wzElement == 'slide'\n                    _ ctx.w(pptParent + '.addShape(' + ctx.values.pptMainInstance + '.shapes.' + model.wzName + ', ' + pptNode + ');')\n                else\n                    throw new Error(\"Image not child of slide not managed\")\n                $if wzConfigIsDevelopment\n                    if model.wzParent.wzElement == 'slide'\n                        _ ctx.w(pptParent + '_debug.items.push({ shape_' + model.wzName + ': ' + pptNode + ' });')\n\n        objectNode.js( link )\n            $append close\n                _ ctx.w(pptParent + '.hyperlink = ' + pptNode + ';')\n\n        objectNode.js( border )\n            $append close\n                _ ctx.w(pptParent + '.border = ' + pptNode + ';')\n\n        objectNode.js( fill )\n            $append close\n                _ ctx.w(pptParent + '.fill = ' + pptNode + ';')\n\n        objectNode.js( bulletObj )\n            $append close\n                _ ctx.w(pptParent + '.bullet = ' + pptNode + ';')\n\n        $foreach item in ['top','right','bottom','left']\n            objectNode.js( ${item} )\n                $append close\n                    if model.wzName == 'null'\n                        _ ctx.w(pptParent + '.${item} = null;')\n                    else\n                        _ ctx.w(pptParent + '.${item} = ' + pptNode + ';')\n\n        objectNode.js( sizing )\n            $append close\n                _ ctx.w(pptParent + '.sizing = ' + pptNode + ';')\n\n        objectNode.js( line )\n            $append close\n                _ ctx.w(pptParent + '.line = ' + pptNode + ';')\n\n        objectNode.js( shadow )\n            $append close\n                _ ctx.w(pptParent + '.shadow = ' + pptNode + ';')\n\n        async-md( imageDef )\n            if ctx.values.mainObjectCreated == false\n                _ ctx.w('const ' + ctx.values.pptMainObject + ' = new ppt.Document(' + ctx.values.pptMainInternalObject + ');')\n                set ctx.values.mainObjectCreated = true\n            _ ctx.w('const ' + model.wzName + ' = ppt.Media.addImage(')\n            # _ ctx.w('  ' + ctx.values.pptMainObject + ', 300, 300,')\n            _ ctx.w('  ' + ctx.values.pptMainObject + ',')\n            _ ctx.w('  fs.readFileSync(\"' + verify.replaceAll(model.src, '\\\\', '\\\\\\\\') + '\")')\n            _ ctx.w(');')\n            r_cb()\n\n        async-md( imageRef )\n            var pptParent = ctx.values.pptStack[ctx.values.pptStack.length-1]\n            _ ctx.w(pptParent + '.children.push(' + model.wzName + ');')\n            r_cb()\n\n        +\n        headings( 1 )\n        headings( 2 )\n        headings( 3 )\n        headings( 4 )\n        headings( 5 )\n        headings( 6 )\n\n        textNode.js( text )\n        \n        textNode.js( bold )\n            _ ctx.w(pptNode + '.bold = true;')\n        textNode.js( italic ) \n            _ ctx.w(pptNode + '.italic = true;')\n        textNode.js( underline ) \n            _ ctx.w(pptNode + '.underline = true;')\n        \n        async-md( style )\n            var pptParent = ctx.values.pptStack[ctx.values.pptStack.length-1].node\n            _ ctx.w(pptParent + ' = Object.assign({},' + pptParent + ', (styles[\"' + model.wzName + '\"] || {}));')\n            r_cb()\n\n        nodeProperty.js( before, before )\n        nodeProperty.js( after, after )\n        nodeProperty.js( space, space )\n        nodeProperty.js( margin, margin, array )\n        nodeProperty.js( columnGap, columnGap )\n        nodeProperty.js( x, x, num|perc )\n        nodeProperty.js( y, y, num|perc )\n        nodeProperty.js( pt, pt )\n        nodeProperty.js( pageOrientation, pageOrientation, string )\n        nodeProperty.js( pageSize, pageSize, string )\n        nodeProperty.js( pageMargins, pageMargins, array )\n        nodeProperty.js( boldProp, bold, true )\n        nodeProperty.js( italicProp, italic, true )\n        nodeProperty.js( underlineProp, underline, true )\n        nodeProperty.js( font, fontFace, string )\n        nodeProperty.js( xbreak, breakLine, true )\n        nodeProperty.js( xname, name, string )\n        nodeProperty.js( href, url, string )\n        nodeProperty.js( background, bkgd, string )\n        nodeProperty.js( alignment, align, string )\n        nodeProperty.js( valignment, valign, string )\n        nodeProperty.js( charSpace, characterSpace, string )\n        nodeProperty.js( charCode, characterCode, string )\n        nodeProperty.js( slideHref, slide, string )\n        \n        $foreach item in ['width','height','fontSize','size','indent','indentLevel','rotate','rounding','colspan',\n            \\ 'rowspan','opacity','blur','angle','offset']\n            nodeProperty.js( ${item}, ${item} )\n        # nodeProperty.js( fontSize, fontSize )\n        # ...\n\n        $foreach item in ['noWrap','subScript','smallCaps','emphasisMark','strike',\n            \\ 'doubleStrike','superScript','allCaps','bullet','flipH','flipV']\n            nodeProperty.js( ${item}, ${item}, true )\n        # nodeProperty.js( noWrap, noWrap, true )\n        # ...\n\n        $foreach item in ['bkgd','color','highlight','value','layout','align','valign',\n            \\ 'path','characterCode','characterSpace','dashType','beginArrowType',\n            \\ 'endArrowType','code']\n            nodeProperty.js( ${item}, ${item}, string )\n        # nodeProperty.js( bkgd, bkgd, string )\n        # ...\n        \n        nodePropertyChoice.js( xtype)\n            if model.wzParent.wzElement == 'xxx'\n                _ ctx.w(pptParent + '.type = ppt.Xxx.' + model.wzName + ';')\n            else\n                _ ctx.w(pptParent + '.type = \"' + model.wzName + '\";')\n        \n        nodePropertyChoice.js( w )\n            if model.wzParent.wzElement == 'colW'\n                _ ctx.w(pptParent + '.push(' + numOrPerc(model.wzName) + ');')\n            else\n                _ ctx.w(pptParent + '.w =' +  numOrPerc(model.wzName) + ';')\n\n        nodePropertyChoice.js( h )\n            if model.wzParent.wzElement == 'rowH'\n                _ ctx.w(pptParent + '.push(' + numOrPerc(model.wzName) + ');')\n            else\n                _ ctx.w(pptParent + '.h =' +  numOrPerc(model.wzName) + ';')\n\n        nodePropertyChoice.js( title )\n            if model.wzParent.wzElement == 'link'\n                _ ctx.w(pptParent + '.tooltip = \"' + model.wzName + '\";')\n            else\n                _ ctx.w(pptParent + '.type = \"' + model.wzName + '\";')\n\n        +\n        async-md( shading )\n\n            pptNode.js( shd )\n            _ ctx.w('const ' + pptNode + ' = {};')\n        \n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                @ noindent\n                a_cb()\n                    _ ctx.w(pptParent + '.shading = ' + pptNode + ';')\n                    _ ctx.values.pptStack.pop()\n                    r_cb()\n\n        objectNode.js( table )\n            _ ctx.w(pptNode + '_rows = [];')\n            $append close\n                _ ctx.w(pptParent + '.addTable(' + pptNode + '_rows, ' + pptNode + ');')\n                $if wzConfigIsDevelopment\n                    _ ctx.w(pptParent + '_debug.items.push({ table: ' + pptNode + '_rows, options: ' + pptNode + ' });')\n\n        arrayNode.js( tr )   \n            $append close\n                _ ctx.w(pptParent + '_rows.push(' + pptNode + ');')\n\n        objectNode.js( td )\n            $append close\n                _ ctx.w(pptParent + '.push(' + pptNode + '.content);')\n\n        objectNode.js( underline )   \n            $append close\n                _ ctx.w(pptNode + '.underline = ' + pptNode + ';')\n\n        objectNode.js( styles )\n            $append close\n                _ ctx.w(pptParent + '.styles = ' + pptNode + ';')\n\n        objectNode.js( xdefault )\n            $append close\n                _ ctx.w(pptParent + '.default = ' + pptNode + ';')\n\n        objectNode.js( styleDef )\n            $append close\n                _ ctx.w('styles[\"' + model.wzName + '\"] = ' + pptNode + ';')\n                $if wzConfigIsDevelopment\n                    _ ctx.w(ctx.values.pptMainInstance + '_debug.styles[\"' + model.wzName + '\"] = ' + pptNode + ';')\n\n        objectNode.js( defaultStyleDef )\n            $append close\n                _ ctx.w('defaultStyle.content = ' + pptNode + ';')\n                $if wzConfigIsDevelopment\n                    _ ctx.w(ctx.values.pptMainInstance + '_debug.defaultStyle = ' + pptNode + ';')\n\n        objectNode.js( spacing )\n            $append close\n                _ ctx.w(pptParent + '.spacing = ' + pptNode + ';')\n\n        objectNode.js( border )\n            $append close\n                _ ctx.w(pptParent + '.border = ' + pptNode + ';')\n\n\n        # see nodePropertyChoice.js( w ... h )\n        $foreach item in ['colW','rowH']\n            arrayNode.js( ${item} )\n                $append close\n                    _ ctx.w(pptParent + '.${item} = ' + pptNode + ';')\n\n        objectNode.js( ul )\n            _ ctx.w(pptNode + '.ul = [];')\n            $append close\n                _ ctx.w(pptParent + '[\"' + pptParentArrayName + '\"].push(' + pptNode + ');')\n\n        objectNode.js( ol )\n            _ ctx.w(pptNode + '.ul = [];')\n            $append close\n                _ ctx.w(pptParent + '[\"' + pptParentArrayName + '\"].push(' + pptNode + ');')\n\n        objectNode.js( li )\n            _ ctx.w(pptNode + '.text = [];')\n            $append close\n                _ ctx.w(pptParent + '.children.push(' + pptNode + 'Obj);')\n                _ ctx.w(pptParent + '[\"' + pptParentArrayName + '\"].push(' + pptNode + ');')                \n"
                }
            ],
            "transformations": [
                {
                    "name": "ppt/extended",
                    "schema": "ppt",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ppt\\.wizzi\\lib\\artifacts\\ppt\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: '',\n            name: 'extended',\n            schema: 'ppt',\n            checkSchema: true\n        };\n    v08/lib/artifacts/trans(&md)\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.py",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.py",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.py\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.py/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.py\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.py",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "py"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.py\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.py-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.py\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.py",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "py"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "py",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.py\\.wizzi-override\\lib\\wizzi\\schemas\\py.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema py\n\n    e statement\n\t\t# A statement line node with unlimited depth.\n\t\t# Is the schema base node.\n\t\t# In itself works as a comment line.\n\t\ttag #\n\t\tr statement/s\n\n\te codeline : statement\n\n    e py : statement\n\t\tis-root\n        any codeline/statements\n\n\te param\n\n    e function : statement\n        r param/s\n        any codeline/statements\n\t\n    e return : statement\n\n    $include py/classes"
                }
            ],
            "artifacts": [
                {
                    "name": "py/document",
                    "schema": "py",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.py\\.wizzi-override\\lib\\artifacts\\py\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.py',\n            name: 'document',\n            schema: 'py',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n        $append main\n            _ md.py\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        async-md( py )\n            _ ctx.w('<py>')\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                {\n                    @ indent true\n                a_cb()\n                    _ ctx.w('</py>')\n                    r_cb()\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n"
                },
                {
                    "name": "py/module",
                    "schema": "py",
                    "artifact": "module",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.py\\.wizzi-override\\lib\\artifacts\\py\\module\\gen\\main.js.ittf",
                    "content": "module\r\n    kind es6\r\n    $\r\n        var md = {\r\n            schema: 'py',\r\n            name: 'module',\r\n            checkSchema: true,\r\n            preprocess: false,\r\n            mainStart: true,\r\n            mainFinish: true,\r\n        }\r\n    gen( &md )\r\n        $append imports\r\n            var writers = require('./writers/index')\r\n\r\n        $append main\r\n            \r\n            var item_count = 0\r\n            iife next\r\n                var item = model.statements[item_count++]\r\n                if !item\r\n                    return\r\n                        _ terminate_gen\r\n                            @ model\r\n                            @ ctx\r\n                _ writers.gen\r\n                    @ item\r\n                    @ ctx\r\n                    a_cb()\r\n                        _ next\r\n\r\n        function mainStart\r\n            param model\r\n            param ctx\r\n        \r\n        function mainFinish\r\n            param model\r\n            param ctx"
                }
            ],
            "transformations": [
                {
                    "name": "py/extended",
                    "schema": "py",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.py\\.wizzi-override\\lib\\artifacts\\py\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.py',\n            name: 'extended',\n            schema: 'py',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.raml",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.raml",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.raml\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.raml/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.raml\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.raml",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "raml"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.raml\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.raml-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.raml\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.raml",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "raml"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "raml",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.raml\\.wizzi-override\\lib\\wizzi\\schemas\\raml.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema raml\n\n\t# A schema modeling a RESTful API\n\t# Implementing the RESTful API Modeling Language (RAML) http://raml.org/spec.html\n\t# RAML is a concise, expressive language for describing RESTful APIs.\n\t# Built on broadly used standards such as YAML and JSON, \n\t# RAML is a non-proprietary, vendor-neutral open spec.\n\t#\n\t# NOTE\n\t# Resource Types and Trait Parameters are not implemented in this wizzischema\n\t# because their purpose is a reuse of patterns which is the peculiar\n\t# benefit of using the Wizzi Factory. Use IttfFragments instead.\n\t#\n\t# NOTE ps\n\t# Annotation Types are not yet available in this wizzischema.\n\t# They require an implementation in the WizziModelType artifact generator.\n\t# That is work in progress.\n\n\texport-to json\n\n\trequire parseurl\n\t\tkind module\n\n\te ramlItem\n\t\tis-abstract\n\t\tr annotation/s\n\t\tr comment/s\n\n\te raml : ramlItem\n\t\t# The root Entity of the raml Schema.\n\n\t\tis-root\n\n\t\ta title\n\t\t\t# (Required) The title property is a short plain text description of the RESTful API. \n\t\t\t# The title property's value SHOULD be suitable for use as a title for the contained user documentation.\n\t\t\tis-required\n\t\t\n\t\ta version\n\t\t\t# (Optional) If the RAML API definition is targeted to a specific API version, \n\t\t\t# the API definition MUST contain a version property. \n\t\t\n\t\ta_tag( baseUri, base-uri )\n\t\t\t# (Optional during development; Required after implementation) \n\t\t\t# A RESTful API's resources are defined relative to the API's base URI.\n\t\t\t# The use of the baseUri field is OPTIONAL to allow describing APIs that have not yet been implemented.\n\t\t\t# May contain a template URI. A template URI refers to a URI parameter, which is a variable element, \n\t\t\t# enclosed in curly brackets ({}) inside a relative URI of a resource.\n\t\t\t#\n\t\t\t# Example\n\t\t\t#\n\t\t\t# raml\n\t\t\t#     ...\n\t\t\t#     base-uri https://{bucketName}.s3.amazonaws.com\n\t\t\t#     ...\n\t\t\t#     base-uri-parameter bucketName:\n\t\t\t#         description The name of the bucket\n\t\t\n\t\ta protocols\n\t\t\t# (Optional) A RESTful API can be reached HTTP, HTTPS, or both. \n\t\t\t# The protocols property MAY be used to specify the protocols that an API supports. \n\t\t\t# If the protocols property is not specified, the protocol specified at the baseUri property is used. \n\t\t\t# The protocols property MUST be an array of strings, of values \"HTTP\" and/or \"HTTPS\".\n\t\t\tdefault none\n\t\t\trestrict\n\t\t\t\tenum none\n\t\t\t\tenum http\n\t\t\t\tenum https\n\t\t\t\tenum http,https\n\n\t\ta port\n\t\t\ttype integer\n\t\t\tdefault 10011\n\n\t\tr baseUriParameter/s\n\t\t\n\t\tr mediaTypes\n\t\t\tone-to-one\n\t\t\n\t\tr schema\n\t\t\tone-to-one\n\t\t\n\t\tr resource/s\n\t\t\n\t\tm wzinitialize\n\n\t\t\tset this.parameters\n\t\t\t\t[\n\t\t\tforeach item in this.baseUriParameters\n\t\t\t\tset item.in = 'uri'\n\t\t\t\t_ this.parameters.push(item)\n\n\t\tm getMediaTypes\n\t\t\tvar ret = []\n\t\t\tif isObject(this.mediaTypes)\n\t\t\t\tforeach item in this.mediaTypes.mediaTypes\n\t\t\t\t\t_ ret.push(item)\n\t\t\treturn ret\n\t\t\n\t\tm getComments\n\t\t\treturn initComments(this.comments)\n\n\t\tm getResources\n\t\t\tvar resCtx\n\t\t\t\t{\n\t\t\t\t\t@ paths\n\t\t\t\t\t\t[\n\t\t\t\t\t@ resources\n\t\t\t\t\t\t[\n\t\t\tforeach r in this.resources\n\t\t\t\t_ r.getData(resCtx)\n\t\t\treturn resCtx.resources\n\n\te comment\n\t\t# A comment line for describing items.\n\t\ttag #\n\t\tr comment/s\n\n\te annotation\n\t\t# Annotations provide a mechanism to extend the API specification with metadata\n\t\ttag (\n\n\n\t$include raml/parameters\n\t$include raml/resource\n\t$include raml/method\n\t$include raml/body\n\t$include raml/mediatypes\n\t$include raml/response\n\n\te security : ramlItem\n\t\t# \n\t\t\n\t\ta description\n\t\t\t# The description attribute MAY be used to describe a securitySchemes property.\n\n\t\ta type\n\t\t\t# The type attribute MAY be used to convey information about authentication flows and mechanisms to processing applications such as Documentation Generators and Client generators. Processing applications SHOULD provide handling for the following schemes:\n\t\t\tdefault none\n\n\t\t\trestrict\n\t\t\t\tenum none\n\t\t\t\tenum OAuth.1.0\n\t\t\t\t\t# The API's authentication requires using OAuth 1.0 as described in RFC5849 [RFC5849]\n\t\t\t\tenum OAuth.2.0\n\t\t\t\t\t# The API's authentication requires using OAuth 2.0 as described in RFC6749 [RFC6749]\n\t\t\t\tenum Basic\n\t\t\t\t\t# The API's authentication relies on using Basic Access Authentication as described in RFC2617 [RFC2617]\n\t\t\t\tenum Digest\n\t\t\t\t\t# The API's authentication relies on using Digest Access Authentication as described in RFC2617 [RFC2617]\n\t\t\t\tenum x-{other}\n\t\t\t\t\t# The API's authentication relies in another authentication method.\n\n\t\tr setting/s\n\n\te setting : ramlItem\n\t\ta requestTokenUri\n\t\t\t# The URI of the Temporary Credential Request endpoint as defined in RFC5849 Section 2.1\n\t\ta authorizationUri\n\t\t\t# The URI of the Resource Owner Authorization endpoint as defined in RFC5849 Section 2.2\n\t\ta tokenCredentialsUri\n\t\t\t# The URI of the Token Request endpoint as defined in RFC5849 Section 2.3\n\t\ta authorizationUri\n\t\t\t# The URI of the Authorization Endpoint as defined in RFC6749 [RFC6748] Section 3.1\n\t\ta accessTokenUri\n\t\t\t# The URI of the Token Endpoint as defined in RFC6749 [RFC6748] Section 3.2\n\t\ta authorizationGrants\n\t\t\t# A list of the Authorization grants supported by the API As defined in RFC6749 [RFC6749] Sections 4.1, 4.2, 4.3 and 4.4, can be any of: code, token, owner or credentials.\n\t\ta scopes\n\t\t\t# A list of scopes supported by the API as defined in RFC6749 [RFC6749] Section 3.3\n\n\t$include raml/types\n\t$include raml/example\n\t$include init_comments\n\n    m isObject\n        param value\n        return typeof value === 'object' && value !== null && !Array.isArray(value)"
                }
            ],
            "artifacts": [
                {
                    "name": "raml/document",
                    "schema": "raml",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.raml\\.wizzi-override\\lib\\artifacts\\raml\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.raml',\n            name: 'document',\n            schema: 'raml',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n        $append main\n            _ md.raml\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        async-md( raml )\n            _ ctx.w('<raml>')\n            _ md.genItems\n                @ model.items\n                @ ctx\n                {\n                    @ indent true\n                a_cb()\n                    _ ctx.w('</raml>')\n                    r_cb()\n"
                },
                {
                    "name": "raml/html_docs",
                    "schema": "raml",
                    "artifact": "html_docs",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.raml\\.wizzi-override\\lib\\artifacts\\raml\\html_docs\\gen\\main.js.ittf",
                    "content": "module\r\n\tkind jsfile\r\n\r\n\tvar util = require('util')\r\n\tvar path = require('path')\r\n\tvar wizzi = require('wizzi')\r\n\r\n\tvar md = module.exports = {}\r\n\tvar myname = 'raml.html.docs.main'\r\n\r\n\tset md.gen\r\n\t\tfunction\r\n\t\t\tparam model\r\n\t\t\tparam ctx\r\n\t\t\tparam callback\r\n\r\n\t\t\t_ wizzi.fsFactory\r\n\t\t\t\t{\r\n\t\t\t\t\t{ plugins\r\n\t\t\t\t\t\t[ items\r\n\t\t\t\t\t\t\t@ 'wizzi-core'\r\n\t\t\t\t\t\t\t@ 'wizzi-web'\r\n\t\t\t\ta_cb( wf )\r\n\t\t\t\t\t_ wf.loadModelAndGenerateArtifact\r\n\t\t\t\t\t\t_ path.join\r\n\t\t\t\t\t\t\t@ __dirname\r\n\t\t\t\t\t\t\t@ 'ittf'\r\n\t\t\t\t\t\t\t@ 'raml-docs.html.ittf'\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t{ modelRequestContext\r\n\t\t\t\t\t\t\t\t@ raml model\r\n\t\t\t\t\t\t\t@ artifactRequestContext {}\r\n\t\t\t\t\t\t@ 'html/document'\r\n\t\t\t\t\t\ta_cb( artifactText )\r\n\t\t\t\t\t\t\t# loog 'raml.html_docs.artifactText', artifactText\r\n\t\t\t\t\t\t\t_ ctx.w(artifactText)\r\n\t\t\t\t\t\t\tr_cb( ctx )\r\n"
                },
                {
                    "name": "raml/js_client",
                    "schema": "raml",
                    "artifact": "js_client",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.raml\\.wizzi-override\\lib\\artifacts\\raml\\js_client\\gen\\main.js.ittf",
                    "content": "module\r\n\tkind jsfile\r\n\r\n\tvar util = require('util')\r\n\tvar path = require('path')\r\n\tvar wizzi = require('wizzi')\r\n\r\n\tvar md = module.exports = {}\r\n\tvar myname = 'raml.js.client.main'\r\n\r\n\tset md.gen\r\n\t\tfunction\r\n\t\t\tparam model\r\n\t\t\tparam ctx\r\n\t\t\tparam callback\r\n\r\n\t\t\t_ wizzi.fsFactory\r\n\t\t\t\t{\r\n\t\t\t\t\t{ plugins\r\n\t\t\t\t\t\t[ items\r\n\t\t\t\t\t\t\t@ 'wizzi-core'\r\n\t\t\t\t\t\t\t@ 'wizzi-js'\r\n\t\t\t\ta_cb( wf )\r\n\t\t\t\t\t_ wf.loadModelAndGenerateArtifact\r\n\t\t\t\t\t\t_ path.join\r\n\t\t\t\t\t\t\t@ __dirname\r\n\t\t\t\t\t\t\t@ 'ittf'\r\n\t\t\t\t\t\t\t@ 'js-client.js.ittf'\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t{ modelRequestContext\r\n\t\t\t\t\t\t\t\t@ raml model\r\n\t\t\t\t\t\t\t@ artifactRequestContext {}\r\n\t\t\t\t\t\t@ 'js/module'\r\n\t\t\t\t\t\ta_cb( artifactText )\r\n\t\t\t\t\t\t\t# loog 'raml.js-client.artifactText', artifactText\r\n\t\t\t\t\t\t\t_ ctx.w(artifactText)\r\n\t\t\t\t\t\t\tr_cb( ctx )\r\n\r\n"
                },
                {
                    "name": "raml/nodejs_server",
                    "schema": "raml",
                    "artifact": "nodejs_server",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.raml\\.wizzi-override\\lib\\artifacts\\raml\\nodejs_server\\gen\\main.js.ittf",
                    "content": "module\r\n\tkind jsfile\r\n\r\n\tvar util = require('util')\r\n\tvar path = require('path')\r\n\tvar wizzi = require('wizzi')\r\n\r\n\tvar md = module.exports = {}\r\n\tvar myname = 'raml.nodejs.server.main'\r\n\r\n\tset md.gen\r\n\t\tfunction\r\n\t\t\tparam model\r\n\t\t\tparam ctx\r\n\t\t\tparam callback\r\n\r\n\t\t\tvar ittfDocumentPath = path.join(__dirname, 'ittf', 'nodejs-server.js.ittf')\r\n\r\n\t\t\tvar jsContext\r\n\t\t\t\t{\r\n\t\t\t\t\t@ raml model\r\n\t\t\t\t\t@ request\r\n\t\t\t\t\t\t{\r\n\t\t\t\r\n\t\t\t_ wizzi.jsModule\r\n\t\t\t\t@ ittfDocumentPath\r\n\t\t\t\t@ jsContext\r\n\t\t\t\tfunction\r\n\t\t\t\t\tparam err\r\n\t\t\t\t\tparam result\r\n\t\t\t\t\tif err\r\n\t\t\t\t\t\tthrow new Error(err)\r\n\t\t\t\t\t_ ctx.w(result)\r\n\t\t\t\t\t_ callback(null, ctx)"
                }
            ],
            "transformations": [
                {
                    "name": "raml/extended",
                    "schema": "raml",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.raml\\.wizzi-override\\lib\\artifacts\\raml\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.raml',\n            name: 'extended',\n            schema: 'raml',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n    set functors.namespace\n        function\n            param parent\n            param resultObj\n            set resultObj.ns = parent.wzName\n            log 'functors.namespace'\n            foreach child in parent.items\n                if child.wzElement == \"author\"\n                    set resultObj.ns_author = child.wzName\n                else\n                    _ doitem\n                        @ child\n                        @ resultObj\n            set resultObj.ns = 'global'\n            set resultObj.ns_author = 'global'\n    set functors.getQualified\n        function\n            param ns\n            param name\n            return name.indexOf('.') > -1 ? name : (ns || 'global') + '.' + name\n    $include comment\n    $include contents\n    $include biblio\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.rdbms",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.rdbms/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "rdbms"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.rdbms-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "rdbms"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "rdbms",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms\\.wizzi-override\\lib\\wizzi\\schemas\\rdbms.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema rdbms\n\t\n\t# A schema modeling a relational database\n\n\texport-to json\n\texport-to xml\n\n\trequire ./tableHelper\n\t\tkind module\n\t\tdeclare-var tableHelper\n\n\te rdbms\n\t\t\n\t\t# The root element of the rdbms schema.\n\t\t\n\t\tr table/s\n\t\tr relation/s\n\t\tr validationError/s\n\t\tr comment/s\n\n\t\tm testInfo\n\t\t\tvar ret\n\t\t\t\t{\n\t\t\t\t\t@ tables\n\t\t\t\t\t\t[\n\t\t\tforeach table in this.tables\n\t\t\t\tvar ctx = {}\n\t\t\t\t_ table.testInfo(ctx)\n\t\t\t\t_ ret.tables.push(ctx)\n\t\t\treturn ret\n\n\te rdbmsitem\n\t\tr comment/s\n\n\te comment\n\t\t# A comment line for describing items.\n\t\ttag #\n\n\t$include rdbms/table\n\t$include rdbms/tablecolumn\n\t$include rdbms/index\n\t$include rdbms/validation\n\t$include rdbms/relation\n\t$include rdbms/document\n\t$include rdbms/code\n"
                }
            ],
            "artifacts": [
                {
                    "name": "rdbms/document",
                    "schema": "rdbms",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms\\.wizzi-override\\lib\\artifacts\\rdbms\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.rdbms',\n            name: 'document',\n            schema: 'rdbms',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n        $append main\n            _ md.rdbms\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        async-md( rdbms )\n            _ ctx.w('<rdbms>')\n            _ md.genItems\n                @ model.items\n                @ ctx\n                {\n                    @ indent true\n                a_cb()\n                    _ ctx.w('</rdbms>')\n                    r_cb()\n"
                },
                {
                    "name": "rdbms/html_docs",
                    "schema": "rdbms",
                    "artifact": "html_docs",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms\\.wizzi-override\\lib\\artifacts\\rdbms\\html_docs\\gen\\main.js.ittf",
                    "content": "module\r\n\tkind jsfile\r\n\r\n\tvar util = require('util')\r\n\tvar path = require('path')\r\n\tvar wizzi = require('wizzi')\r\n\r\n\tvar md = module.exports = {}\r\n\tvar myname = 'rdbms.html.docs.main'\r\n\r\n\tset md.gen\r\n\t\tfunction\r\n\t\t\tparam model\r\n\t\t\tparam ctx\r\n\t\t\tparam callback\r\n\r\n\t\t\t_ wizzi.fsFactory\r\n\t\t\t\t{\r\n\t\t\t\t\t{ plugins\r\n\t\t\t\t\t\t[ items\r\n\t\t\t\t\t\t\t@ 'wizzi-core'\r\n\t\t\t\t\t\t\t@ 'wizzi-web'\r\n\t\t\t\ta_cb( wf )\r\n\t\t\t\t\t_ wf.loadModelAndGenerateArtifact\r\n\t\t\t\t\t\t_ path.join\r\n\t\t\t\t\t\t\t@ __dirname\r\n\t\t\t\t\t\t\t@ 'ittf'\r\n\t\t\t\t\t\t\t@ 'rdbms-docs.html.ittf'\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t{ modelRequestContext\r\n\t\t\t\t\t\t\t\t@ rdbms model\r\n\t\t\t\t\t\t\t@ artifactRequestContext {}\r\n\t\t\t\t\t\t@ 'html/document'\r\n\t\t\t\t\t\ta_cb( artifactText )\r\n\t\t\t\t\t\t\t_ ctx.w(artifactText)\r\n\t\t\t\t\t\t\tr_cb( ctx )"
                },
                {
                    "name": "rdbms/jsoncrud",
                    "schema": "rdbms",
                    "artifact": "jsoncrud",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms\\.wizzi-override\\lib\\artifacts\\rdbms\\jsoncrud\\gen\\main.js.ittf",
                    "content": "module\r\n\tkind jsfile\r\n\r\n\tvar util = require('util')\r\n\tvar path = require('path')\r\n\tvar wizzi = require('wizzi')\r\n\tvar thisWizziPackage = require('../../../../../index')\r\n\r\n\tvar md = module.exports = {}\r\n\tvar myname = 'rdbms.jsoncrud.main'\r\n\r\n\tset md.gen\r\n\t\tfunction\r\n\t\t\tparam model\r\n\t\t\tparam ctx\r\n\t\t\tparam callback\r\n\r\n\t\t\t_ wizzi.fsFactory\r\n\t\t\t\t{\r\n\t\t\t\t\t{ plugins\r\n\t\t\t\t\t\t[ items\r\n\t\t\t\t\t\t\t@ 'wizzi-core'\r\n\t\t\t\t\t\t\t@ 'wizzi-js'\r\n\t\t\t\ta_cb( wf )\r\n\t\t\t\t\t_ wf.loadModelAndGenerateArtifact\r\n\t\t\t\t\t\t_ path.join\r\n\t\t\t\t\t\t\t@ __dirname\r\n\t\t\t\t\t\t\t@ 'ittf'\r\n\t\t\t\t\t\t\t@ 'jsoncrud.js.ittf'\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t{ modelRequestContext\r\n\t\t\t\t\t\t\t\t@ rdbms model\r\n\t\t\t\t\t\t\t@ artifactRequestContext {}\r\n\t\t\t\t\t\t@ 'js/module'\r\n\t\t\t\t\t\ta_cb( artifactText )\r\n\t\t\t\t\t\t\t# loog 'jsoncrud.artifactText', artifactText\r\n\t\t\t\t\t\t\t_ ctx.w(artifactText)\r\n\t\t\t\t\t\t\tr_cb( ctx )\r\n\r\n"
                },
                {
                    "name": "rdbms/jsonmodel",
                    "schema": "rdbms",
                    "artifact": "jsonmodel",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms\\.wizzi-override\\lib\\artifacts\\rdbms\\jsonmodel\\gen\\main.js.ittf",
                    "content": "module\r\n\tkind jsfile\r\n\r\n\tvar util = require('util')\r\n\tvar path = require('path')\r\n\tvar wizzi = require('wizzi')\r\n\r\n\tvar md = module.exports = {}\r\n\tvar myname = 'rdbms.jsonmodel.main'\r\n\r\n\tset md.gen\r\n\t\tfunction\r\n\t\t\tparam model\r\n\t\t\tparam ctx\r\n\t\t\tparam callback\r\n\r\n\t\t\t$*\r\n\t\t\tvar ittfDocumentPath = path.join(__dirname, 'ittf', 'jsonmodel.js.ittf')\r\n\t\t\t_ wizzi.wizzi.ittf.loadModel\r\n\t\t\t\t@ ittfDocumentPath\r\n\t\t\t\t{\r\n\t\t\t\t\t@ table model.table\r\n\t\t\t\t\t@ request\r\n\t\t\t\t\t\t{\r\n\t\t\t\tfunction\r\n\t\t\t\t\tparam err\r\n\t\t\t\t\tparam result\r\n\t\t\t\t\tif err\r\n\t\t\t\t\t\tthrow new Error(err)\r\n\t\t\t\t\t_ ctx.w(result.toIttf())\r\n\t\t\t\t\t_ callback(null, ctx)\r\n\t\t\t*$\r\n\r\n\t\t\t_ wizzi.fsFactory\r\n\t\t\t\t{\r\n\t\t\t\t\t{ plugins\r\n\t\t\t\t\t\t[ items\r\n\t\t\t\t\t\t\t@ 'wizzi-core'\r\n\t\t\t\t\t\t\t@ 'wizzi-js'\r\n\t\t\t\ta_cb( wf )\r\n\t\t\t\t\t_ wf.loadModelAndGenerateArtifact\r\n\t\t\t\t\t\t_ path.join\r\n\t\t\t\t\t\t\t@ __dirname\r\n\t\t\t\t\t\t\t@ 'ittf'\r\n\t\t\t\t\t\t\t@ 'jsonmodel.js.ittf'\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t{ modelRequestContext\r\n\t\t\t\t\t\t\t\t@ table model.table\r\n\t\t\t\t\t\t\t@ artifactRequestContext {}\r\n\t\t\t\t\t\t@ 'js/module'\r\n\t\t\t\t\t\ta_cb( artifactText )\r\n\t\t\t\t\t\t\t# loog 'jsoncrud.artifactText', artifactText\r\n\t\t\t\t\t\t\t_ ctx.w(artifactText)\r\n\t\t\t\t\t\t\tr_cb( ctx )\r\n\r\n\r\n"
                },
                {
                    "name": "rdbms/jsonmodel_context",
                    "schema": "rdbms",
                    "artifact": "jsonmodel_context",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms\\.wizzi-override\\lib\\artifacts\\rdbms\\jsonmodel_context\\gen\\main.js.ittf",
                    "content": "module\r\n\tkind jsfile\r\n\r\n\tvar util = require('util')\r\n\tvar path = require('path')\r\n\tvar wizzi = require('wizzi')\r\n\r\n\tvar md = module.exports = {}\r\n\tvar myname = 'rdbms.jsonmodel_persister.main'\r\n\r\n\tset md.gen\r\n\t\tfunction\r\n\t\t\tparam model\r\n\t\t\tparam ctx\r\n\t\t\tparam callback\r\n\r\n\t\t\t# log myname, util.inspect(model, {depth:1})\r\n\r\n\t\t\t$*\r\n\t\t\tvar ittfDocumentPath = path.join(__dirname, 'ittf', 'jsonmodel_context.js.ittf')\r\n\t\t\t_ wizzi.wizzi.ittf.loadModel\r\n\t\t\t\t@ ittfDocumentPath\r\n\t\t\t\t{\r\n\t\t\t\t\t@ rdbms model\r\n\t\t\t\t\t@ request\r\n\t\t\t\t\t\t{\r\n\t\t\t\tfunction\r\n\t\t\t\t\tparam err\r\n\t\t\t\t\tparam result\r\n\t\t\t\t\tif err\r\n\t\t\t\t\t\tthrow new Error(err)\r\n\t\t\t\t\t_ ctx.w(result.toIttf())\r\n\t\t\t\t\t_ callback(null, ctx)\r\n\t\t\t\t*$\r\n\r\n\t\t\t_ wizzi.fsFactory\r\n\t\t\t\t{\r\n\t\t\t\t\t{ plugins\r\n\t\t\t\t\t\t[ items\r\n\t\t\t\t\t\t\t@ 'wizzi-core'\r\n\t\t\t\t\t\t\t@ 'wizzi-js'\r\n\t\t\t\ta_cb( wf )\r\n\t\t\t\t\t_ wf.loadModelAndGenerateArtifact\r\n\t\t\t\t\t\t_ path.join\r\n\t\t\t\t\t\t\t@ __dirname\r\n\t\t\t\t\t\t\t@ 'ittf'\r\n\t\t\t\t\t\t\t@ 'jsonmodel_context.js.ittf'\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t{ modelRequestContext\r\n\t\t\t\t\t\t\t\t@ rdbms model\r\n\t\t\t\t\t\t\t@ artifactRequestContext {}\r\n\t\t\t\t\t\t@ 'js/module'\r\n\t\t\t\t\t\ta_cb( artifactText )\r\n\t\t\t\t\t\t\t# loog 'jsoncrud.artifactText', artifactText\r\n\t\t\t\t\t\t\t_ ctx.w(artifactText)\r\n\t\t\t\t\t\t\tr_cb( ctx )\r\n\r\n\r\n\r\n\r\n"
                },
                {
                    "name": "rdbms/jsonmodel_persister",
                    "schema": "rdbms",
                    "artifact": "jsonmodel_persister",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms\\.wizzi-override\\lib\\artifacts\\rdbms\\jsonmodel_persister\\gen\\main.js.ittf",
                    "content": "module\r\n\tkind jsfile\r\n\r\n\tvar util = require('util')\r\n\tvar path = require('path')\r\n\tvar wizzi = require('wizzi')\r\n\r\n\tvar md = module.exports = {}\r\n\tvar myname = 'rdbms.jsonmodel_persister.main'\r\n\r\n\tset md.gen\r\n\t\tfunction\r\n\t\t\tparam model\r\n\t\t\tparam ctx\r\n\t\t\tparam callback\r\n\r\n\t\t\t$*\r\n\t\t\tvar ittfDocumentPath = path.join(__dirname, 'ittf', 'jsonmodel_persister.js.ittf')\r\n\t\t\t_ wizzi.wizzi.ittf.loadModel\r\n\t\t\t\t@ ittfDocumentPath\r\n\t\t\t\t{\r\n\t\t\t\t\t@ table model.table\r\n\t\t\t\t\t@ request\r\n\t\t\t\t\t\t{\r\n\t\t\t\tfunction\r\n\t\t\t\t\tparam err\r\n\t\t\t\t\tparam result\r\n\t\t\t\t\tif err\r\n\t\t\t\t\t\tthrow new Error(err)\r\n\t\t\t\t\t_ ctx.w(result.toIttf())\r\n\t\t\t\t\t_ callback(null, ctx)\r\n\t\t\t*$\r\n\r\n\t\t\t_ wizzi.fsFactory\r\n\t\t\t\t{\r\n\t\t\t\t\t{ plugins\r\n\t\t\t\t\t\t[ items\r\n\t\t\t\t\t\t\t@ 'wizzi-core'\r\n\t\t\t\t\t\t\t@ 'wizzi-js'\r\n\t\t\t\ta_cb( wf )\r\n\t\t\t\t\t_ wf.loadModelAndGenerateArtifact\r\n\t\t\t\t\t\t_ path.join\r\n\t\t\t\t\t\t\t@ __dirname\r\n\t\t\t\t\t\t\t@ 'ittf'\r\n\t\t\t\t\t\t\t@ 'jsonmodel_persister.js.ittf'\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t{ modelRequestContext\r\n\t\t\t\t\t\t\t\t@ table model.table\r\n\t\t\t\t\t\t\t@ artifactRequestContext {}\r\n\t\t\t\t\t\t@ 'js/module'\r\n\t\t\t\t\t\ta_cb( artifactText )\r\n\t\t\t\t\t\t\t# loog 'jsoncrud.artifactText', artifactText\r\n\t\t\t\t\t\t\t_ ctx.w(artifactText)\r\n\t\t\t\t\t\t\tr_cb( ctx )\r\n\r\n\r\n"
                }
            ],
            "transformations": [
                {
                    "name": "rdbms/extended",
                    "schema": "rdbms",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.rdbms\\.wizzi-override\\lib\\artifacts\\rdbms\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.rdbms',\n            name: 'extended',\n            schema: 'rdbms',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n    set functors.namespace\n        function\n            param parent\n            param resultObj\n            set resultObj.ns = parent.wzName\n            log 'functors.namespace'\n            foreach child in parent.items\n                if child.wzElement == \"author\"\n                    set resultObj.ns_author = child.wzName\n                else\n                    _ doitem\n                        @ child\n                        @ resultObj\n            set resultObj.ns = 'global'\n            set resultObj.ns_author = 'global'\n    set functors.getQualified\n        function\n            param ns\n            param name\n            return name.indexOf('.') > -1 ? name : (ns || 'global') + '.' + name\n    $include comment\n    $include contents\n    $include biblio\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.regexp",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.regexp",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.regexp\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.regexp/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.regexp\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.regexp",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "regexp"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.regexp\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.regexp-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.regexp\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.regexp",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "regexp"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "regexp",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.regexp\\.wizzi-override\\lib\\wizzi\\schemas\\regexp.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema regexp\n\n\texport-to json\n\n\te node\n\t\t# A tree node with unlimited depth.\n\t\t# Is the schema base node.\n\t\t# In itself works as a comment line.\n\t\ttag ###\n\t\tr node/s\n\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\tforeach item in this.nodes\n\t\t\t\t_ item.toRegExp(sb)\n\n\t\tm getRegExpString\n\t\t\tvar sb = []\n\t\t\t_ this.toRegExp(sb)\n\t\t\treturn sb.join('')\n\n\te regexp : node\n\t\tis-root\n\n\t\tm wzInitialize\n\t\t\tset this.elements = {}\n\t\t\tset this.executables = {}\n\n\t\tm exec\n\t\t\tparam name\n\t\t\tparam string\n\t\t\tif this.executables[name]\n\t\t\t\t_ this.executables[name].exec(string)\n\t\t\telse\n\t\t\t\tlog 'Executable not found: ', name\n\n\t\tm execTests\n\t\t\tvar results = []\n\t\t\tfor var k in this.executables\n\t\t\t\t# loog 'execTests.executable', k\n\t\t\t\tforeach r in this.executables[k].execTests()\n\t\t\t\t\t_ results.push(r)\n\t\t\treturn results\n\n\te_tag( executableRegExp, re, node )\n\t\ta flags\n\t\t\tdefault gi\n\t\ta_flag( named )\n\n\t\tr test/s\n\n\t\tm wzInitialize\n\t\t\tvar root = this.wzRoot()\n\t\t\tif root.executables[this.wzName]\n\t\t\t\tthrow new Error('Duplicated executableRegExp: ' + this.wzName)\n\t\t\tset root.executables[this.wzName] = this\n\n\t\tm exec\n\t\t\tparam string\n\t\t\tvar re = this.toRegExp()\n\t\t\t# var result = string.match(re)\n\t\t\tvar result = re.exec(string)\n\t\t\treturn result\n\n\t\tm execTests\n\t\t\tvar results = []\n\t\t\tforeach t in this.tests\n\t\t\t\t# loog 'execTests.executableRegExp', t.wzName\n\t\t\t\tvar r = this.exec(t.wzName)\n\t\t\t\t_ results.push\n\t\t\t\t\t{\n\t\t\t\t\t\t@ name this.wzName\n\t\t\t\t\t\t@ regexp this.__regexp\n\t\t\t\t\t\t@ string t.wzName\n\t\t\t\t\t\t@ result\n\t\t\t\t\t\t\tiif this.named\n\t\t\t\t\t\t\t\tthen r.captures\n\t\t\t\t\t\t\t\telse r\n\t\t\t\t\t\t@ expected t.expected\n\t\t\t\t\t\t@ isExpected\n\t\t\t\t\t\t\t_ t.isExpected\n\t\t\t\t\t\t\t\tiif this.named\n\t\t\t\t\t\t\t\t\tthen r.captures\n\t\t\t\t\t\t\t\t\telse r\n\t\t\treturn results\n\n\t\tm toRegExp\n\t\t\tif !this.__regexp\n\t\t\t\tvar sb = []\n\t\t\t\tforeach item in this.nodes\n\t\t\t\t\t_ item.toRegExp(sb)\n\t\t\t\tset this.__regexp = sb.join('')\n\t\t\t#\n\t\t\t\treturn\n\t\t\t\t\tnew RegExp(this.__regexp, this.flags)\n\t\t\t#\n\t\t\tif this.named\n\t\t\t\treturn\n\t\t\t\t\t_ verify.namedRegExp\n\t\t\t\t\t\tnew RegExp(this.__regexp, this.flags)\n\t\t\telse\n\t\t\t\treturn \n\t\t\t\t\t_ verify.getAllRegExp\n\t\t\t\t\t\tnew RegExp(this.__regexp, this.flags)\n\n\te_tag( regexpElement, e, node )\n\t\t# composable element of a regexp\n\n\t\tm wzInitialize\n\t\t\tvar root = this.wzRoot()\n\t\t\tif root.elements[this.wzName]\n\t\t\t\tthrow new Error('Duplicated regexpElement: ' + this.wzName)\n\t\t\tset root.elements[this.wzName] = this\n\n\te test : node\n\t\t\n\n\t\tm wzInitialize\n\t\t\tset this.expected = null\n\t\t\tif this.nodes.length === 1 && this.nodes[0].wzElement === 'expected'\n\t\t\t\tset this.expected = this.nodes[0].toValue()\n\n\t\tm isExpected\n\t\t\tparam results\n\t\t\tif this.expected == null\n\t\t\t\treturn null\n\t\t\tif !results\n\t\t\t\tif this.expected === 'null'\n\t\t\t\t\treturn true\n\t\t\t\telse\n\t\t\t\t\treturn false\n\t\t\tif verify.isArray(this.expected)\n\t\t\t\tif results.length != this.expected.length\n\t\t\t\t\treturn false\n\t\t\t\tfor var i=0; i<results.length; i++\n\t\t\t\t\tif results[i] !== this.expected[i]\n\t\t\t\t\t\treturn false\n\t\t\t\treturn true\n\t\t\telse\n\t\t\t\t# loog 'res', JSON.stringify(results)\n\t\t\t\t# loog 'exp', JSON.stringify(this.expected) \n\t\t\t\treturn JSON.stringify(results) === JSON.stringify(this.expected) \n\n\te expected : node\n\t\ta separator\n\t\t\tdefault ,\n\n\t\tm toValue\n\t\t\t# loog 'expected', this\n\t\t\tif verify.isEmpty(this.wzName)\n\t\t\t\tif this.nodes.length === 0\n\t\t\t\t\treturn null\n\t\t\t\telse\n\t\t\t\t\t# loog 'expected is object'\n\t\t\t\t\treturn this.nodes[0].toValue().value\n\t\t\telse\n\t\t\t\tif this.wzName === 'null'\n\t\t\t\t\treturn this.wzName\n\t\t\t\treturn this.wzName.trim().split(this.separator)\n\n\te_tag( bracket, [, node )\n\t\t# one required group of juxtaposed components\n\t\t# juxtaposed: separated by whitespaces\n\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\tforeach item in this.nodes\n\t\t\t\tif i > 0\n\t\t\t\t\t_ sb.push(' ')\n\t\t\t\t_ item.toRegExp(sb)\n\t\t\n\t\tm toValue\n\t\t\tvar ret \n\t\t\t\t{\n\t\t\t\t\t@ name this.wzName\n\t\t\t\t\t@ value []\n\t\t\tforeach item in this.nodes\n\t\t\t\tvar v = item.toValue()\n\t\t\t\t_ ret.value.push\n\t\t\t\t\t@ v.name + ( v.value ? ' ' + v.value : '' )\n\t\t\treturn ret\n\t\n\te_tag( bracketQuestionMark, [?, node )\n\t\t# one optional group of juxtaposed components\n\t\t# juxtaposed: separated by whitespaces\n\t\n\te_tag( bracketPlus, [+, node )\n\t\t# at least one or many groups of juxtaposed components\n\t\t# juxtaposed: separated by whitespaces\n\n\te_tag( bracketHashmark, [#, node )\n\t\t# zero or many groups of comma separated juxtaposed components\n\t\t# juxtaposed: separated by whitespaces\n\t\n\te_tag( ampersand, &, node )\n\t\t# one required group of joined components\n\t\t# joined: (no juxtaposed) without separators\n\t\n\te_tag( ampersandQuestionmark, [&?, node )\n\t\t# one optional group of joined components\n\t\t# joined: (no juxtaposed) without separators\n\t\n\te_tag( ampersandPlus, [&+, node )\n\t\t# at least one or many groups of joined components\n\t\t# for completness of symbols but has no sense, has the same meaning of `ampersand`\n\t\t# joined: (no juxtaposed) without separators\n\n\te_tag( ampersand, [&#, node )\n\t\t# at least one or many groups of comma separated joined components\n\t\t# joined: (no juxtaposed) without separators\n\n\te_tag( asterix, *, node )\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\t_ nodeToRegExp\n\t\t\t\t@ this\n\t\t\t\t@ sb\n\t\t\t\t@ '*'\n\n\te_tag( plus, +, node )\n\t\t# at least one or many groups of juxtaposed components\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\t_ nodeToRegExp\n\t\t\t\t@ this\n\t\t\t\t@ sb\n\t\t\t\t@ '+'\n\n\te_tag( questionMark, ?, node )\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\tvar s = getReFromName(this)\n\t\t\t_ nodeToRegExp\n\t\t\t\t@ this\n\t\t\t\t@ sb\n\t\t\t\t@ '?'\n\n\te_tag( colon, :, node )\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\tvar s = getReFromName(this)\n\t\t\tif verify.isNotEmpty(s)\n\t\t\t\t_ sb.push(s)\n\t\t\telse\n\t\t\t\t_ sb.push('unknown colon wzName: ' + this.wzName)\n\n\t\tm toValue\n\t\t\tvar v = verify.parseNameValue(this.wzName)\n\t\t\treturn \n\t\t\t\t{\n\t\t\t\t\t@ name v.name()\n\t\t\t\t\t@ value v.value()\n\t\n\te_tag( doubleColon, ::, node )\n\t\n\te_tag( bar, \\|, node )\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\tvar l = this.nodes[0].getRegExpString()\n\t\t\tvar r = this.nodes[1].getRegExpString()\n\t\t\t_ sb.push(enclose(l))\n\t\t\t_ sb.push('|')\n\t\t\t_ sb.push(enclose(r))\n\t\n\te_tag( doubleBar, ||, node )\n\t\n\te_tag( doubleAmpersand, &&, node )\n\n\te_tag( paren, (, node )\n\t\t# (x) - Matches x and remembers the match. These are called capturing groups.\n\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\tvar s = getReFromName(this)\n\t\t\tif verify.isNotEmpty(s)\n\t\t\t\t_ sb.push('(' + s + ')')\n\t\t\telse\n\t\t\t\tset s = getReFromChildren(this)\n\t\t\t\tif verify.isNotEmpty(s)\n\t\t\t\t\t_ sb.push('(' + s + ')')\n\n\te_tag( graph, {, node )\n\t\t# Quantifier\n\t\t# x{n}   - Where n is a positive integer. Matches exactly n occurrences of the preceding item x.\n\t\t# x{n,}\t - Where n is a positive integer. Matches at least n occurrences of the preceding item x.\n\t\t# x{n,m} - Where n and m are positive integers. Matches at least n and at most m occurrences of the preceding item x.\n\t\t\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\tvar s = getReFromChildren(this)\n\t\t\tif verify.isNotEmpty(s)\n\t\t\t\t_ sb.push(s)\n\t\t\t_ sb.push('{' + this.wzName + '}')\n\n\t\tm toValue\n\t\t\tvar ret \n\t\t\t\t{\n\t\t\t\t\t@ name this.wzName\n\t\t\t\t\t@ value {}\n\t\t\tforeach item in this.nodes\n\t\t\t\tvar v = item.toValue()\n\t\t\t\tset ret.value[v.name] = v.value\n\t\t\t# loog 'graph.toValue.ret', ret\n\t\t\treturn ret\n\n\te_tag( parenQuestionMarkEqual, (?=, node )\n\t\t# Assertion\n\t\t# x(?=y) Matches x only if x is followed by y.\n\t\t\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\t_ nodeToRegExp\n\t\t\t\t@ this\n\t\t\t\t@ sb\n\t\t\t\t@ '(?='\n\n\te_tag( parenQuestionMarkExlamationPoint, (?!, node )\n\t\t# Assertion\n\t\t# x(?!y) Matches x only if x is not followed by y.\n\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\t_ nodeToRegExp\n\t\t\t\t@ this\n\t\t\t\t@ sb\n\t\t\t\t@ '(?!'\n\n\te_tag( parenColon, (:, node )\n\t\t# Named captures\n\t\t# x(?!y) Matches x only if x is not followed by y.\n\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\tvar s = getReFromChildren(this)\n\t\t\t_ sb.push\n\t\t\t\t@ '(:' + '<' + this.wzName + '>' + s + ')'\n\n\te_tag( bracketCap, [^, node )\n\t\t# A negated or complemented character set\n\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\t_ sb.push('[^')\n\t\t\tif verify.isEmpty(this.wzName) === false\n\t\t\t\t_ sb.push(this.wzName)\n\t\t\telse\n\t\t\t\tforeach item in this.nodes\n\t\t\t\t\t_ item.toRegExp(sb)\n\t\t\t_ sb.push(']')\n\t\t\n\te_tag( capDollar, ^$, node )\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\t_ sb.push('^')\n\t\t\tvar s = getReFromName(this)\n\t\t\tif verify.isNotEmpty(s)\n\t\t\t\t_ sb.push(s)\n\t\t\telse\n\t\t\t\tforeach item in this.nodes\n\t\t\t\t\t_ item.toRegExp(sb)\n\t\t\t_ sb.push('$')\n\n\te blank : node\n\t\tm toRegExp\n\t\t\tparam sb\n\t\t\tvar num = verify.isNumber(this.wzName) ? verify.convert(this.wzName, 'integer') : 1\n\t\t\t_ sb.push(new Array(num + 1).join(' '))\n\n\tdeclare\n\t\tvar builtInElements\n\t\t\t{\n\t\t\t\t@ space '\\\\s'\n\t\t\t\t@ 'not-space' '\\\\S'\n\t\t\t\t@ word '\\\\w'\n\t\t\t\t@ 'not-word' '\\\\W'\n\t\t\t\t@ digit '\\\\d'\n\t\t\t\t@ 'not-digit' '\\\\D'\n\t\t\t\t@ 'word-boundary' '\\\\b'\n\t\t\t\t@ 'not-word-boundary' '\\\\B'\n\t\t\t\t@ tab '\\\\t'\n\t\t\t\t@ crlf '\\\\r\\\\f'\n\t\t\t\t@ 'carriage-return' '\\\\r'\n\t\t\t\t@ 'form-feed' '\\\\f'\n\t\n\tm escape\n\t\tparam text\n\t\treturn verify.escapeRegExp(text)\n\t\t\n\tm getElement\n\t\tparam root\n\t\tparam wzName\n\t\tif verify.isEmpty(wzName)\n\t\t\treturn null\n\t\tvar re = /\\<(\\w+\\-?\\w+)\\>/g;\n\t\tvar match = re.exec(wzName);\n\t\t# loog 'match', re, wzName, match\n\t\tif match != null\n\t\t\tvar elName = match[1]\n\t\t\tif builtInElements[elName]\n\t\t\t\treturn\n\t\t\t\t\t[\n\t\t\t\t\t\t@ match[0]\n\t\t\t\t\t\t@ builtInElements[elName]\n\t\t\t\t\t\t@ 'builtIn'\n\t\t\tvar el = root.elements[elName]\n\t\t\t# loog 'getElement', elName, el.wzTag, el.wzName\n\t\t\treturn\n\t\t\t\t[\n\t\t\t\t\t@ match[0]\n\t\t\t\t\t@ el\n\t\telse\n\t\t\t# loog 'getElement not found: ' + wzName\n\t\t\treturn null\n\n\tm getReFromName\n\t\tparam node\n\t\tvar s = node.wzName\n\t\tif verify.isEmpty(s)\n\t\t\treturn null\n\t\tif s.indexOf('<') < 0 && s.indexOf('-') > -1 && s.length === 3\n\t\t\treturn '[' + escape(s) + ']'\n\t\telse\n\t\t\tvar el = getElement(node.wzRoot(), s)\n\t\t\tif el === null\n\t\t\t\treturn escape(s)\n\t\t\telse\n\t\t\t\tif el.length > 2 && el[2] === 'builtIn'\n\t\t\t\t\treturn \n\t\t\t\t\t\t_ verify.replaceAll\n\t\t\t\t\t\t\t@ s\n\t\t\t\t\t\t\t@ el[0]\n\t\t\t\t\t\t\t@ el[1]\n\t\t\t\telse\n\t\t\t\t\tvar sb = []\n\t\t\t\t\t_ el[1].toRegExp(sb)\n\t\t\t\t\treturn\n\t\t\t\t\t\t_ verify.replaceAll\n\t\t\t\t\t\t\t@ s\n\t\t\t\t\t\t\t@ el[0]\n\t\t\t\t\t\t\t_ sb.join('')\n\tm getReFromChildren\n\t\tparam node\n\t\tvar sb = []\n\t\tforeach item in node.nodes\n\t\t\t_ item.toRegExp(sb)\n\t\treturn sb.join('')\n\n\tm nodeToRegExp\n\t\tparam node\n\t\tparam sb\n\t\tparam tag\n\t\tvar s = getReFromName(node)\n\t\tif verify.isNotEmpty(s)\n\t\t\tif tag[0] === '('\n\t\t\t\t_ sb.push(tag + s + ')')\n\t\t\telse\n\t\t\t\t_ sb.push(enclose(s) + tag)\n\t\telse\n\t\t\tset s = getReFromChildren(node)\n\t\t\tif verify.isNotEmpty(s)\n\t\t\t\tif tag[0] === '('\n\t\t\t\t\t_ sb.push(tag + s + ')')\n\t\t\t\telse\n\t\t\t\t\t_ sb.push(enclose(s) + tag)\n\n\tm enclose\n\t\tparam s\n\t\tif numchars(s) < 2 ||\n\t\t\t\\b (s[0] === '(' && s.substr(-1) === ')') ||\n\t\t\t\\b (s[0] === '[' && s.substr(-1) === ']') ||\n\t\t\t\\b (s[0] === '^' && s.substr(-1) === '$')\n\t\t\treturn s\n\t\telse\n\t\t\tif s.indexOf('[') > -1 && s.indexOf(']') > -1\n\t\t\t\treturn '(?:' + s + ')'\n\t\t\telse\n\t\t\t\treturn '[' + s + ']'\n\t\n\tm numchars\n\t\tparam s\n\t\tif verify.isEmpty(s)\n\t\t\treturn 0\n\t\tvar count = 0\n\t\tfor var i=0; i<s.length; i++\n\t\t\tif s[i] != '\\\\'\n\t\t\t\tset count++\n\t\treturn count\n"
                }
            ],
            "artifacts": [
                {
                    "name": "regexp/document",
                    "schema": "regexp",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.regexp\\.wizzi-override\\lib\\artifacts\\regexp\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.regexp',\n            name: 'document',\n            schema: 'regexp',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n        $append main\n            _ md.regexp\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        async-md( regexp )\n            _ ctx.w('<regexp>')\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                {\n                    @ indent true\n                a_cb()\n                    _ ctx.w('</regexp>')\n                    r_cb()\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n"
                }
            ],
            "transformations": [
                {
                    "name": "regexp/extended",
                    "schema": "regexp",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.regexp\\.wizzi-override\\lib\\artifacts\\regexp\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.regexp',\n            name: 'extended',\n            schema: 'regexp',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.svg",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.svg",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.svg\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.svg/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.svg\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.svg",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "svg"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.svg\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.svg-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.svg\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.svg",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "svg"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "svg",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.svg\\.wizzi-override\\lib\\wizzi\\schemas\\svg.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema svg\r\n\r\n\t# Language schema that targets\r\n\t# the Scalable Vector Graphics (SVG) 1.1 (Second Edition) specification.\r\n\t# It implements a minimal set of elements, but see the genericAttribute and\r\n    # genericElement schema elements for the way to overcome limitations.\r\n\r\n\tmtree-is-preprocessed true\r\n\r\n    # TODO export-to json is for test only\r\n    export-to json\r\n\r\n\t$\r\n\t\t/*\r\n\t\t\tWe use jswizzi to build the value context : 'presentationAttributes' that will\r\n\t\t\tbe referenced below, in the template nodes that define the styles attribute of the\r\n\t\t\tsvg.\r\n\t\t*/\r\n\t\tvar x_presentationAttributes = 'alignment-baseline,baseline-shift,clip,clip-path,clip-rule,' + \r\n\t\t\t'color,color-interpolation,color-interpolation-filters,color-profile,color-rendering,' +\r\n\t\t\t'cursor,direction,display,dominant-baseline,enable-background,/*fill,*/fill-opacity,fill-rule,' +\r\n\t\t\t'filter,flood-color,flood-opacity,font-family,font-size,font-size-adjust,font-stretch,' +\r\n\t\t\t'font-style,font-variant,font-weight,glyph-orientation-horizontal,glyph-orientation-vertical,' +\r\n\t\t\t'image-rendering,kerning,letter-spacing,lighting-color,marker-end,marker-mid,marker-start,' +\r\n\t\t\t'mask,/*opacity,*/overflow,pointer-events,shape-rendering,stop-color,stop-opacity,/*stroke,*/'+ \r\n\t\t\t'stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,' +\r\n\t\t\t'stroke-opacity,stroke-width,text-anchor,text-decoration,text-rendering,unicode-bidi,' +\r\n\t\t\t'visibility,word-spacing,writing-mode';\r\n\t\tvar a_presentationAttributes = x_presentationAttributes.split(',');\r\n\t\tvar presentationAttributes = [], len = a_presentationAttributes.length, item, i;\r\n\t\tfor (i=0; i<len; i++) {\r\n\t\t\titem = a_presentationAttributes[i];\r\n\t\t\tpresentationAttributes.push({ name: _.dashToCamelCase(item), tag: item });\r\n\t\t}\r\n\t\r\n\tdeclare\r\n\t\tvar styles\r\n\t\t\t[\r\n\t\t\t\t$foreach pa in presentationAttributes\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t@ name '${pa.name}'\r\n\t\t\t\t\t\t@ tag '${pa.tag}'\r\n\r\n\te comment\r\n\t\ttag #\r\n\t\tr comment/s\r\n\t\r\n\te element\r\n\t\t# attributes common to all svg elements\r\n\t\ta id\r\n\t\ta href\r\n\t\ta rotate\r\n        a class\r\n        a_tag( dataName, data-name\r\n        a transform\r\n\t\ta xmlns\r\n        a xmlns:*\r\n\t\ta_tag( xmlBase, xml:base\r\n\t\ta_tag( xmlLang, xml:lang\r\n\t\ta_tag( xmlSpace, xml:space\r\n\t\ta_tag(pathLength, path-length)\r\n\t\t\t# This attribute lets specify the total length for the path, in user units.\r\n\t\t\t# Value type: <number> ; Default value: none; Animatable: yes\r\n        a fill\r\n        a stroke\r\n        a_tag(strokeWidth, stroke-width)\r\n        a opacity\r\n\r\n\t\t$foreach pa in presentationAttributes\r\n\t\t\ta ${pa.name}\r\n\t\t\t\t$if pa.tag !== pa.name\r\n\t\t\t\t\ttag ${pa.tag}\r\n\t\t\r\n\t\tr comment/s\r\n\t\tr attribute/s\r\n\t\tr element/s\r\n\r\n\t\tsvg/getAttrs( \r\n\t\t\t\\b id;class;dataName;href;rotate;transform;xmlns;xmlBase;xmlLang;xmlSpace;pathLength;\r\n            \\ fill;stroke;strokeWidth;opacity\r\n\t\t\t\\b )\r\n\r\n\t\tm getStyleAttributes\r\n\t\t\tvar ret = []\r\n\t\t\tforeach style in styles\r\n\t\t\t\tif typeof(this[style.name]) !== 'undefined' && this[style.name] != null\r\n\t\t\t\t\t_ ret.push\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t@ name style.name\r\n\t\t\t\t\t\t\t@ tag style.tag\r\n\t\t\t\t\t\t\t@ value this[style.name]\r\n\t\t\treturn ret\r\n\r\n\te attribute\r\n\t\t# Used for Svg element attributes not declared in this schema.\r\n\t\t# The wzName must contain a name-value pair separated by a blank (value is optional).\r\n\t\t# Name is the attribute name and value, if not empty, is the attribute value.\r\n\r\n\t\ttag @\r\n\t\r\n\te rect : element\r\n\r\n\t\ta x\r\n\t\t\t# This attribute determines the x coordinate of the rect.\r\n\t\t\t# Value type: <length>|<percentage> ; Default value: 0; Animatable: yes\r\n\t\ta y\r\n\t\t\t# This attribute determines the y coordinate of the rect.\r\n\t\t\t# Value type: <length>|<percentage> ; Default value: 0; Animatable: yes\r\n\t\ta width\r\n\t\t\t# This attribute determines the width of the rect.\r\n\t\t\t# Value type: auto|<length>|<percentage> ; Default value: auto; Animatable: yes\r\n\t\ta height\r\n\t\t\t# This attribute determines the height of the rect.\r\n\t\t\t# Value type: auto|<length>|<percentage> ; Default value: auto; Animatable: yes\r\n\t\ta rx\r\n\t\t\t# This attribute determines the horizontal corner radius of the rect.\r\n\t\t\t# Value type: auto|<length>|<percentage> ; Default value: auto; Animatable: yes\r\n\t\ta ry\r\n\t\t\t# This attribute determines the vertical corner radius of the rect.\r\n\t\t\t# Value type: auto|<length>|<percentage> ; Default value: auto; Animatable: yes\r\n\r\n\t\tsvg/getAttrs( x;y;width;height;rx;ry, element )\r\n\r\n\te svg : rect\r\n\t\tis-root\r\n\t\ta viewBox\r\n            tag viewBox|view-box\r\n\t\t\t# This attribute defines the bound of the SVG viewport for the current SVG fragment.\r\n\t\t\t# Value type: <list-of-numbers> ; Default value: none; Animatable: yes\r\n\t\ta_tag( preserveAspectRatio, preserve-aspect-ratio )\r\n\t\t\t# This attribute defines how the svg fragment must be deformed if it is embedded in a container with a different aspect ratio.\r\n\t\t\t# Value type: (none| xMinYMin| xMidYMin| xMaxYMin| xMinYMid| xMidYMid| xMaxYMid| xMinYMax| xMidYMax| xMaxYMax) (meet|slice)? ; Default value: xMidYMid meet; Animatable: yes\r\n\t\ta version\r\n        a alt\r\n\t\tsvg/getAttrs( width;height;viewBox;preserveAspectRatio;version, element )\r\n\r\n\te line : element\r\n\t\ta x1\r\n\t\ta y1\r\n\t\ta x2\r\n\t\ta y2\r\n\r\n\t\tsvg/getAttrs( x1;y1;x2;y2;, element )\r\n\r\n\te polyline : element\r\n\t\ta points\r\n\t\t\r\n\t\tsvg/getAttrs( points, element )\r\n\r\n\t\r\n\te polygon : element\r\n\t\ta points\r\n\r\n\t\tsvg/getAttrs( points:pathLength, element )\r\n\r\n\te circle : element\r\n\t\ta cx\r\n\t\ta cy\r\n\t\ta r\r\n\r\n\t\tsvg/getAttrs( cx;cy;r, element )\r\n\r\n\te ellipse : element\r\n\t\ta cx\r\n\t\ta cy\r\n\t\ta rx\r\n\t\ta ry\r\n\r\n\t\tsvg/getAttrs( cx;cy;rx;ry, element )\r\n\r\n\te path : element\r\n\t\ta d\r\n\r\n\t\tsvg/getAttrs( d, element )\r\n\r\n\te text : element\r\n\t\ta x\r\n\t\ta y\r\n\t\ta fontFamily\r\n\t\t\ttag font-family\r\n\t\ta fontSize\r\n\t\t\ttag font-size\r\n        a fontWeight\r\n            tag font-weight\r\n        a textAnchor\r\n            tag text-anchor\r\n\t\t\r\n        svg/getAttrs( x;y;fontFamily;fontSize;fontWeight;textAnchor, element )\r\n\r\n\te textPath : element\r\n\r\n\te tspan : element\r\n\t\ta x\r\n\t\ta y\r\n\t\ta dx\r\n\t\ta dy\r\n\r\n\t\tsvg/getAttrs( x;y;dx;dy , element )\r\n\r\n\te a : element\r\n\t\t# link\r\n\t\t# a\r\n\t\t\t# href http://tecfa.unige.ch\r\n\t\t\t# rect\r\n\t\t\t\t# fill #00FF00\r\n\t\t\t\t# stroke #00FF00\r\n\t\t\t\t# width 300\r\n\t\t\t\t# height 40\r\n\t\t\t\t# ry 5\r\n\t\t\t\t# rx 5\r\n\t\t\t\t# y 80\r\n\t\t\t\t# x 50\r\n\t\t\t# text TECFA POWER 1 click away\r\n\t\t\t\t# x 100\r\n\t\t\t\t# y 110\r\n\t\t\t\t# stroke #000099\r\n\t\t\t\t# fill #000099\r\n\t\t\t\t# font-size 24\r\n\t\t$$ svg/getAttrs( transform, element )\r\n\r\n\te g : element\r\n\t\t# grouping\r\n\t\t$$ svg/getAttrs( transform, element )\r\n\r\n\te image : rect\r\n\t\t$$ svg/getAttrs( transform, rect )\r\n\r\n\te title : element\r\n\r\n\te altGlyph : element\r\n\te altGlyphDef : element\r\n\te altGlyphItem : element\r\n\te animate : element\r\n\te animateColor : element\r\n\te animateMotion : element\r\n\te animateTransform : element\r\n\te clipPath : element\r\n\t\t$$ svg/getAttrs( transform, element )\r\n\te color-profile : element\r\n\te cursor : element\r\n\te defs : element\r\n\t\t$$ svg/getAttrs( transform, element )\r\n\te desc : element\r\n\te feBlend : element\r\n\te feColorMatrix : element\r\n\te feComponentTransfer : element\r\n\te feComposite : element\r\n\te feConvolveMatrix : element\r\n\te feDiffuseLighting : element\r\n\te feDisplacementMap : element\r\n\te feDistantLight : element\r\n\te feFlood : element\r\n\te feFuncA : element\r\n\te feFuncB : element\r\n\te feFuncG : element\r\n\te feFuncR : element\r\n\te feGaussianBlur : element\r\n\te feImage : element\r\n\te feMerge : element\r\n\te feMergeNode : element\r\n\te feMorphology : element\r\n\te feOffset : element\r\n\te fePointLight : element\r\n\te feSpecularLighting : element\r\n\te feSpotLight : element\r\n\te feTile : element\r\n\te feTurbulence : element\r\n\te filter : element\r\n\te font : element\r\n\te font-face : element\r\n\te font-face-format : element\r\n\te font-face-name : element\r\n\te font-face-src : element\r\n\te font-face-uri : element\r\n\te foreignObject : element\r\n\t\t$$ svg/getAttrs( transform, element )\r\n\te glyph : element\r\n\te glyphRef : element\r\n\te hkern : element\r\n\te linearGradient : line\r\n        a gradientUnits\r\n\te marker : element\r\n\te mask : element\r\n\te metadata : element\r\n\te missing-glyph : element\r\n\te mpath : element\r\n\te pattern : element\r\n        a progressLines\r\n        $$ a_tag( viewBox, viewBox|view-box )\r\n        a width\r\n        a height\r\n        a patternUnits\r\n        a patternTransform\r\n\te radialGradient : element\r\n        a cx\r\n        a cy\r\n        a r\r\n        a gradientUnits\r\n        a gradientTransform \r\n        svg/getAttrs( cx;cy;r;gradientUnits;gradientTransform, element )\r\n\te script : element\r\n\te set : element\r\n\te stop : element\r\n\t\ta style\r\n\t\ta offset\r\n\t\tsvg/getAttrs( style;offset, element )\r\n\te stroke-width : element\r\n    e style : element\r\n\te switch : element\r\n\t\t$$ svg/getAttrs( transform, element )\r\n\te symbol : element\r\n\te tref : element\r\n\te use : element\r\n\t\t$$ svg/getAttrs( transform, element )\r\n\te view : element\r\n\te vkern : element\r\n\r\n    e jsInclude : element\r\n        tag ::script\r\n        include js module\r\n\r\n\t# TODO this should become function\r\n\tm extractAttributes\r\n\t\tparam element\r\n\t\tparam names_string\r\n\t\tparam attrs\r\n\t\tif !attrs\r\n\t\t\tset attrs = []\r\n\t\tif verify.isNotEmpty(names_string)\r\n\t\t\tvar names = names_string.split(';')\r\n\t\t\tforeach name in names\r\n\t\t\t\tif typeof(element[name]) !== 'undefined' && element != null\r\n\t\t\t\t\t_ attrs.push\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t@ name name\r\n\t\t\t\t\t\t\t@ value element[name]\r\n\t\treturn attrs"
                }
            ],
            "artifacts": [
                {
                    "name": "svg/document",
                    "schema": "svg",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.svg\\.wizzi-override\\lib\\artifacts\\svg\\document\\gen\\main.js.ittf",
                    "content": "module wizzi.plugin.svg.lib.artifacts.svg.document.gen.main\n    kind es6\n    $\n        // isAsync: false is important!!!\n        var md = {\n            plugin: 'wizzi.plugin.svg',\n            name: 'document',\n            schema: 'svg',\n            checkSchema: true,\n            isAsync: false,\n        };\n\n\t# Language artifact that targets\n\t# the Scalable Vector Graphics (SVG) 1.1 (Second Edition) specification.\n\t# It implements a minimal set of elements\n\t#\n\t# This is a code write based artifact generator.\n\t#\n\n    gen( &md )\n        $append imports\n            # gen also has a 'lineparser' function from wizzi-utils\n            var myLineParser = require('../../../utils/lineParser')\n            var included_writers = require('./included_writers')\n        $append main\n            if false\n                # this for md.checkSchema: false\n                # allow generations from non root elements\n                _ md.myGetGenItem\n                    @ ctx\n                    (\n                        @ model\n                        a_cb( )\n                            if ctx.artifactGenerationErrors.length > 0\n                                r_cb_err( ctx.artifactGenerationErrors )\n                            else\n                                # generation OK\n                                r_cb( ctx )\n            else\n                # this for md.checkSchema: true\n                _ md.svg\n                    @ model\n                    @ ctx\n                    a_cb( )\n                        if ctx.artifactGenerationErrors.length > 0\n                            r_cb_err( ctx.artifactGenerationErrors )\n                        else\n                            # generation OK\n                            r_cb( ctx )\n        \n        async-md( svg )\n            if ctx.values.forCssImage || ctx.values.forHtmlSvgElement\n            else\n                _ ctx.w('<?xml version=\"1.0\"?>')\n            _ writeBeginTag\n                @ ctx\n                @ 'svg'\n            _ ctx.write(\" xmlns='http://www.w3.org/2000/svg'\")\n            _ writeAttributes(model, ctx)\n            _ writeCloseBegin\n                @ ctx\n            _ md.myGenItems\n                @ model.elements\n                @ ctx\n                {\n                    @ indent true\n                a_cb( notUsed )\n                    _ writeEndTag\n                        @ ctx\n                        @ 'svg'\n                    _ callback(null, true)\n        \n        async-md( standardElement )\n            # loog '***** standard element', model.wzElement\n            _ writeBeginTag\n                @ ctx\n                @ model.wzTag\n            _ writeAttributes(model, ctx)\n            if model.elements.length > 0\n                _ writeCloseBegin\n                    @ ctx\n                if model.wzName && model.wzName.length > 0\n                    _ ctx.write(model.wzName)\n                _ md.myGenItems\n                    @ model.elements\n                    @ ctx\n                    {\n                        @ indent true\n                    a_cb( notUsed )\n                        _ writeEndTag\n                            @ ctx\n                            @ model.wzTag\n                        return\n                            _ callback\n            else\n                _ ctx.write\n                    @ closeSym(ctx)\n                _ ctx.write\n                    @ (model.wzName && model.wzName.length > 0 ? model.wzName : '')\n                _ writeEndTag\n                    @ ctx\n                    @ model.wzTag\n                return\n                    _ callback\n\n        #\n            async-md( linearGradient )\n                _ writeBeginTag\n                    @ ctx\n                    @ 'linearGradient'\n                _ writeAttributes(model, ctx)\n                _ writeCloseBegin\n                    @ ctx\n                # TODO\n                _ writeEndTag\n                    @ ctx\n                    @ 'linearGradient'\n                    _ callback(null, true)\n\n        set md.myGenItems\n            function\n                param elements\n                param ctx\n                param options\n                param callback\n                var\n                    decl opt = options || {}\n                    decl from = opt.from || 0\n                    decl indent = typeof opt.indent === 'undefined' ? true : opt.indent\n\n                if indent\n                    _ ctx.indent()\n\n                var goelements = []\n                for var i = from; i < elements.length; i++\n                    _ goelements.push(elements[i])\n\n                _ async.mapSeries\n                    @ goelements\n                    _ md.myGetGenItem\n                        @ ctx\n                    a_cb( notUsed )\n                        if indent\n                            _ ctx.deindent()\n                        return\n                            _ callback\n        \n        set md.myGetGenItem\n            function\n                param ctx\n                return\n                    function\n                        param model\n                        param callback\n                        if md[model.wzElement]\n                            # loog '***** known element', model.wzElement\n                            _ md[model.wzElement]\n                                @ model\n                                @ ctx\n                                a_cb( done )\n                                    if done\n                                        # ok, processed\n                                        return\n                                            _ callback\n                                    else\n                                        return\n                                            _ md.standardElement\n                                                @ model\n                                                @ ctx\n                                                @ callback\n                        else\n                            return\n                                _ md.standardElement\n                                    @ model\n                                    @ ctx\n                                    @ callback\n\n        function writeAttributes\n            param model\n            param ctx\n            var v\n            foreach a in model.getAttributes()\n                set v = encodeValue(ctx, a.value)\n                _ ctx.write\n                    @ \" \" + a.name + \"='\" + v + \"'\"\n\n            if model.attributes\n                foreach a in model.attributes\n                    var p = myLineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ ctx.write\n                            @ \" \" + p.name() + \"='\" + p.value() + \"'\"\n                    else\n                        _ ctx.write\n                            @ \" \" + p.name()\n\n            var styles = model.getStyleAttributes()\n            if styles.length > 0\n                var sb = []\n                foreach style in styles\n                    set v = encodeValue(ctx, style.value)\n                    _ sb.push\n                        @ style.tag + ':' + v + ';'\n                _ ctx.write\n                    @ \" style='\" + sb.join('') + \"'\"\n        \n        function encodeValue\n            param ctx\n            param value\n            if ctx.values.forCssImage\n                var v = verify.replaceAll(value, '%','%25') \n                return verify.replaceAll(v, '#','%23') \n            else\n                return value\n\n        function openSym\n            param ctx\n            return ctx.values.forCssImage ? '%3C' : '<'\n\n        function closeSym\n            param ctx\n            return ctx.values.forCssImage ? '%3E' : '>'\n\n        function writeBeginTag\n            param ctx\n            param name\n            _ ctx.write\n                @ openSym(ctx) + name\n\n        function writeCloseBegin\n            param ctx\n            if ctx.values.forCssImage\n                _ ctx.write\n                    @ closeSym(ctx)\n            else\n                _ ctx.w\n                    @ closeSym(ctx)\n\n        function writeEndTag\n            param ctx\n            param name\n            if name\n                _ __w\n                    @ ctx\n                    @ openSym(ctx) + '/' + name + closeSym(ctx)\n            else\n                _ __w\n                    @ ctx\n                    @ '/' + closeSym(ctx)\n\n        function __w\n            param ctx\n            param text\n            if ctx.values.forCssImage\n                _ ctx.write(text)\n            else\n                _ ctx.w(text)\n\n        $include includes\n\n        +\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        +\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        +\n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n\n"
                }
            ],
            "transformations": [
                {
                    "name": "svg/extended",
                    "schema": "svg",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.svg\\.wizzi-override\\lib\\artifacts\\svg\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.svg',\n            name: 'extended',\n            schema: 'svg',\n            checkSchema: true\n        };\n    trans( &md )\n"
                }
            ],
            "wizzifiers": [
                {
                    "name": "svg",
                    "schema": "svg",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.svg\\.wizzi-override\\lib\\wizzifiers\\svg\\wizzifier.js.ittf",
                    "content": "module\n    $\n        var schemaName = 'svg';\n    kind es6\n    basewizzifier()\n        $append imports\n            var xml2js = require('xml2js')\n            var svg_parser = new xml2js.Parser()\n            var cleanAST = require('./cleanAST')\n            +\n            function parseInternal\n                param tobeWizzified\n                param options\n                param callback\n                log 'tobeWizzified', tobeWizzified\n                try\n                    _ svg_parser.parseString\n                         @ tobeWizzified\n                         a_cb( syntax )\n                            log \"syntax\", syntax\n                            r_cb( syntax )\n                catch ex\n                    return\n                        _ callback\n                            @ ex\n            +\n        function camelCaseToDash\n            param str\n            return str.replace( /([a-z])([A-Z])/g, '$1-$2' ).toLowerCase()\n        \n        function cleanName\n            param name\n            return camelCaseToDash(name)\n\n        function cleanAttr\n            param attr\n            var lines = attr.match(/[^\\r\\n]+/g)\n            for var i=0; i<lines.length;i++\n                set lines[i] = lines[i].trim()\n            return lines.join('') \n\n        function appendChilds\n            param name\n            param nodeArray\n            param parent\n            # loog 'appendChilds.name', name\n            foreach node in nodeArray\n                if verify.isString(node)\n                    set parent.name = node\n                else \n                    var ac = getAttribsAndChilds(node)\n                    var tag\n                        { \n                            @ tag cleanName(name)\n                            @ children\n                                [ \n                    _ parent.children.push(tag)\n                    var aObj = ac.a\n                    for var aName in aObj\n                        _ tag.children.push\n                            { \n                                @ tag cleanName(aName)\n                                @ name cleanAttr(aObj[aName])\n                                @ children\n                                    [ \n                    foreach childnode in ac.c\n                        if verify.isArray(childnode.value) === false\n                            log \"Error: value is not an array: \" + childnode.name + ',' + childnode.value\n                        else \n                            _ appendChilds\n                                @ childnode.name\n                                @ childnode.value\n                                @ tag\n        \n        function getAttribsAndChilds\n            param node\n            var attribs\n                { \n            var children\n                [ \n            for var prop in node\n                if node.hasOwnProperty(prop)\n                    if prop === '$'\n                        var attribsObj = node[prop]\n                        # log('getAttribsAndChilds.$', attribsObj, true)\n                        for var k in attribsObj\n                            set attribs[k] = attribsObj[k]\n                    else \n                        var value = node[prop]\n                        var isArray = verify.isArray(value)\n                        _ children.push\n                            { \n                                @ name cleanName(prop)\n                                @ value node[prop]\n            return \n                { \n                    @ a attribs\n                    @ c children   \n\n        function wizzify\n            param tobeWizzified\n            param options\n            param callback\n            var wizziTree\n                { \n                    @ children\n                        [ \n            _ parseInternal\n                @ tobeWizzified\n                @ options\n                a_cb( result )\n                    if options.dumpfile\n                        _ file.write\n                            @ options.dumpfile\n                            _ JSON.stringify(result, null, 2)\n                        \n                    for var prop in result\n                        if result.hasOwnProperty(prop)\n                            var root = result[prop]\n                            if verify.isObject(root) === false\n                                return\n                                    _ callback\n                                        new Error(\"Root is not an object. Prop: \" + prop + ', root: ' + root)\n                            var ac = getAttribsAndChilds(root)\n                            var propx = prop\n                            if prop == 'viewBox'\n                                set propx = prop\n                            set wizziTree =\n                                { \n                                    @ tag propx\n                                    @ attribs\n                                        [ \n                                    @ children\n                                        [ \n                            var aObj = ac.a\n                            for var aName in aObj\n                                _ wizziTree.children.push\n                                    { \n                                        @ tag cleanName(aName)\n                                        @ name cleanAttr(aObj[aName])\n                                        @ children\n                                            [ \n                            for var j = 0; j < ac.c.length; j++\n                                var childnode = ac.c[j]\n                                if verify.isArray(childnode.value) === false\n                                    log \"Error: value is not an array: \" + childnode.name + ',' + childnode.value\n                                else \n                                    _ appendChilds\n                                        @ childnode.name\n                                        @ childnode.value\n                                        @ wizziTree\n                    # log \"wizziTree\", wizziTree\n                    _ callback(null, wizziTree)\n        $include helper_functions\n        +\n        function isKnownType\n            param type\n            return ['Int', 'Float', 'Boolean', 'String'].indexOf(type) > -1\n        +\n        function getTypeName\n            param type\n            return isKnownType(type) ? type.toLowerCase() : type\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.text",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.text",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.text\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.text/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.text\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.text",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "text"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.text\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.text-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.text\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.text",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "text",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.text\\.wizzi\\lib\\wizzi\\schemas\\text.wfschema.ittf",
                    "genConfig": "wizzi.config.js"
                }
            ],
            "artifacts": [
                {
                    "name": "text/document",
                    "schema": "text",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.text\\.wizzi-override\\lib\\artifacts\\text\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.text',\n            name: 'document',\n            schema: 'text',\n            rootElement: '',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n        $append main\n            # loog 'wizzi.plugi.text.lib.artifacts.text.document', model, model.toText\n            if model.toText\n                _ ctx.write\n                    _ model.toText\n            else\n                _ ctx.write\n                    @ model.content\n            r_cb( ctx )"
                }
            ],
            "transformations": [
                {
                    "name": "text/extended",
                    "schema": "text",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.text\\.wizzi-override\\lib\\artifacts\\text\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.text',\n            name: 'extended',\n            schema: 'text',\n            rootElement: '',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ],
            "wizzifiers": [
                {
                    "name": "text",
                    "schema": "text",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.text\\.wizzi-override\\lib\\wizzifiers\\text\\wizzifier.js.ittf",
                    "content": "module\n    $\n        var schemaName = 'text';\n    kind es6\n    basewizzifier()\n        $append imports\n            var text_parser = require('./parser')\n            +\n            function parseInternal\n                param tobeWizzified\n                param options\n                param callback\n                var syntax\n                try\n                    set syntax\n                         _ text_parser.parse\n                            @ tobeWizzified\n                    return\n                        _ callback\n                            @ null\n                            @ syntax\n                catch ex\n                    return\n                        _ callback\n                            @ ex\n        +\n        function wizzify\n            param tobeWizzified\n            param options\n            param callback\n            set options = options || {};\n            set options.input = tobeWizzified\n            set options.stack = []\n            set options.verbose = false\n            _ parseInternal\n                @ tobeWizzified\n                @ options\n                a_cb( syntax )\n                    # log stringify(syntax, null, 2)\n                    var wizziTree\n                        { \n                            @ tag 'text'\n                            @ name ''\n                            [ children\n                    foreach line in syntax\n                        _ wizziTree.children.push\n                            {\n                                @ tag line\n                                @ name ''\n                                [ children\n                    log 'wizziTree', wizziTree\n                    r_cb( wizziTree )\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.ts",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ts",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ts\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.ts/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ts\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ts",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "ts"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ts\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.ts-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ts\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ts",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "ts"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "ts",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ts\\.wizzi-override\\lib\\wizzi\\schemas\\ts.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema ts\n\t\n\t# A schema modeling a typescript module.\n\n\tmtree-is-preprocessed\n\n\te statement\n\t\t# The base element for all code nodes, and\n\t\t# a generic code statement that will be emitted as is.\n\t\t# The indentation will depend to the node depth.\n\t\ttag +\n\t\t\n\t\tr statement/s\n\t\n\te comment : statement\n\t\ttag #\n\n\te_tag( xmodule, module, statement )\n\t\t# The root element of the ts schema.\n\t\tis-root\n\t\t\n\t\tr feature/s\n\n\t\tm wzinitialize\n\t\t\tset this.wzModelState = ctx.modelState = {}\n\n\t\tm hasFeature\n\t\t\tparam name\n\t\t\tforeach f in this.features\n\t\t\t\tif f.wzName === name\n\t\t\t\t\treturn true\n\t\t\treturn false\n\n\te feature\n\t\t# A known feature that this module require.\n\n    e_tag( decorator, @d, statement\n\n\t$include ts/vars\n\t$include ts/expressions\n\t$include ts/statements\n\t$include ts/calls\n\t$include ts/objects\n\t$include ts/functions\n\t$include ts/types\n\t$include ts/classes\n\t$include ts/react\n\t$include ts/html\n\t$include ts/template\n\t$include ts/debug\n\n\t$include ts/typescript\n\n\tdeclare\n        function isDescendentOf\n            param model\n            param ancestor\n            if !model.wzParent\n                return false\n            if model.wzParent.wzElement == ancestor\n                return true\n            return \n                _ isDescendentOf\n                    @ model.wzParent\n                    @ ancestor"
                }
            ],
            "artifacts": [
                {
                    "name": "ts/document",
                    "schema": "ts",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ts\\.wizzi-override\\lib\\artifacts\\ts\\document\\gen\\main.js.ittf",
                    "content": "module wizzi.plugin.ts@${wzCtx.version}.lib.artifacts.ts.module.gen.main\n    kind es6\n    \n    $include versions\n\n    $\n        var md = {\n            plugin: 'wizzi.plugin.ts',\n            name: 'document',\n            schema: 'ts',\n            rootElement: 'xmodule',\n            checkSchema: true,\n            isAsync: true,\n        };\n    \n    gen( &md )\n        $append imports\n            var statement = require('./statement')\n            # old var wzIife = require('./wziife')\n        $append main\n            set ctx.__ecma = 'es6'\n            set ctx.__jskind = 'react'\n\n            _ main_init\n                @ model\n                @ ctx\n\n            repeater(1, model.statements)\n                _ statement.gen\n                    @ item_1\n                    @ ctx\n                    a_cb()\n                        repeater_increment(1)\n                $append next\n                    if ctx.artifactGenerationErrors.length > 0\n                        return\n                            _ callback(ctx.artifactGenerationErrors)\n                    else\n                        r_cb( ctx )\n\n        function main_init\n            param model\n            param ctx\n            \n            # log myname, 'ctx.values', ctx.values\n            if (!!ctx.values.noGeneratorComments) == false\n                _ ctx.w('/*')\n                _ ctx.w('    artifact generator: ' + __filename)\n                _ ctx.w('    package: wizzi.plugin.ts@${versions['wizzi.plugin.ts@next']}')\n                _ ctx.w('    primary source IttfDocument: ' + model.wzSourceFilepath('f1'))\n                $if wzConfigIsPackageDeploy == false\n                    _ ctx.w('    utc time: ' + new Date().toUTCString())\n                _ ctx.w('*/')\n\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        \n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        \n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n"
                }
            ],
            "transformations": [
                {
                    "name": "ts/extended",
                    "schema": "ts",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ts\\.wizzi-override\\lib\\artifacts\\ts\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.ts',\n            name: 'extended',\n            schema: 'ts',\n            rootElement: 'xmodule',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ],
            "wizzifiers": [
                {
                    "name": "ts",
                    "schema": "ts",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.ts\\.wizzi-override\\lib\\wizzifiers\\ts\\wizzifier.js.ittf",
                    "content": "module\n    $\n        var schemaName = 'ts';\n    kind es6\n\n    basewizzifier()\n        $append imports\n            var ts_parser = require('@babel/parser')\n            var cleanAST = require('./cleanAST')\n            var CommentManager = require('../utils/commentManager')\n            +\n            var commonPlugins\n                [\n                    @ 'jsx'\n                    @ \"objectRestSpread\"\n                    @ \"classProperties\"\n                    @ \"doExpressions\"\n                    @ ['decorators', { decoratorsBeforeExport: true }]\n                    @ \"classProperties\"\n                    @ \"classPrivateProperties\"\n                    @ \"classPrivateMethods\"\n                    @ \"exportDefaultFrom\"\n                    @ \"exportNamespaceFrom\"\n                    @ \"asyncGenerators\"\n                    @ \"functionBind\"\n                    @ \"functionSent\"\n                    @ \"dynamicImport\"\n                    @ \"numericSeparator\"\n                    @ \"optionalChaining\"\n                    @ \"importMeta\"\n                    @ \"bigInt\"\n                    @ \"optionalCatchBinding\"\n                    @ \"throwExpressions\"\n                    @ \"nullishCoalescingOperator\"\n            +\n            var csswizzifier = null\n\t        var htmlwizzifier = null\n            $if wzConfigIsDocumentation\n                var wzDocs\n                    {\n                        [ AstgNodes\n\n            $include html_tags\n            +\n            function parseInternal\n                param tobeWizzified\n                param options\n                param callback\n                set options = options || {}\n                var plugins\n                try\n                    if options.ts_or_flow === 'typescript'\n                        set plugins\n                            [\n                                @ 'typescript'\n                                ._ concat\n                                    @ commonPlugins\n                    else\n                        set plugins\n                            [\n                                @ 'flow'\n                                ._ concat\n                                    @ commonPlugins\n                    # loog 'tswizzifier.container.options', options\n                    var syntax\n                        _ ts_parser.parse\n                            @ tobeWizzified\n                            {\n                                @ sourceType 'module'\n                                @ plugins plugins\n                    r_cb( syntax )\n                catch ex\n                    return\n                        _ callback\n                            @ ex\n        var format\n            function\n                param parent\n                param ast\n                param options\n                if !ast\n                    throw new Error('missing ast. parent is: ' + util.inspect(parent, { depth: 2 }))\n                if parent === null\n                    if options.starter\n                        set options.starter = false\n                    elif options.returnText\n                        # ok\n                    else\n                        _ showstack(options)\n                        throw new Error('parent is null.' + util.inspect(ast, 4))\n\n                if options.verbose\n                    # loog 'ast.type', ast.type\n                if ast.type == 'OptionalMemberExpression'\n                    set ast.type = 'MemberExpression'\n                    set ast.optional = true\n                if ast.type == 'OptionalCallExpression'\n                    set ast.type = 'CallExpression'\n                    set ast.optional = true\n                var formatter = format[ast.type]\n                if formatter\n                    _ options.stack.push(ast)\n                    var result = formatter(parent, ast, options)\n                    _ options.stack.pop()\n                    return result\n                else\n                    throw new Error('no formatter for type: ' + ast.type)\n\n        var formatText\n            function\n                param parent\n                param ast\n                param options\n                param node\n                var saveReturnText = options.returnText\n                set options.returnText = true\n                if node\n                    _ options.formatTextNodes.push(node)\n                var value = format(parent, ast, options)\n                if node\n                    _ options.formatTextNodes.pop(); \n                set options.returnText = saveReturnText\n                return value\n\n        function wizzify\n            param tobeWizzified\n            param options\n            param callback\n            # loog 'options', options\n            set options = options || {};\n            set options.input = tobeWizzified\n            set options.stack = []\n            set options.formatTextNodes = []\n            set options.wizziIncludes = []\n            set options.stateAST = []\n            var startTime = Date.now()\n            var babelOptions = options.babel || {}\n            _ parseInternal\n                @ tobeWizzified\n                @ babelOptions\n                a_cb( syntax\n                    if options.syntaxOutFile\n                        _ file.write\n                            @ options.syntaxOutFile\n                            _ JSON.stringify\n                                _ cleanAST(syntax)\n                                @ null\n                                @ 2\n                    set options.starter = true\n                    set options.commentManager = new CommentManager()\n                    var root\n                        {\n                            @ tag 'module'\n                            [ children\n                    if babelOptions.ts_or_flow !== 'typescript'\n                        _ root.children.push\n                            {\n                                @ tag 'kind'\n                                @ name 'react'\n                                [ children\n                    try\n                        _ format(root, syntax, options)\n                    catch ex\n                        return\n                            _ callback\n                                @ ex\n                    \n                    # log \"wizziTree\", JSON.stringify(root, null, 2)\n                    # loog 'options.wizziIncludes', options.wizziIncludes\n                    _ async.map\n                        @ options.wizziIncludes\n                        function\n                            param item\n                            param callback\n                            if item.kind === 'css'\n                                if !csswizzifier\n                                    set csswizzifier = require('../../cssparser/css/wizzifier')\n                                _ csswizzifier.getWizziTree\n                                    @ item.literal\n                                    {\n                                    a_cb_no_throw( ittf )\n                                        # loog 'getWizzifierIncludes.item.ittf', ittf\n                                        _ item.node.children.push\n                                            @ ittf\n                                        r_cb()\n                            else\n                                if !htmlwizzifier\n                                    set htmlwizzifier = require('../../htmlparser/wizzi/wizzifier')\n                                _ htmlwizzifier.getWizziTree\n                                    @ item.literal\n                                    {\n                                    a_cb_no_throw( ittf )\n                                        # loog 'getWizzifierIncludes.item.ittf', ittf\n                                        _ item.node.children.push\n                                            @ ittf\n                                        r_cb()\n                        a_cb()\n                            try\n                                $if wzConfigIsDocumentation\n                                    _ file.write\n                                        _ path.join\n                                            @ __dirname\n                                            @ \"..\"\n                                            @ \"..\"\n                                            @ \"..\"\n                                            @ \"..\"\n                                            @ \"..\"\n                                            @ \"..\"\n                                            @ \"autodocs\"\n                                            @ \"ts.wizzify.json\"\n                                        _ JSON.stringify\n                                            @ wzDocs\n                                            @ null\n                                            @ '\\t'\n                            catch ex\n                            r_cb( root )\n        +\n        set md.getCodeAST\n            function\n                param input\n                param options\n                param callback\n                set options = options || {}\n                set options.input = input\n                set options.stack = []\n                set options.formatTextNodes = []\n                set options.wizziIncludes = []\n                set options.stateAST = []\n                var babelOptions = options.babel || {}\n                var syntax\n                try\n                    set syntax = md.parse(input, babelOptions)\n                catch ex\n                    return\n                        _ callback\n                            @ ex\n                _ cleanAST(syntax)\n                _ callback\n                    @ null\n                    @ syntax\n        +\n        $include helper_functions\n        +\n        function isKnownType\n            param type\n            return ['Int', 'Float', 'Boolean', 'String'].indexOf(type) > -1\n        +\n        function getTypeName\n            param type\n            return isKnownType(type) ? type.toLowerCase() : type\n        +\n\n        f( File, skip\n            f_p( program\n            # TODO VIA f_a( comments\n\n        f( Program, skip\n            # s( sourceType, \"script\" | \"module\"\n            f_a( directives, true, Directive\n            f_a( body\n\n        f( Identifier, @id;is-text\n            name( name\n            # An identifier. Note that an identifier may be an expression or a destructuring pattern.\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    set ret.tag = '('\n                else\n                    set ret.tag = '+'\n            f_p( typeAnnotation, false\n            $* VIA\n            if node.optional\n                set ret.name = ret.name + '?'\n            *$\n            if node.optional\n                _ ret.children.push\n                    {\n                        @ tag ':optional'\n                        @ name ''\n                        [ children\n            if ret.children.length > 0\n                set __isText = false\n                set ret.isText = false\n                set ret.textified = null\n                # set ret.CICCIO = \"MAGIC\"\n            # loog 'Identifier', ret\n\n        f( PrivateName\n            f_p_name( Identifier\n            # A Private Name Identifier.\n\n        f( RegExpLiteral, literal;is-text\n            set ret.name = '/' + node.pattern + '/'\n            if node.flags && node.flags.length > 0\n                set ret.name += node.flags\n                # loog '*************** RegExpLiteral.ret.name', ret.name\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    set ret.tag = '('\n                else\n                    set ret.tag = '+'\n\n        f( NullLiteral, literal;is-text\n            set ret.name = 'null'\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    set ret.tag = '('\n                else\n                    set ret.tag = '+'\n\n        f( StringLiteral, literal;is-text\n            set ret.name = node.extra.raw\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    set ret.tag = '('\n                else\n                    set ret.tag = '+'\n            \n        f( BooleanLiteral, literal;is-text\n            name( value, boolean\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    set ret.tag = '('\n                else\n                    set ret.tag = '+'\n\n        f( NumericLiteral, literal;is-text\n            name( value, numeric\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    set ret.tag = '('\n                else\n                    set ret.tag = '+'\n\n        f( Function, function\n            # A function [declaration](#functiondeclaration) or [expression](#functionexpression).\n            f_p_name(id, Identifier | null\n            f_p( typeParameters, false, ?TypeParameterInstantiation\n            f_a_in_tag( params, params\n            _ processParams(ret)\n            # [ Pattern ]\n            f_p( body )\n            # b( generator\n            # b( async\n            # VIA\n                _ replaceChildrenOfChildWhenText\n                    @ ret\n                    @ getChildPosByTag(ret, 'params')\n                    @ 'param'\n            if node.generator\n                set ret.tag = 'function*'\n            if node.async\n                set ret.tag = 'async-function'\n            \n        f( ExpressionStatement, stm\n            # An expression statement, i.e., a statement consisting of a single expression.\n            f_p( expression )\n            if replaceWithSingleChild(ret, 'set')\n            elif replaceWithSingleChild(ret, '_')\n            else\n                error 'ExpressionStatement.failed.ret', ret\n                throw new Error()\n\n        f( BlockStatement, block;skip\n            f_a( body\n            f_a( directives\n            # A block statement, i.e., a sequence of statements surrounded by braces.\n\n        f( EmptyStatement, ;\n            # An empty statement, i.e., a solitary semicolon.\n\n        f( DebuggerStatement, debugger\n            # A `debugger` statement.\n\n        f( WithStatement, with\n            f_p( object, true, Expression\n            f_p( body\n            # A `with` statement.\n\n        f( ReturnStatement, return\n            f_p( argument, false, Expression | null\n            get_text_from_1_children(  )\n            # loog 'ReturnStatement', ret\n            # loog 'ReturnStatement.parent', parent.children[parent.children.length-1]\n\n        f( LabeledStatement, label\n            f_p_temp( label, true, true, Identifier\n            set ret.name = getNodeText(p_label)\n            f_p( body\n\n        f( BreakStatement, break\n            f_p_name( label, Identifier | null\n\n        f( ContinueStatement, continue\n            f_p_name( label, Identifier | null\n\n        f( IfStatement, if;ret-is-array\n            f_p_tag( test, test\n            _ setNameFromChildByTag(ret, 'test', true)\n            if node.consequent\n                f_p_temp( consequent\n                # loog 'IfStatement', p_consequent\n                if p_consequent.tag && p_consequent.tag.length > 0\n                    _ ret.children.push(p_consequent)\n                else\n                    foreach item in p_consequent.children\n                        _ ret.children.push(item)\n            if node.alternate\n                f_p_temp( alternate\n                var p_else\n                    {\n                        @ tag 'else'\n                        [ children\n                # loog 'IfStatement', p_consequent\n                if p_alternate.tag && p_alternate.tag.length > 0\n                    _ p_else.children.push(p_alternate)\n                else\n                    foreach item in p_alternate.children\n                        _ p_else.children.push(item)\n                set ret = [ret, p_else]\n            else\n                set ret = [ret]\n\n        f( SwitchStatement, switch\n            # A `switch` statement.\n            f_p_temp( discriminant, true, true, Expression\n            if isTextualNode(p_discriminant)\n                set ret.name = p_discriminant.textified || p_discriminant.name\n                set ret.textified = ret.name\n            else\n                _ ret.children.push\n                    @ p_discriminant\n            f_a( cases, true, SwitchCase\n\n        f( SwitchCase, case\n            f_p_temp( test, false, true, Expression | null\n            f_a( consequent, true, Statement\n            # A `case` (if `test` is an `Expression`) or `default` (if `test === null`) clause in the body of a `switch` statement.\n            #\n            if node.test == null\n                set ret.tag = 'default'\n            else\n                if p_test.textified || p_test.isText\n                    set ret.name = p_test.textified || p_test.name\n                    set ret.textified = ret.name\n                else\n                    throw new Error('SwitchCase.test must be textual:' + JSON.stringify(node, null, 2))\n\n        f( ThrowStatement, throw\n            f_p_temp( argument\n            # A `throw` statement.\n            if isTextualNode(p_argument)\n                set ret.name = getNodeText(p_argument)\n            else\n                _ ret.children.push\n                    @ p_argument\n\n        f( TryStatement, try;ret-is-array\n            # loog 'wizzifiers.ts.TryStatement', JSON.stringify(node, null, 2)\n            f_p( block, true, BlockStatement\n            f_p_temp( handler, false, true, CatchClause, optional\n            f_p_temp( finalizer, false, true, BlockStatement | null\n            var tempRet = [ ret ]\n            # loog 'TryStatement.p_handler', p_handler\n            # loog 'TryStatement.p_finalizer', p_finalizer\n            if p_handler\n                _ tempRet.push(p_handler)\n            if p_finalizer\n                # loog 'TryStatement', 'p_finalizer', p_finalizer\n                _ tempRet.push\n                    {\n                        @ tag 'finally'\n                        @ name ''\n                        [ children\n                            @ p_finalizer\n            set ret = tempRet\n            # A `try` statement. If `handler` is `null` then `finalizer` must be a `BlockStatement`.\n\n        f( CatchClause, catch\n            # A `catch` clause following a `try` block.\n            f_p_name( param, Pattern | null\n            f_p( body, true, BlockStatement\n            # loog 'CatchClause.ret', ret\n\n        f( WhileStatement, while\n            f_p_tag( test, test, Expression\n            get_text_from_1_children( )\n            f_p( body, true, Statement\n\n        f( DoWhileStatement, do\n            f_p_tag( test, test, Expression\n            get_text_from_1_children( )\n            f_p( body, true, Statement\n\n        f( ForStatement, for\n            f_p_tag( init, init, VariableDeclaration | Expression | null\n            f_p_tag( test, test, Expression | null\n            f_p_tag( update, update, Expression | null\n            # loog 'p_init.textified', p_init.textified\n            var c1 = p_init.isText ? p_init.name : (p_init.textified ? p_init.textified : '')\n            var c2 = p_test.isText ? p_test.name : (p_test.textified ? p_test.textified : '')\n            var c3 = p_update.isText ? p_update.name : (p_update.textified ? p_update.textified : '')\n            set ret.name = c1 + '; ' + c2 + '; ' + c3\n            _ removeChildByTag(ret, 'init')\n            _ removeChildByTag(ret, 'test')\n            _ removeChildByTag(ret, 'update')\n            f_p( body, true, Statement\n\n        f( ForInStatement, for\n            f_p_temp( left, true, true, VariableDeclaration |  Expression\n            f_p_temp( right, true, true, Expression\n            if isTextualNode(p_left)\n                set ret.name = getNodeText(p_left)\n                if isTextualNode(p_right)\n                    set ret.name += ' in ' + getNodeText(p_right)\n                else\n                    _ ret.children.push\n                        {\n                            @ tag 'in'\n                            [ children\n                                @ p_right\n            else\n                _ ret.children.push\n                    {\n                        @ tag 'left'\n                        [ children\n                            @ p_left\n                if isTextualNode(p_right)\n                    _ ret.children.push\n                        {\n                            @ tag 'in'\n                            @ name getNodeText(p_right)\n                            [ children\n                else\n                    _ ret.children.push\n                        {\n                            @ tag 'in'\n                            [ children\n                                @ p_right\n\n            b( await\n            f_p( body, true, Statement\n        \n        f( ForOfStatement, for\n            f_p_temp( left, true, true, VariableDeclaration |  Expression\n            f_p_temp( right, true, true, Expression\n            # loog 'ForOfStatement', isTextualNode(p_left), isTextualNode(p_right)\n            if isTextualNode(p_left)\n                set ret.name = getNodeText(p_left)\n                if isTextualNode(p_right)\n                    set ret.name += ' of ' + getNodeText(p_right)\n                    set ret.textified = ret.name\n                    set ret.isText = true\n                else\n                    _ ret.children.push\n                        {\n                            @ tag 'of'\n                            [ children\n                                @ p_right\n            else\n                _ ret.children.push\n                    {\n                        @ tag 'left'\n                        [ children\n                            @ p_left\n                if isTextualNode(p_right)\n                    _ ret.children.push\n                        {\n                            @ tag 'of'\n                            @ name getNodeText(p_right)\n                            [ children\n                else\n                    _ ret.children.push\n                        {\n                            @ tag 'of'\n                            [ children\n                                @ p_right\n            b( await\n            f_p( body, true, Statement\n        \n        f( FunctionDeclaration, function\n            # A function [declaration](#functiondeclaration) or [expression](#functionexpression).\n            f_p_name(id, Identifier | null\n            f_p( typeParameters, false, ?TypeParameterInstantiation\n            # f_a_in_tag( params, params\n            # _ processParams(ret)\n            f_a_temp( params\n            _ processParams2(ret, p_params)\n            f_p_temp( returnType, false, true\n            if p_returnType\n                # loog 'p_returnType', JSON.stringify(p_returnType)\n                set p_returnType\n                    {\n                        @ tag ':return'\n                        [ children\n                            @ p_returnType\n                _ ret.children.push(p_returnType)\n            f_p( predicate, false\n            f_p( body, true, Statement\n            if node.generator\n                set ret.tag = 'function*'\n            if node.async\n                set ret.tag = 'async-function'\n\n        f( VariableDeclaration, node.kind;tag-is-var\n            # enum \"var\" | \"let\" | \"const\"\n            \n            f_a( declarations, true, VariableDeclarator\n            \n            # loog '=== VariableDeclaration ittf result 1', JSON.stringify(ret, null, 2)\n            \n            get_text_from_1_children(  )\n            \n            # loog '=== VariableDeclaration ittf result 2', ret, 'got_text_1', got_text_1\n            \n            if got_text_1\n                set ret.textified = node.kind + ' ' + ret.textified\n            elif ret.children.length == 1\n                # loog 'VariableDeclaration.ret.children[0].children.length', ret.children[0].children.length\n                if ret.children[0].children.length == 0\n                    set ret.name = ret.children[0].name\n                    set ret.children = []\n                    # no init value\n                elif ret.children[0].children.length == 1\n                    set ret.name = ret.children[0].name\n                    set ret.children[0] = ret.children[0].children[0]\n                    # loog 'ret.name', ret.name\n                    # loog 'ret.children[0]', ret.children[0]\n                    # set ret.textified = node.kind + ' ' + ret.name\n                elif ret.children[0].children.length == 2\n                    var child1 = ret.children[0].children[0]\n                    var child2 = ret.children[0].children[1]\n                    # loog 'ret.name', ret.name\n                    # loog 'ret.children[0].name', ret.children[0].name\n                    # loog 'child1.tag.name', child1.tag, child1.name\n                    # loog 'child2.tag.name', child2.tag, child2.name\n                    if child2.tag === '=' || isTypeReference(child1.tag)\n                        set ret.name = ret.children[0].name\n                        set ret.children = []\n                        _ ret.children.push\n                            @ child1\n                        _ ret.children.push\n                            @ child2\n                    else\n                        if child1.name && child1.name.length > 0 && child1.children.length > 0\n                            set ret.name = child1.name\n                            set ret.children = []\n                            foreach item in child1.children\n                                _ ret.children.push\n                                    @ item\n                            _ ret.children.push\n                                @ child2\n                        else\n                            set ret.name = ret.children[0].name\n                            set ret.children = []\n                            _ ret.children.push\n                                @ child1\n                            _ ret.children.push\n                                @ child2\n                else\n                    error 'Error VariableDeclaration. Case not managed.',\n                    foreach item in ret.children\n                        error 'VariableDeclaration.child', item\n                    throw new Error(\"VariableDeclaration. Case not managed.\")\n            elif ret.children.length > 1\n                var sb = []\n                foreach item in ret.children\n                    if item.textified\n                        _ sb.push(item.textified)\n                    else\n                        set sb = null\n                        break\n                if sb\n                    set ret.textified = node.kind + ' ' + sb.join(', ')\n\n            if node.declare\n                set ret\n                    {\n                        @ tag ':declare'\n                        @ name ''\n                        [ children\n                            @ ret\n            \n\n        f( VariableDeclarator, decl\n            f_p_temp(id, true, true)\n            \n            # loog 'VariableDeclarator,p_id, isTextualNode(p_id)', p_id, isTextualNode(p_id)\n            if isTextualNode(p_id)\n                set ret.name = getNodeText(p_id)\n            else\n                if p_id.tag === '@id'\n                    set ret.name = p_id.name\n                    set ret.children = p_id.children\n                else\n                    _ ret.children.push\n                        @ p_id\n            \n            # loog 'VariableDeclarator 1', ret\n\n            f_p( typeAnnotation, false, ?TypeAnnotation\n\n            f_p_temp( init, false, true, Expression | null\n            \n            # loog 'VariableDeclarator.p_init', p_init\n            \n            if p_init\n                # loog 'VariableDeclarator.p_init', isTextualNode(p_id), 'p_id', p_id, 'p_init', p_init\n                if isTextualNode(p_id)\n                    if isTextualNode(p_init)\n                        set ret.name += ' = ' + getNodeText(p_init)\n                        set ret.textified = ret.name\n                        set ret.isText = true\n                    else\n                        _ ret.children.push\n                            @ p_init\n                    $* VIA\n                    else\n                        # has no init value ( node.init == null )\n                        set ret.textified = ret.name\n                    *$\n                else\n                    $* 27/3/21 waiting for big big damage\n                    if p_id.tag === '@id'\n                        _ ret.children.push\n                            @ p_init\n                    else\n                    *$\n                    if isTextualNode(p_init)\n                        _ ret.children.push\n                            {\n                                @ tag '='\n                                @ name getNodeText(p_init)\n                                [ children\n                    else\n                        _ ret.children.push\n                            {\n                                @ tag '='\n                                [ children\n                                    @ p_init\n            else\n                $* 24/3/21 BIG BIG damage\n                set ret.textified = ret.name\n                set ret.isText = true\n                *$\n\n            # loog 'VariableDeclarator 2 ret', ret\n\n        f( Decorator, @d\n            f_p_temp( expression, true, true, Expression\n            if isTextualNode(p_expression)\n                set ret.name = getNodeText(p_expression)\n            else\n                _ ret.children.push\n                    @ p_expression\n\n        f( Directive, directive\n            if node.value && node.value.value === 'use strict'\n                set ret = null\n            else\n                f_p_temp( value, true, true, DirectiveLiteral\n                if isTextualNode(p_value)\n                    set ret.name = getNodeText(p_value)\n\n        f( DirectiveLiteral\n\n        f( Expression, expr\n            # Any expression node. Since the left-hand side of an assignment may be any expression in general, an expression can also be a pattern.\n\n        f( Super, super;is-text\n            # A `super` pseudo-expression.\n            set ret.name = 'super'\n\n        f( Import, import\n            # A `import` pseudo-expression.\n\n        f( ThisExpression, this;is-text\n            # A `this` expression.\n            set ret.name = 'this'\n\n        f( ArrowFunctionExpression, =>\n            if verify.isArray(node.body) == false\n                set node.body = [node.body]\n            f_a_in_tag( params, params\n            _ processParams(ret)\n            f_p_temp(returnType, false)\n            if p_returnType\n                set p_returnType\n                    {\n                        @ tag ':return'\n                        [ children\n                            @ p_returnType\n                _ ret.children.push(p_returnType)\n            f_a( body, true, BlockStatement | Expression\n            b( expression\n            \n            # loog '*** ArrowFunctionExpression.ret.params', getChildByTag(ret, 'params')\n            # loog '*** ArrowFunctionExpression.ret', ret\n            # A fat arrow function expression, e.g., `let foo = (bar) => { /* body */ }`.\n            \n            if node.async\n                set ret.tag = 'async=>'\n            if node.generator\n                set ret.tag += '*'\n    \n        f( YieldExpression, yield\n            $$ 20/3/21 f_p_tag( argument, argument, Expression | null\n            f_p_temp( argument, true, true, Expression | null\n            # loog 'ObjectProperty.p_value', p_value\n            if isTextualNode(p_argument)\n                set ret.name = getNodeText(p_argument)\n            else\n                _ ret.children.push\n                    @ p_argument\n            $$ get_text_from_1_children(  )\n            b( delegate\n            # A `yield` expression.\n\n        f( AwaitExpression, await\n            f_p( argument, false, Expression | null\n            # A `await` expression.\n\n        f( ArrayExpression, [\n            f_a( elements, true, Expression | SpreadElement | null \n            # An array expression.\n            if options.mustBeText\n                if setTextList(ret, ', ')\n                    set ret.textified = '[' + ret.textified + ']'\n                    # loog '### ArrayExpression', 'name:', ret.name, 'textified', ret.textified, ret.isText\n                else\n                    throw new Error(\"ArrayExpression. Cannot textify node as requested: \" + JSON.stringify(node, null, 2))\n            elif options.couldBeText\n                var tlist = getTextList(ret, ', ')\n                if tlist && tlist.length < 15\n                    set ret.textified = '[' + ret.textified + ']'\n                    # TODO??? set ret.children = []\n                else\n                    set ret.textified = null\n                    foreach item in ret.children\n                        if isTextualNode(item)\n                            set item.tag = '@'\n                            set item.name = getNodeText(item)\n                        elif [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                            set item.tag = '@'\n            else\n                foreach item in ret.children\n                    if isTextualNode(item)\n                        set item.tag = '@'\n                        set item.name = getNodeText(item)\n                    elif [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                        set item.tag = '@'\n            if ret.children.length == 0\n                set ret.textified = '[]'\n\n        f( ObjectExpression, {\n            if options.stateAST[options.stateAST.length-1] === 'JSXExpressionContainer'\n                _ parent.children.pop\n                set ret = parent\n                var __skip = true\n            f_a( properties, true, ObjectProperty | ObjectMethod | SpreadElement\n            if options.mustBeText\n                if setTextList(ret, ', ')\n                    set ret.textified = '{' + ret.textified + '}'\n                    if node.extra && node.extra.parenthesized == true\n                        set ret.textified = '(' + ret.textified + ')'\n                else\n                    throw new Error(\"ObjectExpression. Cannot textify node as requested: \" + JSON.stringify(node, null, 2))\n            else\n                foreach item in ret.children\n                    if item.tag === '...' \n                        # loog 'ObjectExpression, item.tag, item.children.length', item.tag, item.textified, item.children.length\n                        if item.children.length == 0\n                            set item.name = item.textified\n                            set item.tag = '@'\n                        elif item.children.length == 1\n                            if item.children[0].name\n                                set item.children[0].name = '...' + item.children[0].name\n                            if item.textified\n                                set item.children[0].textified = '...' + item.children[0].textified\n                            if item.children[0].name || item.textified\n                                set item.tag = item.children[0].tag\n                                set item.textified = item.children[0].textified\n                                set item.name = item.children[0].name\n                                set item.children = item.children[0].children\n                                # loog 'ObjectExpression length 1', item.tag, item.name, item.textified\n                            else\n                                # go on\n                    if item.tag === '@' && item.name === 'template' \n                        \\b && item.children.length == 1 && item.children[0].tag === '`lit'\n                        # loog 'ObjectExpression', item.tag, item.name, getLiteral(item.children[0])\n                        _ options.wizziIncludes.push\n                            {\n                                @ kind 'html'\n                                @ node item\n                                @ literal getLiteral(item.children[0])\n                        set item.children = []\n\n                if !ret.textified && ret.children.length == 0\n                    if node.extra && node.extra.parenthesized == true\n                        # set ret.name = ret.textified = '({})' // 10/1/19\n                        set ret.textified = '({})'\n                    else\n                        # set ret.name = ret.textified = '{}' // 10/1/19\n                        # set ret.textified = '{}' // 25/3/21\n                else\n                    if node.extra && node.extra.parenthesized == true\n                        var temp\n                            {\n                                @ tag '('\n                                [ children\n                                    @ ret\n                        set ret = temp\n\n        $* interface\n        f( ObjectMember, @\n            f_p( key, true, Expression\n            # b( computed\n            f_a( decorators, false, Decorator \n        *$\n\n        f( ObjectProperty, @\n            # loog 'ObjectProperty enter options.mustBeText', options.mustBeText\n            const save = options.mustBeText\n            set options.mustBeText = true\n            f_p_temp(key, true)\n            # loog 'ObjectProperty.p_key', p_key\n            set options.mustBeText = save\n            \n            if isTextualNode(p_key)\n                set ret.name = getNodeText(p_key)\n                if node.computed\n                    set ret.name = '[' + ret.name + ']'\n            else\n                var p_computed\n                    {\n                        @ tag '@['\n                        [ children\n                            @ p_key\n                _ ret.children.push\n                    @ p_computed\n                set ret = p_computed\n            \n            f_a( decorators, false, Decorator\n\n            # loog 'ObjectProperty.ret.name', ret.name, 'node.value.type', node.value.type\n            if node.value.type === 'AssignmentPattern'\n                f_p_temp( value.left, true, true, Expression\n                f_p_temp( value.right, true, true, Expression\n                # loog 'p_value_left', p_value_left\n                # loog 'p_value_right', p_value_right\n                if node.value.left.type === 'ObjectPattern'\n                    _ ret.children.push\n                        @ p_value_left\n                    if isTextualNode(p_value_right)\n                        _ ret.children.push\n                            {\n                                @ tag '='\n                                @ name getNodeText(p_value_right)\n                                [ children\n                    elif p_value_right.tag === 'none' && verify.isNotEmpty(p_value_right.name)\n                        # FIXME why this?\n                        _ ret.children.push\n                            {\n                                @ tag '='\n                                @ name p_value_right.name\n                                [ children\n                    else\n                        _ ret.children.push\n                            {\n                                @ tag '='\n                                [ children\n                                    @ p_value_right\n                else\n                    if isTextualNode(p_value_right)\n                        if options.mustBeText\n                            set ret.textified = ret.name += ' = ' + getNodeText(p_value_right)\n                        else\n                            _ ret.children.push\n                                {\n                                    @ tag '='\n                                    @ name getNodeText(p_value_right)\n                                    [ children\n                    elif p_value_right.tag === 'none' && verify.isNotEmpty(p_value_right.name)\n                        # FIXME why this?\n                        _ ret.children.push\n                            {\n                                @ tag '='\n                                @ name p_value_right.name\n                                [ children\n                    else\n                        _ ret.children.push\n                            {\n                                @ tag '='\n                                [ children\n                                    @ p_value_right\n            else\n                f_p_temp( value, true, true, Expression\n                # loog 'ObjectProperty.p_value', p_value, isTextualNode(p_value), isTextualNode(p_key)\n                if isTextualNode(p_value)\n                    if isTextualNode(p_key)\n                        if options.mustBeText\n                            if ret.name !== getNodeText(p_value)\n                                set ret.textified = ret.name += ': ' + getNodeText(p_value)\n                            else\n                                set ret.textified = ret.name\n                        else\n                            if ret.name !== getNodeText(p_value)\n                                set ret.name += ' ' + getNodeText(p_value)\n                    else\n                        _ ret.children.push\n                            {\n                                @ tag '+'\n                                @ name getNodeText(p_value)\n                                [ children\n                elif p_value.tag === 'none' && verify.isNotEmpty(p_value.name)\n                    if isTextualNode(p_key)\n                        if ret.name !== p_value.name\n                            set ret.name += ' ' + p_value.name\n                    else\n                        _ ret.children.push\n                            {\n                                @ tag '+'\n                                @ name p_value.name\n                                [ children\n                else\n                    _ ret.children.push\n                        @ p_value\n            \n            # TODO b( shorthand\n            # TODO b( async\n            # TODO b( generator\n            \n\n            if ret.children.length == 1 && ret.children[0].tag === '{'\n                set ret.tag = '{' + ret.tag.substr(1)\n                set ret.children = ret.children[0].children\n            elif ret.children.length == 1 && ret.children[0].tag === '['\n                set ret.tag = '[' + ret.tag.substr(1)\n                set ret.children = ret.children[0].children\n\n        f( ObjectMethod, node.kind;tag-is-var\n            # loog 'ObjectMethod enter options.mustBeText', options.mustBeText\n            # s( kind\n            # enum \"get\" | \"set\" | \"method\"\n            const save = options.mustBeText\n            set options.mustBeText = true\n            f_p_temp(key, true)\n            set ret.name = getNodeText(p_key)\n            set options.mustBeText = save\n            b( async\n            f_a_in_tag( params, params\n            _ processParams(ret)\n            f_p_temp(returnType, false)\n            if p_returnType\n                set p_returnType\n                    {\n                        @ tag ':return'\n                        [ children\n                            @ p_returnType\n                _ ret.children.push(p_returnType)\n            f_p( body, true, Statement\n            set ret.tag = ret.tag == 'constructor' ? 'ctor' : (ret.tag == 'method' ? 'm' : ret.tag)\n            _ setNameFromChildByTag(ret, 'key', true)\n            if ret.tag === 'ctor'\n                set ret.name = ''\n            elif node.computed\n                set ret.name = '[' + ret.name + ']'\n\n        f( FunctionExpression, function\n            f_p_name(id, Identifier | null\n            f_p( typeParameters, false, ?TypeParameterInstantiation\n            f_a_in_tag( params, params\n            _ processParams(ret)\n            f_p_temp(returnType, false)\n            if p_returnType\n                set p_returnType\n                    {\n                        @ tag ':return'\n                        [ children\n                            @ p_returnType\n                _ ret.children.push(p_returnType)\n            f_p( body )\n            \n            if node.async\n                set ret.tag = 'async-function'\n            if node.generator\n                set ret.tag += '*'\n\n        f( UnaryExpression, 'op' + node.operator;tag-is-var\n            # A unary operator expression.\n            # s( operator, UnaryOperator enum \"-\" | \"+\" | \"!\" | \"~\" | \"typeof\" | \"void\" | \"delete\" | \"throw\"\n            # b( prefix\n\n            if ret.tag == 'opdelete'\n                set ret.tag = 'delete'\n            \n            f_p_temp( argument, true, true, Expression\n            if isTextualNode(p_argument)\n                set ret.name = getNodeText(p_argument)\n                const space = ['-','+','!','{'].indexOf(node.operator) > -1 ? '' : ' '\n                set ret.textified = node.operator + space + ret.name\n            else\n                _ ret.children.push\n                    @ p_argument\n\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                if node.extra && node.extra.parenthesized == true\n                    # is the return value of an ArrowExpression\n                    # TODO ...\n                    if isTextualNode(p_argument)\n                        set ret.tag = '('\n                        set ret.name = node.operator + getNodeText(p_argument)\n                        set ret.textified = '(' + node.operator + getNodeText(p_argument) + ')'\n                    else\n                        var temp\n                            {\n                                @ tag '('\n                                [ children\n                                    @ ret\n                        set ret = temp\n                else\n                    # TODO ...\n                    if isTextualNode(p_argument)\n                        set ret.tag = '+'\n                        set ret.name = node.operator + getNodeText(p_argument)\n                    else\n                        var temp\n                            {\n                                @ tag '+'\n                                [ children\n                                    @ ret\n                        set ret = temp\n            \n        f( UpdateExpression, 'op' + node.operator;tag-is-var\n            # An update (increment or decrement) operator expression.\n            # s( operator, UpdateOperator enum \"++\" | \"--\"\n            f_p( argument, true, Expression\n            # b( prefix\n            \n            get_text_from_1_children(  )\n            if got_text_1\n                set ret.tag = 'set'\n                if node.prefix\n                    set ret.name = node.operator + ret.name\n                else\n                    set ret.name = ret.name + node.operator\n                set ret.textified = ret.name\n            \n            if node.prefix\n                set ret.tag = node.operator + 'op'\n\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if got_text_1\n                    if node.extra && node.extra.parenthesized == true\n                        set ret.tag = '('\n                    else\n                        set ret.tag = '+'\n                else\n                    # TODO\n                    # is the return value of an ArrowExpression\n                    if got_text_1\n                        set ret.tag = '('\n                    else\n                        set ret.tag = '(' + ret.tag\n\n        f( BinaryExpression, 'op' + node.operator;tag-is-var\n            # A binary operator token.\n            # s( operator, BinaryOperator\n            # enum \"==\" | \"!=\" | \"===\" | \"!==\" \n                \\b \"<\" | \"<=\" | \">\" | \">=\"\n                \\b | \"<<\" | \">>\" | \">>>\"\n                \\b | \"+\" | \"-\" | \"*\" | \"/\" | \"%\"\n                \\b | \"|\" | \"^\" | \"&\" | \"in\"\n                \\b | \"instanceof\"\n                \\b | \"|>\"\n\n            if node.operator.length > 1\n                set ret.tag = node.operator\n            \n            f_p_temp( left, true, true, Expression\n            # loog 'BinaryExpression.p_left', p_left\n            f_p_temp( right, true, true, Expression\n            # loog 'BinaryExpression.p_right', p_right\n\n            if isTextualNode(p_left) && isTextualNode(p_right)\n                set ret.tag = 'set'\n                set ret.name = getNodeText(p_left) + ' ' + node.operator + ' ' + getNodeText(p_right)\n                set ret.textified = ret.name\n                if node.extra && node.extra.parenthesized == true\n                    set ret.textified = '(' + ret.textified + ')'\n            else\n                if isTextualNode(p_left) || (p_left.children.length == 0 && [$*'@expr',*$ '@id', 'literal'].indexOf(p_left.tag) > -1)\n                    set p_left.tag = '+'\n                    if isTextualNode(p_left)\n                        set p_left.name = getNodeText(p_left)\n                        set p_left.children = []\n                _ ret.children.push\n                    @ p_left\n                if isTextualNode(p_right) || (p_right.children.length == 0 && [$*'@expr',*$ '@id', 'literal'].indexOf(p_right.tag) > -1)\n                    set p_right.tag = '+'\n                    if isTextualNode(p_right)\n                        set p_right.name = getNodeText(p_right)\n                        set p_right.children = []\n                _ ret.children.push\n                    @ p_right\n                if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                    # is the return value of an ArrowExpression\n                    if node.extra && node.extra.parenthesized == true\n                        set ret.tag = '(' + ret.tag\n                    else\n                        # 18/3/21 set ret.tag = '+'\n\n        f( AssignmentExpression, set\n            # loog 'AssignmentExpression enter options.mustBeText', options.mustBeText\n            # An assignment operator expression.\n            # s( operator, AssignmentOperator\n            # enum AssignmentOperator {\n                \\b \"=\" | \"+=\" | \"-=\" | \"*=\" | \"/=\" | \"%=\"\n                \\b | \"<<=\" | \">>=\" | \">>>=\"\n                \\b | \"|=\" | \"^=\" | \"&=\"\n            const save = options.mustBeText\n            set options.mustBeText = true\n            f_p_temp( left, true, true, Pattern | Expression\n            set options.mustBeText = save\n            f_p_temp( right, true, true, Expression\n            \n            if isTextualNode(p_left)\n                set ret.name = getNodeText(p_left) + ' ' + node.operator + ' '\n            else\n                set ret.name = node.operator\n                _ ret.children.push\n                    @ p_left\n            # loog 'AssignmentExpression.isTextualNode(p_right)', isTextualNode(p_right)\n            # loog 'AssignmentExpression.p_right', p_right\n            if isTextualNode(p_left) && isTextualNode(p_right)\n                set ret.name += getNodeText(p_right)\n            else\n                if verify.isEmpty(p_right.tag)\n                    foreach item in p_right.children\n                        _ ret.children.push\n                            @ item\n                else\n                    _ ret.children.push\n                        @ p_right\n            # loog 'AssignmentExpression.ret final', ret\n\n        f( LogicalExpression, 'op' + node.operator;tag-is-var\n            # A logical operator expression.\n            # s( operator, LogicalOperator enum \"||\" | \"&&\" | \"??\"\n            \n            f_p_temp( left, true, true, Expression\n            f_p_temp( right, true, true, Expression\n\n            var parenthesized = node.extra && node.extra.parenthesized\n\n            # loog 'LogicalExpression', isTextualNode(p_left), isTextualNode(p_right)\n            # loog 'LogicalExpression,p_left', p_left\n            # loog 'LogicalExpression,p_right', p_right\n            if isTextualNode(p_left) && isTextualNode(p_right)\n                set ret.tag = '@expr' $$ 27/3/21 'set'\n                set ret.name = parenthesize(getNodeText(p_left) + ' ' + node.operator + ' ' + getNodeText(p_right), parenthesized)\n                set ret.textified = ret.name\n            else\n                set ret.tag = node.operator\n                # loog 'LogicalExpression,isTextualNode(p_left),p_left', isTextualNode(p_left), p_left\n                if isTextualNode(p_left) || [$*'@expr', 27/3/21*$'@id', 'literal','set'].indexOf(p_left.tag) > -1\n                    set p_left.tag = '+'\n                    if isTextualNode(p_left)\n                        set p_left.name = getNodeText(p_left)\n                        set p_left.children = []\n                _ ret.children.push\n                    @ p_left\n                # loog 'LogicalExpression,isTextualNode(p_right),p_right', isTextualNode(p_right), p_right\n                if isTextualNode(p_right) || [$*'@expr', 27/3/21*$'@id', 'literal','set'].indexOf(p_right.tag) > -1\n                    set p_right.tag = '+'\n                    if isTextualNode(p_right)\n                        set p_right.name = getNodeText(p_right)\n                        set p_right.children = []\n                _ ret.children.push\n                    @ p_right\n                if parenthesized\n                    set ret \n                        {\n                            @ tag '('\n                            @ children [ret]\n                $*\n                if isTextualNode(p_left) || ['@id', 'literal'].indexOf(p_left.tag) > -1\n                    set p_left.tag = '+'\n                    if isTextualNode(p_left)\n                        set p_left.name = getNodeText(p_left)\n                        set p_left.children = []\n                _ ret.children.push\n                    @ p_left\n                # loog 'LogicalExpression.p_left', p_left\n                if isTextualNode(p_right) || ['@id', 'literal'].indexOf(p_right.tag) > -1\n                    set p_right.tag = '+'\n                    if isTextualNode(p_right)\n                        set p_right.name = getNodeText(p_right)\n                        set p_right.children = []\n                _ ret.children.push\n                    @ p_right\n                # loog 'LogicalExpression.p_right', p_right\n                *$\n\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    if ret.tag === 'set'\n                        set ret.tag = '('\n                    else\n                        set ret.tag = '(' + ret.tag\n                else\n                    if ret.tag === 'set'\n                        set ret.tag = '+'\n                    else\n                        # TODO Do nothing is OK?\n\n        f( SpreadElement, ...\n            f_p_temp( argument, true, true, Expression\n            # loog 'SpreadElement.p_argument', p_argument\n            if isTextualNode(p_argument)\n                set ret.name = getNodeText(p_argument)\n                set ret.textified = '...' + ret.name\n            else\n                _ ret.children.push\n                    @ p_argument\n                # set ret.textified = p_argument.source\n                # throw new Error('SpreadElement must be textual:' + JSON.stringify(p_argument, null, 2))\n\n        f( MemberExpression, @expr\n            f_p_temp( object\n            f_p_temp( property\n            \n            # b( computed\n            # b( optional, optional\n            # If `computed` is `true`, the node corresponds to a computed (`a[b]`) member expression and `property` is an `Expression`. \n            # If `computed` is `false`, the node corresponds to a static (`a.b`) member expression and `property` is an `Identifier`. \n            # The `optional` flags indicates that the member expression can be called even if the object is null or undefined. \n            # If this is the object value (null/undefined) should be returned.\n            \n            # if p_object.name == 'Promise'\n                # loog 'MemberExpression.p_object', isTextualNode(p_object), p_object\n                # loog 'MemberExpression.p_property', isTextualNode(p_property), p_property\n\n            var qmark = node.optional ? '?' : ''\n\n            if isTextualNode(p_object)\n                var obj = getNodeText(p_object)\n                if isTextualNode(p_property)\n                    var prop = getNodeText(p_property)\n                    set ret.name = node.computed \n                        \\b ? obj + qmark + '[' + prop + ']' \n                        \\b : obj + qmark + '.' + prop\n                    set ret.textified = ret.name\n                    set ret.children = []\n                    # loog 'MemberExpression.textified', ret.textified\n                else\n                    set ret.name = obj + qmark\n                    var link\n                        {\n                            @ tag node.computed ? '.[' : '.'\n                            [ children\n                    _ link.children.push\n                        @ p_property\n                    _ ret.children.push\n                        @ link\n            else\n                log 1011\n                if node.computed\n                    set p_property.tag = '.['\n                else\n                    set p_property.tag = '.'\n                if p_object.tag === '('\n                    # log 2\n                    # 26/3/21 this is the most improbable, waiting for big damage\n                    set p_object.name = p_object.name + qmark\n                    _ ret.children.push\n                        @ p_object\n                    _ ret.children.push\n                        @ p_property\n                else\n                    # log 3, p_object.tag, p_object.name\n                    set ret.tag = p_object.tag\n                    set ret.name = p_object.name + qmark\n                    set ret.source = p_object.source\n                    set ret.children = p_object.children\n                    _ ret.children.push\n                        @ p_property\n\n                # loog 'MemberExpression.tag.name', ret.tag, ret.name\n                foreach item in ret.children\n                    # loog 'MemberExpression.child', i, ret.children[i].tag, ret.children[i].name\n\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    set ret\n                        {\n                            @ tag '('\n                            @ children [ret]\n                else\n                    $$ Whats this ???\n                    set ret\n                        {\n                            @ tag '+'\n                            @ children [ret]\n\n\n        f( BindExpression, bind-expr\n            f_p( object, false, Expression | null\n            f_p( callee, true, Expression\n            # if `object` is `null`, then `callee` should be a `MemberExpression`.\n\n        f( ConditionalExpression, iif\n            # A conditional expression, i.e., a ternary `?`/`:` expression.\n            f_p_tag( test, test\n            f_p_temp( consequent, true, true, Expression\n            f_p_temp( alternate, true, true, Expression\n            \n            # loog 'ConditionalExpression 1', ret.tag\n            _ setNameFromChildByTag(ret, 'test', true)\n            # loog 'ConditionalExpression 2', ret.tag\n\n            _ setOrInlineIfTextualNode\n                @ ret\n                @ p_consequent\n                @ 'then'\n\n            $*\n            if isTextualNode(p_consequent)\n                _ ret.children.push\n                    {\n                        @ tag 'then'\n                        @ name getNodeText(p_consequent)\n                        [ children\n            else\n                _ ret.children.push\n                    {\n                        @ tag 'then'\n                        [ children\n                            @ p_consequent\n            *$\n\n            _ setOrInlineIfTextualNode\n                @ ret\n                @ p_alternate\n                @ 'else'\n\n            $*\n            if isTextualNode(p_alternate)\n                _ ret.children.push\n                    {\n                        @ tag 'else'\n                        @ name getNodeText(p_alternate)\n                        [ children\n            else\n                _ ret.children.push\n                    {\n                        @ tag 'else'\n                        [ children\n                            @ p_alternate\n            *$\n\n            # loog 'ConditionalExpression 3', ret.tag\n\n            $* VIA 29/3/21\n            if node.__parent && node.__parent.name === 'body' && node.__parent.len == 1\n                # is the return value of an ArrowExpression\n                if node.extra && node.extra.parenthesized == true\n                    var temp\n                        {\n                            @ tag '('\n                            [ children\n                                @ ret\n                    set ret = temp\n                else\n                    # TODO do nothing\n            *$\n            if node.extra && node.extra.parenthesized == true\n                set ret\n                    {\n                        @ tag '('\n                        @ name ''\n                        [ children\n                            @ ret\n\n            # loog 'ConditionalExpression 4', ret.tag\n\n        f( CallExpression, _\n            # A function or method call expression.\n\n            f_p( typeParameters, false, ?TypeParameterInstantiation\n            f_p_temp( callee, true, true, | Super | Import\n            f_a_temp( arguments\n\n            var lastCallee = ret\n            # loog 'CallExpression.p_callee', p_callee\n\n            var qmark = node.optional ? '?.' : ''\n            \n            if isTextualNode(p_callee)\n                # loog 'CallExpression',\n                    \\b 'isTextualNode(p_callee)', isTextualNode(p_callee), \n                    \\b 'getNodeText(p_callee)', getNodeText(p_callee), \n                    \\b 'node.typeParameters', node.typeParameters,\n                    \\b 'p_arguments', p_arguments\n                # first of all try to set ret.textified\n\n                set ret.name = getNodeText(p_callee) + qmark\n                \n                if node.typeParameters\n\n                    foreach item in p_arguments.children\n                        if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                            set item.tag = '@'\n                        _ lastCallee.children.push\n                            @ item\n                \n                else\n\n                    # loog 'CallExpression p_arguments', p_arguments\n\n                    if p_arguments && p_arguments.children.length > 0\n                        var tlist = getTextList(p_arguments, ', ')\n                        if tlist\n                            set ret.name += '(' + tlist + ')'\n                            set ret.textified = ret.name\n                            set ret.isText = true\n                        else\n                            foreach item in p_arguments.children\n                                if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                                    set item.tag = '@'\n                                _ lastCallee.children.push\n                                    @ item\n                    else\n                        set ret.name += '()'\n                        set ret.textified = ret.name\n                        set ret.isText = true\n\n                    if ret.textified && node.extra && node.extra.parenthesized == true\n                        set ret.textified = '(' + ret.textified + ')'\n\n                # loog 'CallExpression', 'ret.name,textified', ret.name, ret.textified\n            \n            else\n\n                # TODO implement node.optional\n\n                # loog 'CallExpression', \n                    \\b 'p_callee.tag', p_callee.tag, \n                    \\b 'p_callee.name', p_callee.name,\n                    \\b 'ret.tag', ret.tag\n                \n                foreach item in p_callee.children\n                    # loog 'CallExpression', 'p_callee.children', i, p_callee.children[i].tag, p_callee.children[i].name\n                \n                if p_arguments\n                    foreach item in p_arguments.children\n                        # loog 'CallExpression', 'p_arguments.children', i, p_arguments.children[i].tag, p_arguments.children[i].name\n                \n                if ['[', '{', 'new'].indexOf(p_callee.tag) > -1\n                    set ret.tag = p_callee.tag\n                \n                if ['`lit','iif'].indexOf(p_callee.tag) < 0\n                    set ret.name = p_callee.name\n                    set ret.children = p_callee.children\n\n                    $$ Begin 19/3/21\n                    if p_callee.children.length > 0\n                        # loog 'p_callee.children.length > 0'\n                        set lastCallee = p_callee.children[p_callee.children.length-1]\n                        if p_arguments && p_arguments.children.length > 0\n                            if lastCallee.tag === '.'\n                                set lastCallee.tag = '._'\n                                foreach item in p_arguments.children\n                                    if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                                        set item.tag = '@'\n                                    _ lastCallee.children.push\n                                        @ item\n                            else\n                                var call\n                                    {\n                                        @ tag '('\n                                        [ children\n                                foreach item in p_arguments.children\n                                    if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                                        set item.tag = '@'\n                                    _ call.children.push\n                                        @ item\n                                _ ret.children.push(call)\n                        else\n                            if lastCallee.tag === '.'\n                                set lastCallee.tag = '._'\n                    else\n                        # loog 'p_callee.children.length == 0'\n                        set ret.tag = \"_\"\n                        set ret.name = p_callee.tag\n                        if p_arguments && p_arguments.children.length > 0\n                            foreach item in p_arguments.children\n                                if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                                    set item.tag = '@'\n                                _ ret.children.push\n                                    @ item\n                        # loog 'CallExpression', p_callee, ret\n                    # loog 'node.callee.type', node.callee.type, ret.tag\n                    $$ End 19/3/21\n\n                else\n                    # loog '1203'\n                    var temp = [p_callee]\n                    set lastCallee = p_callee.children[p_callee.children.length-1]\n                    if lastCallee.tag === '.'\n                        set lastCallee.tag = '._'\n                        set p_callee.children.length --\n                        _ temp.push\n                            @ lastCallee\n                    set ret.children = temp\n                    foreach item in p_arguments.children\n                        if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                            set item.tag = '@'\n                        _ lastCallee.children.push\n                            @ item\n\n                    $*\n                    var temp = [p_callee]\n                    if p_callee.children.length > 0\n                        var tempCallee = []\n                        foreach item in p_callee.children\n                            # loog 'item.tag', item.tag\n                            if item.tag == '._'\n                                _ temp.push\n                                    @ item\n                            else\n                                _ tempCallee.push\n                                    @ item\n                        set p_callee.children = tempCallee\n                    set ret.children = temp\n                    *$\n\n                $$ Was here 19/3/21\n                \n                if node.callee.type === 'FunctionExpression' && ret.tag === '_'\n                    # loog 'node.callee.type 2', node.callee.type, ret.tag\n                    set ret.tag = 'iife' // 9/1/19\n\n            if node.extra && node.extra.parenthesized == true && !ret.textified\n                var temp\n                    {\n                        @ tag '('\n                        [ children\n                            @ ret\n                set ret = temp\n\n            # loog 'CallExpression.exit.ret', ret\n\n        f( NewExpression, new;could-be-text\n            f_a_in_tag( arguments, arguments\n            f_p_temp( typeParameters, false, false, TSTypeParameterInstantiation\n            f_p_temp( callee\n\n            if p_callee.isText || p_callee.textified\n                set ret.name = p_callee.textified || p_callee.name\n            else\n                throw new Error('NewExpression.callee must be textual:' + p_callee.children[0].tag)\n\n            var argumentsNode = getChildByTag(ret, 'arguments')\n            set ret.children = []\n\n            # loog 'NewExpression.ret', ret\n            # loog 'NewExpression.p_typeParameters', p_typeParameters\n            # loog 'NewExpression.argumentsNode', argumentsNode\n\n            var tlist\n            if node.arguments && node.arguments.length > 0\n                # log 101\n                if !p_typeParameters\n                    set tlist = getTextList(argumentsNode, ', ')\n                # loog 'NewExpression.tlist', tlist\n                if tlist \n                    set ret.name += '(' + tlist + ')'\n                    set ret.textified = 'new ' + ret.name\n                    set ret.isText = true\n                else\n                    if p_typeParameters\n                        foreach item in p_typeParameters.children\n                            _ ret.children.push\n                                @ item\n                    foreach item in argumentsNode.children\n                        if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                            set item.tag = '@'\n                        _ ret.children.push\n                            @ item\n            else\n                # log 102\n                if p_typeParameters\n                    foreach item in p_typeParameters.children\n                        _ ret.children.push\n                            @ item\n                else\n                    set ret.textified = 'new ' + ret.name + '()'\n            # loog 'NewExpression.ret', ret\n\n        f( SequenceExpression, sequence\n            f_a( expressions, true, Expression \n            # A sequence expression, i.e., a comma-separated sequence of expressions.\n            foreach item in ret.children\n                if [$*'@expr', 27/3/21*$'@id', 'literal'].indexOf(item.tag) > -1\n                    set item.tag = 'set'\n\n        f( DoExpression, do\n            f_p( body, true, BlockStatement\n\n        f( TemplateLiteral, `lit\n            f_a_temp( quasis, true, TemplateElement\n            f_a_temp( expressions, true, Expression \n            # loog 'TemplateLiteral', model\n            var i = 0, j\n            for i = 0; i < p_expressions.children.length; i++\n                var q = p_quasis.children[i]\n                for j = 0; j < q.children.length; j++\n                    set item = q.children[j]\n                    _ ret.children.push(item)\n                var e = p_expressions.children[i]\n                # loog 'TemplateLiteral.e', e\n                if ['@expr', '@id', 'literal', 'set'].indexOf(e.tag) > -1\n                    set e.tag = '@'\n                _ ret.children.push(e)\n            if p_quasis.children[i] && p_quasis.children[i].children.length > 0\n                for j = 0; j < p_quasis.children[i].children.length; j++\n                    set item = p_quasis.children[i].children[j]\n                    _ ret.children.push(item)\n\n        f( TaggedTemplateExpression, _`\n            f_p_temp( tag, true, true, Expression\n            if isTextualNode(p_tag)\n                set ret.name = getNodeText(p_tag)\n            else\n                throw new Error('TaggedTemplateExpression.tag must be textual:' + JSON.stringify(node, null, 2))\n            f_p_temp( quasi, true, true, TemplateLiteral\n            foreach item in p_quasi.children\n                _ ret.children.push(item)\n\n        f( TemplateElement, +\n            # b( tail\n            var lines = node.value.raw.split('\\n')\n            foreach line in lines\n                if line[0] === ' '\n                    set line = '&nbsp;' + line.substr(1)\n                if line[line.length-1] === ' '\n                    set line = line.substr(0, line.length -1) + '&nbsp;'\n                _ ret.children.push\n                    {\n                        @ tag '+'\n                        @ name line + (( i < lines.length - 1) ? '&lf;' : '' )\n                        [ children\n            # f_p( value\n            # f_p_p( value, cooked, optional\n            # f_p_p( value, raw\n\n        f( ObjectPattern, {\n            # loog 'ObjectPattern enter options.mustBeText', options.mustBeText\n            f_a( properties, true, AssignmentProperty | RestElement \n            # loog 'wizzifiers.ts.ObjectPattern.ret', JSON.stringify(ret, null, 2)\n            if options.mustBeText\n                if setTextList(ret, ', ') && !!node.typeAnnotation == false\n                    set ret.textified = '{' + ret.textified + '}'\n                    if node.extra && node.extra.parenthesized == true\n                        set ret.textified = '(' + ret.textified + ')'\n                else\n                    throw new Error(\"ObjectPattern. Cannot textify node as requested: \" + JSON.stringify(node, null, 2))\n            else\n                f_p( typeAnnotation, false\n                if ret.children.length == 0\n                    if node.extra && node.extra.parenthesized == true\n                        set ret.name = ret.textified = '({})'\n                    else\n                        set ret.name = ret.textified = '{}'\n                else\n                    if node.extra && node.extra.parenthesized == true\n                        var temp\n                            {\n                                @ tag '('\n                                [ children\n                                    @ ret\n                        set ret = temp\n\n        f( ArrayPattern\n            f_a( elements, false, Pattern | null\n            if setTextList(ret, ', ')\n                set ret.textified = '[' + ret.textified + ']'\n                # loog '*** ArrayPattern len, textified: ', ret.children.length, ret.textified\n            else\n                throw new Error('ArrayPattern must be textual: ' + JSON.stringify(node, null, 2))\n\n        f( RestElement, ...$$;is-text\n            f_p(argument, true , Pattern\n            get_text_from_1_children(  )\n            f_p( typeAnnotation, false\n            $$ set ret.name = '...' + ret.name\n            $$ set ret.textified = ret.name\n            set ret.textified = '...' + ret.name\n            # loog 'RestElement', ret.tag, ret.name, ret.textified\n\n        f( AssignmentPattern, node.operator||'=';tag-is-var\n            f_p_temp( left, true, true, Pattern | Expression\n            f_p_temp( right, true, true, Expression\n            # loog 'AssignmentPattern.p_left', JSON.stringify(p_left, null, 2)\n            # loog 'AssignmentPattern.p_right', JSON.stringify(p_right, null, 2)\n            if isTextualNode(p_left)\n                set ret.name = getNodeText(p_left) \n                if isTextualNode(p_right)\n                    set ret.name += ' ' + (node.operator || '=') + ' ' + getNodeText(p_right)\n                else\n                    _ ret.children.push\n                        {\n                            @ tag node.operator || '='\n                            @ children [p_right]\n            else\n                _ ret.children.push\n                    @ p_left\n                _ ret.children.push\n                    @ p_right\n            # loog 'AssignmentPattern', JSON.stringify(ret, null, 2)\n\n        f( Class, class\n            f_p_name(id, Identifier | null\n            f_p_temp(superClass, false, true, Expression | null\n            if p_superClass\n                if isTextualNode(p_superClass)\n                    _ ret.children.push\n                        {\n                            @ tag 'super'\n                            @ name getNodeText(p_superClass)\n                else\n                    throw new Error('Class. superClass must be textual: ' + JSON.stringify(node, null, 2))\n            f_a( decorators, false, Decorator \n            f_p(body, true, ClassBody\n\n        f( ClassBody, skip\n            f_a( body, true, ClassMethod | ClassPrivateMethod | ClassProperty | ClassPrivateProperty \n\n        f( ClassMethod, node.kind;tag-is-var\n            f_p_tag(key, key, Expression\n            \n            # s( kind\n            # enum \"constructor\" | \"method\" | \"get\" | \"set\"\n            # b( computed\n\n            b( static\n            b( async\n            b( generator\n            \n            if node.accessibility\n                _ ret.children.push\n                    {\n                        @ tag ':' + node.accessibility\n                        @ name ''\n                        [ children\n            \n            f_a( decorators, false, Decorator \n            f_a_in_tag( params, params\n            _ processParams(ret)\n            f_p_temp(returnType, false)\n            if p_returnType\n                set p_returnType\n                    {\n                        @ tag ':return'\n                        [ children\n                            @ p_returnType\n                _ ret.children.push(p_returnType)\n\n            f_p( body, true, Statement\n            set ret.tag = ret.tag == 'constructor' ? 'ctor' : (ret.tag == 'method' ? 'm' : ret.tag)\n            _ setNameFromChildByTag(ret, 'key', true)\n            if ret.tag === 'ctor'\n                set ret.name = ''\n            elif node.computed\n                set ret.name = '[' + ret.name + ']'\n            \n            # VIA\n                _ replaceChildrenOfChildWhenText\n                    @ ret\n                    @ getChildPosByTag(ret, 'params')\n                    @ 'param'\n\n        f( ClassPrivateMethod, node.kind;tag-is-var\n            f_p( key, true, PrivateName\n            # s( kind, \"method\" | \"get\" | \"set\"\n            b( static\n            f_a( decorators, false, Decorator \n            f_a_in_tag( params, params\n            \n            set ret.tag = ret.tag == 'method' ? 'm' : ret.tag\n            _ processParams(ret)\n            f_p_temp(returnType, false)\n            if p_returnType\n                set p_returnType\n                    {\n                        @ tag ':return'\n                        [ children\n                            @ p_returnType\n                _ ret.children.push(p_returnType)\n            f_p( body, true, Statement\n\n        f( ClassProperty, p\n            f_p_name(key, Expression\n            f_p_temp(value, false, true, Expression\n            f_p_temp(typeAnnotation, false, true, ?TypeAnnotation\n\n            if node.optional\n                set ret.name = ret.name + '?'\n\n            b( static\n            if node.readonly\n                _ ret.children.push\n                    {\n                        @ tag ':readonly'\n                        @ name ''\n                        [ children\n            if node.accessibility\n                _ ret.children.push\n                    {\n                        @ tag ':' + node.accessibility\n                        @ name ''\n                        [ children\n            \n            $*\n            if p_value && p_value.tag === '=>'\n                set ret.tag = p_value.tag\n                if p_typeAnnotation\n                    _ ret.children.push\n                        {\n                            @ tag ':return'\n                            @ name ''\n                            @ children [p_typeAnnotation]\n                    foreach item in p_value.children\n                        _ ret.children.push\n                            @ item\n                else\n                    set ret.children = p_value.children\n            else\n            *$\n            if p_typeAnnotation\n                _ ret.children.push\n                    @ p_typeAnnotation\n            if node.computed\n                set ret.name = '[' + ret.name + ']'\n            elif p_value && p_value.tag\n                if ['@id', '@expr', 'literal'].indexOf(p_value.tag) > -1\n                    set p_value.tag = '='\n                _ ret.children.push\n                    @ p_value\n            else\n                # do nothing\n            f_a( decorators, false, Decorator \n\n        f( ClassPrivateProperty, p\n            f_p( key, true, PrivateName\n            f_p( value, false, Expression\n            b( static\n            f_a( decorators, false, Decorator \n\n        f( ClassDeclaration, class\n            f_p_name( id, Identifier\n            b( abstract, :abstract\n            f_p( typeParameters, false, ?TypeParameterInstantiation\n            f_p_temp(superClass, false, true, Expression | null\n            f_p_temp(superTypeParameters, false, true, TypeParameterInstantiation | null\n            var p_super\n            if p_superClass\n                if isTextualNode(p_superClass)\n                    set p_super\n                        {\n                            @ tag 'super'\n                            @ name getNodeText(p_superClass)\n                            [ children\n                    _ ret.children.push\n                        @ p_super\n                elif p_superClass.text === 'null'\n                    # OK\n                else\n                    throw new Error('Class. superClass must be textual: ' + JSON.stringify(node, null, 2))\n            if p_superTypeParameters\n                if p_super\n                    foreach item in p_superTypeParameters.children\n                        if item.tag !== ':param'\n                            _ p_super.children.push\n                                {\n                                    @ tag ':param'\n                                    @ name ''\n                                    [ children\n                                        @ item\n                        else\n                            _ p_super.children.push\n                                @ item\n                else\n                    set p_superTypeParameters.tag = ':super-type-params'\n                    _ ret.children.push\n                        @ p_superTypeParameters\n            f_a_temp( implements, false\n            if p_implements\n                foreach item in p_implements.children\n                    set item.tag = ':implements'\n                    _ ret.children.push\n                        @ item\n            f_a( decorators, false, Decorator \n            f_p( body )\n\n            if node.declare\n                set ret\n                    {\n                        @ tag ':declare'\n                        @ name ''\n                        [ children\n                            @ ret\n\n        f( ClassExpression, class\n            f_p_name( id, Identifier\n            f_p_temp(superClass, false, true, Expression | null\n            f_p_temp(superTypeParameters, false, true\n            if p_superClass\n                if isTextualNode(p_superClass)\n                    # loog 'p_superTypeParameters', p_superTypeParameters\n                    var superchildren = p_superTypeParameters ? p_superTypeParameters.children : []\n                    _ ret.children.push\n                        {\n                            @ tag 'super'\n                            @ name getNodeText(p_superClass)\n                            @ children superchildren\n                else\n                    throw new Error('Class. superClass must be textual: ' + JSON.stringify(node, null, 2))\n            f_p( body )\n\n        f( MetaProperty, meta\n            f_p( meta, true, Identifier\n            f_p( property, true, Identifier\n            get_text_from_2_children( c1 + '.' + c2 )\n\n        f( ModuleDeclaration, module\n            # A module `import` or `export` declaration.\n\n        $* interface\n        f( ModuleSpecifier\n            f_p( local, true, Identifier\n            # A specifier in an import or export declaration.\n        *$\n\n        f( ImportDeclaration, import\n            f_a( specifiers, true, ImportSpecifier | ImportDefaultSpecifier | ImportNamespaceSpecifier\n            f_p_tag( source, from\n            # An import declaration, e.g., `import foo from \"mod\"`.\n            #\n            var xdefault = getChildByTag(ret, 'default')\n            if xdefault\n                set ret.name = xdefault.name\n                _ removeChildByTag(ret, 'default')\n            if ret.children.length == 1 && ret.children[0].tag === 'from'\n                if ret.name && ret.name.length > 0\n                    set ret.name += ' from'\n                set ret.name += ' '\t+ ret.children[0].name\n                _ removeChildByTag(ret, 'from')\n            if node.importKind === 'type'\n                set ret.tag = ':import-type'\n\n        f( ImportSpecifier, @\n            f_p( local, true, Identifier\n            f_p_name( imported, true, Identifier\n\n            # f_p( local, true, Identifier\n            # An imported variable binding, e.g., `{foo}` in `import {foo} from \"mod\"` or `{foo as bar}` in `import {foo as bar} from \"mod\"`. \n            # The `imported` field refers to the name of the export imported from the module. \n            # The `local` field refers to the binding imported into the local module scope. \n            # If it is a basic named import, such as in `import {foo} from \"mod\"`, both `imported` and `local` are equivalent `Identifier` nodes in this case an `Identifier` node representing `foo`. \n            # If it is an aliased import, such as in `import {foo as bar} from \"mod\"`, the `imported` field is an `Identifier` node representing `foo`, \n            # and the `local` field is an `Identifier` node representing `bar`.\n            \n            if ret.children[0].name !== ret.name\n                set ret.children[0].tag = 'as'\n            else\n                set ret.children = []\n\n            if node.importKind === 'type'\n                set ret.tag = ':type'\n\n        f( ImportDefaultSpecifier, default\n            f_p_name( local, Identifier\n            # A default import specifier, e.g., `foo` in `import foo from \"mod.js\"`.\n\n        f( ImportNamespaceSpecifier, as \n            f_p( local, true, Identifier\n            # A namespace import specifier, e.g., `* as foo` in `import * as foo from \"mod.js\"`.\n            get_text_from_1_children()\n\n        f( ExportNamedDeclaration, export\n            f_p( declaration, false, Declaration | null\n            f_a( specifiers, true, ExportSpecifier\n            f_p_tag( source, from\n\n\n            var xdefault = getChildByTag(ret, 'default')\n            if xdefault\n                set ret.name = xdefault.name\n                _ removeChildByTag(ret, 'default')\n            \n            # An export named declaration, e.g., `export {foo, bar}`, `export {foo} from \"mod\"`, `export var foo = 1` or `export * as foo from \"bar\"`.\n            # _Note, Having `declaration` populated with non-empty `specifiers` or non-null `source` results in an invalid state._\n            \n            if node.exportKind === 'type'\n                # VIA 18/03/21 set ret.tag = ':export-type'\n\n        f( ExportSpecifier, @\n            f_p( exported, true, Identifier\n            f_p_name( local, true, Identifier\n            \n            # An exported variable binding, e.g., `{foo}` in `export {foo}` or `{bar as foo}` in `export {bar as foo}`. The `exported` field refers to the name exported in the module. \n            # The `local` field refers to the binding into the local module scope. If it is a basic named export, such as in `export {foo}`, both `exported` and `local` are equivalent `Identifier` nodes \n            # in this case an `Identifier` node representing `foo`. \n            # If it is an aliased export, such as in `export {bar as foo}`, the `exported` field is an `Identifier` node representing `foo`, \n            # and the `local` field is an `Identifier` node representing `bar`.\n            \n            if ret.children[0].name !== ret.name\n                set ret.children[0].tag = 'as'\n            else\n                set ret.children = []\n\n        f( ExportDefaultSpecifier, default\n            f_p_temp( exported, true, true, OptFunctionDeclaration | OptClassDeclaration | Expression\n            if isTextualNode(p_exported)\n                set ret.name = getNodeText(p_exported)\n            else\n                _ ret.children.push\n                    @ p_exported\n\n        f( ExportDefaultDeclaration, export-default\n            # An export default declaration, e.g., `export default function () {}` or `export default 1`.\n            f_p_temp( declaration, true, true, OptFunctionDeclaration | OptClassDeclaration | Expression\n            if isTextualNode(p_declaration)\n                set ret.name = getNodeText(p_declaration)\n            else\n                _ ret.children.push\n                    @ p_declaration\n\n        f( ExportNamespaceSpecifier, as\n            f_p_temp( exported, true, true, OptFunctionDeclaration | OptClassDeclaration | Expression\n            if isTextualNode(p_exported)\n                set ret.name = getNodeText(p_exported)\n            else\n                _ ret.children.push\n                    @ p_exported\n        \n        f( ExportAllDeclaration, export\n            set ret.name = '*'\n            f_p_tag( source, from\n\n        f( CommentBlock, #\n            var values = verify.replaceAll(node.value, '\\r\\n', '\\n').split('\\n')\n            # loog 'options.replaceds', options.replaceds\n            foreach value in values\n                # var v = codeReplacer.restore(value, options.replaceds)\n                _ ret.children.push\n                    {\n                        @ tag '#'\n                        @ name value\n                        [ children\n        \n        f( CommentLine, #\n            # loog 'options.replaceds', options.replaceds\n            # var v = codeReplacer.restore(node.value, options.replaceds)\n            set ret.name = node.value\n\n        f( JSXAttribute, @\n            _ options.stateAST.push\n                @ 'JSXAttribute'\n            f_p_temp( name, true, true, JSXnamespacedName\n            f_p_temp( value, false, true, JSXElement | JSXFragment | StringLiteral | JSXExpressionContainer\n\n            if isTextualNode(p_name)\n                set ret.name = getNodeText(p_name)\n            else\n                throw new Error('JSXAttribute.name must be textual:' + JSON.stringify(node, null, 2))\n\n            # loog 'JSXAttribute.p_value', p_value, isTextualNode(p_value)\n\n            if p_value\n                if isTextualNode(p_value)\n                    set ret.name += ' ' + getNodeText(p_value)\n                elif p_value != null && p_value.text !== 'null'\n                    _ ret.children.push\n                        @ p_value\n            _ options.stateAST.pop\n\n        f( JSXClosingElement, jsx-close\n            # name JSXIdentifier | JSXMemberExpression\n\n        f( JSXElement, jsx-element\n            f_p_temp( openingElement, true, true, JSXOpeningElement\n            # f_p( closingElement, true, JSXClosingElement\n            f_a_temp( children, true, JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment\n            # loog 'p_openingElement', p_openingElement\n            # loog 'p_children', p_children\n            if p_openingElement.name && p_openingElement.name.length > 0\n                var char = p_openingElement.name[0]\n                if char == char.toUpperCase() || html_supported_tags.indexOf(p_openingElement.name) < 0\n                    set ret.tag = '< ' + p_openingElement.name\n                else\n                    set ret.tag = p_openingElement.name\n                set ret.children = p_openingElement.children\n            else\n                set ret.tag = '<'\n                set ret.children = p_openingElement.children\n            \n            # loog 'JSXElement.ret', ret\n            var\n                decl isStyle = ret.tag === 'style'\n            \n            foreach item in p_children.children\n                # loog 'JSXElement.children.item', item\n                if !(item.tag === '+' && item.name.trim().length == 0)\n                    if isStyle\n                        # loog 'isStyle', isStyle, item.children\n                        foreach c in item.children\n                            if c.tag === '`lit'\n                                set ret.tag = \"style-jsx\"\n                                _ options.wizziIncludes.push\n                                    {\n                                        @ kind 'css'\n                                        @ node ret\n                                        @ literal getLiteral(c)\n                                # loog 'JSXElement.children.item.lit', c, getLiteral(c)\n                        if ret.tag !== \"style-jsx\"\n                            _ ret.children.push\n                                @ item\n                    else\n                        _ ret.children.push\n                            @ item\n                            \n            if ret.tag === \"style-jsx\"\n                var children = ret.children\n                set ret.children = []\n                foreach item in children\n                    if item.tag === '{'\n                    elif item.tag === '@' && item.name === 'jsx'\n                    elif item.tag === '@' && item.name === 'global'\n                        _ ret.children.push\n                            {\n                                @ tag 'global'\n                                [ children\n                    else\n                        _ ret.children.push\n                            @ item\n            elif [\"style\",\"title\"].indexOf(ret.tag) > -1\n                set ret.name = ret.tag\n                set ret.tag = '<'\n\n        f( JSXEmptyExpression, skip\n            f_a( innerComments\n\n        f( JSXExpressionContainer\n            #\n                _ options.stateAST.push\n                    @ 'JSXExpressionContainer'\n            f_p_temp( expression\n            # loog 'JSXExpressionContainer.p_expression', p_expression, isTextualNode(p_expression)\n            if isTextualNode(p_expression)\n                set ret.tag = '+'\n                set ret.name = '{' + getNodeText(p_expression) + '}'\n                set ret.textified = ret.name\n            else\n                # loog 'JSXExpressionContainer.options.stateAST', options.stateAST\n                # loog 'JSXExpressionContainer.options.p_expression', p_expression\n                # loog 'options.stateAST[options.stateAST.length-1]', options.stateAST[options.stateAST.length-1]\n                $* 24/3/21 waiting for BIG damage but we must manage this*$\n                set p_expression.textified = null\n                if options.stateAST[options.stateAST.length-1] === 'JSXAttribute'\n                    var __skip = true\n                    _ parent.children.push\n                        @ p_expression\n                else\n                    set ret.tag = '{'\n                    _ ret.children.push\n                        @ p_expression\n            #\n                _ options.stateAST.pop\n\n        f( JSXSpreadChild\n            f_p_temp( expression, true, true, Expression\n            set ret.tag = p_expression.tag\n            set ret.name = '...' + p_expression.name\n            set ret.children = p_expression.children\n    \n        f( JSXIdentifier, jsx-ident;is-text\n            name( name\n\n        f( JSXMemberExpression\n            f_p(object, true, JSXMemberExpression | JSXIdentifier\n            f_p(property, true, JSXIdentifier\n            get_text_from_2_children( c1 + '.' + c2 )\n\n        f( JSXNamespacedName\n            # namespace JSXIdentifier\n            # name JSXIdentifier\n\n        f( JSXOpeningElement, jsx-open\n            f_p_temp( name, true, true, JSXIdentifier | JSXMemberExpression\n            \n            # selfClosing boolean\n\n            # loog 'JSXOpeningElement p_name', p_name\n            if isTextualNode(p_name)\n                set ret.name = getNodeText(p_name)\n            elif isTextualCommentedNode(p_name)\n                set ret.name = getNodeText(p_name)\n                set ret.children = p_name.children\n            else\n                foreach item in p_name.children\n                    if item.tag === 'jsx-ident'\n                        set ret.name = item.name\n                    else\n                        _ ret.children.push\n                            @ item\n            \n            f_p_temp( typeParameters, false, true, TSTypeParameterInstantiation\n            if p_typeParameters\n                foreach item in p_typeParameters.children\n                    _ ret.children.push\n                        @ item\n            # TODO ??? ts here ???\n            f_a_temp( parameters, parameters, TypeParameterInstantiation | TSTypeParameterInstantiation\n            if p_parameters\n                foreach item in p_parameters.children\n                    _ ret.children.push\n                        @ item\n            \n            f_a_temp( attributes, attributes, JSXAttribute | JSXSpreadAttribute\n            if p_attributes\n                foreach item in p_attributes.children\n                    _ ret.children.push\n                        @ item\n\n        f( JSXSpreadAttribute, @\n            f_p( argument, true, Expression\n            get_text_from_1_children( '{...' + c1 + \"}\" )\n\n        f( JSXText, +\n            # if node.value.trim().length == 0 || node.value === '\\n' // 11/1/19\n            var nametrimmed = node.value.trim()\n            if nametrimmed == 0\n                set ret = null\n            else\n                set ret.name = verify.replaceAll(nametrimmed, '\\n', '&lf;')\n                $* 24/3/21\n                if ret.name[0] === ' '\n                    set ret.name = '&nbsp;' + ret.name.substr(1)\n                if ret.name[ret.name.length-1] === ' '\n                    set ret.name = ret.name.substr(0, ret.name.length-1) + '&nbsp;'\n                *$\n\n        f( JSXFragment, <\n            # openingFragment JSXOpeningFragment\n            # closingFragment JSXClosingFragment\n            # children JSXText | JSXExpressionContainer | JSXSpreadChild | JSXElement | JSXFragment\n            set ret.name = 'React.Fragment'\n            f_a( children )\n\n        f( JSXOpeningFragment, fragment-open\n            # aliases: [\"JSX\", \"Immutable\"],\n\n        f( JSXClosingFragment, fragment-close\n            # aliases: [\"JSX\", \"Immutable\"]\n\n        $include flow\n        $include typescript"
                }
            ]
        },
        {
            "name": "wizzi.plugin.vtt",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vtt",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vtt\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.vtt/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vtt\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vtt",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "vtt"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vtt\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.vtt-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vtt\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vtt",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "vtt"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "vtt",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vtt\\.wizzi-override\\lib\\wizzi\\schemas\\vtt.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema vtt\n\n\texport-to json\n\n\t# A schema modeling the Video Text Tracks specification\n\t# mime text/vtt \n\t# https://www.w3.org/TR/webvtt1/\n\n\te_tag( comment, #\n\t\tr comment/s\n\t\n\te vtt : comment\n\t\t# The root element\n\t\tis-root\n\t\tr style/s\n\t\tr region/s\n\t\tr vttCue/s\n\n\te_tag( vttCue, cue, comment\n\t\t\n\t\t# wzName : hh.ss hh.ss\n\t\t#          meaning start time --> end time\n\t\t# ittf\n\t\t#   cue 1 4\n\t\t# vtt\n\t\t#   00.01.000 --> 00.04.000\n\t\t\n\t\ta id\n\n\t\ta_tag( startTime, start\n\t\t\t# start time is also declared in the wzName \n\t\t\n\t\ta_tag( endTime, end\n\t\t\t# end time is also declared in the wzName\n\n\t\ta direction\n\t\t\trestrict\n\t\t\t\tenum rl\n\t\t\t\tenum lr\n\t\t\n\t\ta_tag( lineAlign, line-align\n\t\t\trestrict\n\t\t\t\tenum start\n\t\t\t\tenum center\n\t\t\t\tenum end\n\t\t\n\t\ta_tag( positionAlign, pos-align\n\t\t\trestrict\n\t\t\t\tenum line-left\n\t\t\t\tenum center\n\t\t\t\tenum line-right\n\t\t\t\tenum auto\n\t\t\n\t\ta align\n\t\t\trestrict\n\t\t\t\tenum start\n\t\t\t\tenum center\n\t\t\t\tenum end\n\t\t\t\tenum left\n\t\t\t\tenum right\n\n\t\ta position\n\t\t\t# The position defines the indent of the cue box in the direction defined by the writing direction.\n\t\t\t# wzName : a number from 0 to 100 (a percentage) or \"auto\".\n\t\t\n\t\ta size\n\t\t\t# A number giving the size of the cue box, to be interpreted as a percentage of the video, as defined by the writing direction.\n\t\t\n\t\ta line\n\t\t\t# The line defines positioning of the cue box.\n\t\t\t# The line offsets the cue box from the top, the right or left of the video viewport as defined by the writing direction, the snap-to-lines flag, or the lines occupied by any other showing tracks.\n\t\t\t# The line is set either as a number of lines, a percentage of the video viewport height or width, or as the special value auto, which means the offset is to depend on the other showing tracks.\n\n\t\ta region\n\t\t\t# The id of the referenced region\n\n\t\tr cueText/s\n\t\t$$ r meta/s\n\n\t\t# ID Example\n\t\t# ittf\n\t\t#   cue 3 5\n\t\t#       id 123\n\t\t#       + Hello\n\t\t# vtt\n\t\t#   123\n\t\t#   00.03.000 --> 00.05.000\n\t\t#   Hello\n\n\n\te_tag( componentClass, ., comment\n\n\te_tag( cueText, +, comment\n\t\t# Simple cue text in one line (or auto wrapped single line when longer)\n\t\t# ittf\n\t\t#   c 1 4\n\t\t#       + Never drink liquid nitrogen.\n\t\t# vtt\n\t\t#   00:1.000 --> 00:04.000\n\t\t#   Never drink liquid nitrogen.\n\t\tr componentClass/es\n\t\tr cueText/s\n\n\t$include vtt/text\n\t$include vtt/region\n\t$include vtt/style\n\t\n\n"
                }
            ],
            "artifacts": [
                {
                    "name": "vtt/document",
                    "schema": "vtt",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vtt\\.wizzi-override\\lib\\artifacts\\vtt\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.vtt',\n            name: 'document',\n            schema: 'vtt',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n        $append main\n            _ md.vtt\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        async-md( vtt\n            _ ctx.w( 'WEBVTT' )\n            _ ctx.w\n            _ writeComments\n                @ ctx\n                @ model\n            _md_gen_items( styles\n                _md_gen_items( regions\n                    _md_gen_items( vttCues\n                        r_cb()\n\n        async-md( vttCue\n            _ writeComments\n                @ ctx\n                @ model\n            _ writeCueTime( ctx, model )\n            if typeof model.region !== 'undefined'\n                _ ctx.write( ' region:' + model.region)\n            if typeof model.direction !== 'undefined'\n                _ ctx.write( ' vertical:' + model.direction)\n            if typeof model.line !== 'undefined'\n                _ ctx.write( ' line:' + model.line)\n            if typeof model.position !== 'undefined'\n                _ ctx.write( ' position:' + model.position)\n            if typeof model.size !== 'undefined'\n                _ ctx.write( ' size:' + model.size)\n            if typeof model.align !== 'undefined'\n                _ ctx.write( ' align:' + model.align)\n            if typeof model.lineAlign !== 'undefined'\n                _ ctx.write( ' line-align:' + model.lineAlign)\n            if typeof model.positionAlign !== 'undefined'\n                _ ctx.write( ' position-align:' + model.positionAlign)\n            _ ctx.w\n            _md_gen_items( cueTexts\n                _ ctx.w\n                r_cb()\n\n        async-md( cueText\n            _ ctx.write( model.wzName )\n            var saveIsInsideText = !!ctx.isInsideText\n            set ctx.isInsideText = true\n            _md_gen_items( cueTexts\n                if saveIsInsideText == false\n                    _ ctx.w\n                set ctx.isInsideText = saveIsInsideText\n                r_cb()\n\n        async-md( p\n            _ ctx.write( '- ' + model.wzName )\n            var saveIsInsideText = !!ctx.isInsideText\n            set ctx.isInsideText = true\n            _md_gen_items( cueTexts\n                if saveIsInsideText == false\n                    _ ctx.w\n                set ctx.isInsideText = saveIsInsideText\n                r_cb()\n        \n        async-md( u\n            _ writeCueText\n                @ ctx\n                @ model\n                @ 'u'\n                @ callback\n\n        async-md( i\n            _ writeCueText\n                @ ctx\n                @ model\n                @ 'i'\n                @ callback\n\n        async-md( b\n            _ writeCueText\n                @ ctx\n                @ model\n                @ 'b'\n                @ callback\n\n        async-md( c\n            _ writeCueText\n                @ ctx\n                @ model\n                @ 'c'\n                @ callback\n\n        async-md( voiceSpan\n            _ writeCueText\n                @ ctx\n                @ model\n                @ 'v'\n                @ callback\n\n        async-md( lang\n            _ writeCueText\n                @ ctx\n                @ model\n                @ 'lang'\n                @ callback\n\n        async-md( time\n            _ ctx.write( '<' + tag )\n            _ ctx.write\n                _ formatTime( model.wzName )\n            _ ctx.w('<')\n            r_cb()\n\n        async-md( componentClass\n            _ ctx.write( '.' + model.wzName )\n            r_cb()\n        \n        $include style\n        $include region\n\n        function writeComments\n            param ctx\n            param model\n            if model.comments.length == 1\n                _ ctx.w( 'NOTE ' + model.comments[0].wzName )\n                _ ctx.w\n            if model.comments.length > 1\n                _ ctx.w( 'NOTE' )\n                foreach item in model.comments\n                    _ ctx.w( item.wzName )\n                _ ctx.w\n        \n        function writeCueText\n            param ctx\n            param model\n            param tag\n            param callback\n\n            _ ctx.write( '<' + tag )\n            _md_gen_items( componentClasses\n                _ ctx.write( '>' + model.wzName )\n                var saveIsInsideText = !!ctx.isInsideText\n                set ctx.isInsideText = true\n                _md_gen_items( cueTexts\n                    _ ctx.write( '</' + tag + '>' )\n                    if saveIsInsideText == false\n                        _ ctx.w\n                    set ctx.isInsideText = saveIsInsideText\n                    r_cb()\n\n        function writeCueTime\n            param ctx\n            param model\n            \n            if typeof model.id !== 'undefined'\n                _ ctx.w( model.id )\n            var ss\n                _ model.wzName.split(' ').filter\n                    function\n                        param el\n                        return el != null\n\n            _ ctx.write\n                _ formatTime( ss.length == 1 ? 0 : ss[0] )\n            _ ctx.write\n                @ ' --> '\n            _ ctx.write\n                _ formatTime( ss.length == 1 ? ss[0] : ss[1] )\n\n        function formatTime\n            param t\n            var ss = t.split(':')\n            if ss.length == 1\n                return '00:00:' + zeroPad(ss[0], 2) + '.000'\n            elif ss.length == 2\n                return '00:' + zeroPad(ss[0], 2) + ':' + zeroPad(ss[1], 2) + '.000'\n            elif ss.length == 3\n                return zeroPad(ss[0], 2) + ':' + zeroPad(ss[1], 2) + ':' + zeroPad(ss[2], 2)\n            else\n                return zeroPad(ss[0], 2) + ':' + zeroPad(ss[0], 2) + ':' + zeroPad(ss[1], 2) + ':' + zeroPad(ss[2], 3)\n                \n        function zeroPad\n            param n\n            param len\n            set n = parseInt(n)\n            if len == 2\n                return n > 9 ? n : '0' + n\n            else\n                return n > 99 ? n : n > 9 ? '0' + n : '00' + n\n\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n\n\n\n\n"
                }
            ],
            "transformations": [
                {
                    "name": "vtt/extended",
                    "schema": "vtt",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vtt\\.wizzi-override\\lib\\artifacts\\vtt\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.vtt',\n            name: 'extended',\n            schema: 'vtt',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.vue",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vue",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vue\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.vue/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vue\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vue",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "vue"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vue\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.vue-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vue\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vue",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "vue"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "vue",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vue\\.wizzi-override\\lib\\wizzi\\schemas\\vue.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema vue\n\n\t# NO export-to json\n\n\t# A schema modeling the VUE progressive javaScript framework\n\t# https://vuejs.org/\n\t#\n\t# Includes the wizzi schemas: html, js, ts, css\n\n\t# Preprocess the mTree before loading the wizzi model\n\tmtree-is-preprocessed\n\n\te_tag( comment, #\n\t\tr comment/s\n\n\te element : comment\n\t\t# a generic vue element (tag)\n\t\ttag <\n\t\tr element/s\n\t\n\te vue : element\n\t\t# The root element\n\t\tis-root\n\n\te htmlInclude : element\n\t\ttag ::template\n\t\tinclude html\n\n\te jsInclude : element\n\t\ttag ::script\n\t\tinclude js module\n\n\te tsInclude : element\n\t\ttag ::script-ts\n\t\tinclude ts module\n\n\te cssInclude : element\n\t\ttag ::style\n\t\ta_flag( scoped )\n\t\tinclude css\n\n\n\n\n"
                }
            ],
            "artifacts": [
                {
                    "name": "vue/document",
                    "schema": "vue",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vue\\.wizzi-override\\lib\\artifacts\\vue\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.vue',\n            name: 'document',\n            schema: 'vue',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n            var included_writers = require('./included_writers')\n        $append main\n            _ md.vue\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        async-md( vue )\n            _ writeComments\n                @ ctx\n                @ model\n            _ md.genItems\n                @ model.elements\n                @ ctx\n                {\n                    @ indent true\n                a_cb()\n                    r_cb()\n\n        async-md( htmlInclude\n            if model.get_html\n                _ included_writers.writeIncludeHtml\n                    @ ctx\n                    @ model\n                    @ callback\n            else\n                _ callback\n                    new Error('::template tag has no html element')\n\n        async-md( jsInclude\n            if model.get_js\n                _ included_writers.writeIncludeJs\n                    @ ctx\n                    @ model\n                    @ callback\n            else\n                _ callback\n                    new Error('::script tag has no module element')\n        \n        async-md( tsInclude\n            if model.get_ts\n                _ included_writers.writeIncludeTypescript\n                    @ ctx\n                    @ model\n                    @ callback\n            else\n                _ callback\n                    new Error('::script-ts tag has no module element')\n\n        async-md( cssInclude\n            if model.get_css\n                _ included_writers.writeIncludeCss\n                    @ ctx\n                    @ model\n                    @ callback\n            else\n                _ callback\n                    new Error('::style tag has no css element')\n\n        function writeComments\n            param ctx\n            param model\n            if model.comments.length == 1\n                _ ctx.w( '<!-- ' + model.comments[0].wzName + ' -->')\n            if model.comments.length > 1\n                _ ctx.w( '<!--' )\n                foreach item in model.comments\n                    _ ctx.w( item.wzName )\n                _ ctx.w( '-->' )\n\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        \n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        \n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n\n\n\n\t\n"
                }
            ],
            "transformations": [
                {
                    "name": "vue/extended",
                    "schema": "vue",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vue\\.wizzi-override\\lib\\artifacts\\vue\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.vue',\n            name: 'extended',\n            schema: 'vue',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ],
            "wizzifiers": [
                {
                    "name": "vue",
                    "schema": "vue",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.vue\\.wizzi-override\\lib\\wizzifiers\\vue\\wizzifier.js.ittf",
                    "content": "module\n    $\n        var schemaName = 'vue';\n    kind es6\n    basewizzifier()\n        $append imports\n            var vue_parser = require('vue/language/parser')\n            var cleanAST = require('./cleanAST')\n            function parseInternal\n                param tobeWizzified\n                param options\n                param callback\n                var syntax\n                try\n                    set syntax\n                         _ vue_parser.parse(tobeWizzified)\n                    _ cleanAST(syntax)\n                catch ex\n                    return\n                        _ callback\n                            @ ex\n                return\n                    _ callback\n                        @ null\n                        @ syntax\n        var format\n            function\n                param parent\n                param ast\n                param options\n                if !ast\n                    throw new Error('missing ast. parent is: ' + util.inspect(parent, { depth: 2 }))\n                if parent === null\n                    if options.starter\n                        set options.starter = false\n                    elif options.returnText\n                        # ok\n                    else\n                        _ showstack(options)\n                        throw new Error('parent is null.' + util.inspect(ast, 4))\n                if options.verbose\n                    info 'ast.kind', ast.kind\n                var kind = ast.kind === 'arguments' ? 'xarguments' : ast.kind\n                var formatter = format[kind]\n                if formatter\n                    _ options.stack.push(ast)\n                    var result = formatter(parent, ast, options)\n                    _ options.stack.pop()\n                    return result\n                else\n                    throw new Error('no formatter for kind: ' + ast.kind)\n        function wizzify\n            param tobeWizzified\n            param options\n            param callback\n            set options = options || {};\n            set options.input = tobeWizzified\n            set options.stack = []\n            set options.formatTextNodes = []\n            set options.verbose = true\n            _ parseInternal\n                @ tobeWizzified\n                @ options\n                a_cb( syntax )\n                    log JSON.stringify(syntax, null, 2)\n                    var root\n                        {\n                            @ tag '${schemaName}'\n                            [ children\n                    _ format(root, syntax, options)\n                    return\n                        _ callback\n                            @ null\n                            @ root\n        $include helper_functions\n        function isKnownType\n            param type\n            return ['Int', 'Float', 'Boolean', 'String'].indexOf(type) > -1\n        function getTypeName\n            param type\n            return isKnownType(type) ? type.toLowerCase() : type\n        f( Name, name )\n            # name( value )\n            #\n                # loog 'Name.tag', ret.tag\n                # loog 'Name.name', ret.name\n                # loog 'Name.textified', ret.textified\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.wzjob",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzjob",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzjob\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.wzjob/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzjob\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzjob",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "wzjob",
                            "wfjob"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzjob\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.wzjob-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzjob\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzjob",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "wzjob",
                            "wfjob"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "wzjob",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzjob\\.wizzi-override\\lib\\wizzi\\schemas\\wzjob.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema wzjob\n    \n    preserve-tags true\n    mtree-is-preprocessed true\n    unknown-element-replacer text\n    \n    e node\n        r node/s\n    \n    e wzjob : node\n        is-root\n    \n    \n"
                },
                {
                    "name": "wfjob",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzjob\\.wizzi-override\\lib\\wizzi\\schemas\\wfjob.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema wfjob\r\n\t\r\n\t# A schema modeling a wizzi factory job.\r\n\r\n\texport-to json\r\n\t\r\n\te wfjob\r\n\t\t\r\n\t\t# The root element of the wfjob schema.\r\n\t\t\r\n\t\ta_tag( modelsBaseFolder, models-base-folder )\r\n\t\t\t# The base path for the source models used by this \"wfjob\".\r\n\t\t\r\n\t\ta_tag( destBaseFolder, dest-base-folder )\r\n\t\t\t# The base folder path for the generated artifacts.\r\n\r\n\t\ta title\r\n\t\t\t# A short description of the job.\r\n\r\n\t\tr comment/s\r\n\t\tr require/s\r\n\t\tr model/s\r\n\t\tr line/s\r\n\t\tr production/s\r\n\t\tr execFile/s\r\n\r\n\te comment\r\n\t\t# A comment line for describing job items.\r\n\t\ttag #\r\n\r\n\te require\r\n\r\n\t\t# Requires a WizziFactoryPackage.\r\n\t\t# The IttfNodeValue is the package name. \r\n\t\t# If the package is not globally installed must be a fully qualified path.\r\n\r\n\t$include wfjob/model\r\n\t\r\n\t$include wfjob/artifact\r\n\r\n\t$include wfjob/production\r\n\r\n\t$include wfjob/exec"
                }
            ],
            "artifacts": [
                {
                    "name": "wfjob/document",
                    "schema": "wfjob",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzjob\\.wizzi-override\\lib\\artifacts\\wfjob\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.wzjob',\n            name: 'document',\n            schema: 'wfjob',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n        $append main\n            _ md.wfjob\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        async-md( wfjob )\n            xml-dump-el-open( wfjob )\n            xml-dump-attr( modelsBaseFolder )\n            xml-dump-attr( destBaseFolder )\n            xml-dump-attr( title, last )\n            _md_gen_items( requires, indent )\n                _md_gen_items( models, indent )\n                    _md_gen_items( lines, indent )\n                        _md_gen_items( productions, indent )\n                            _md_gen_items( execFiles, indent )\n                                _md_gen_items( comments, indent )\n                                    xml-dump-el-close( wfjob )\n                                    r_cb()\n\n        async-md( require )\n            xml-dump-el-open( require )\n            _ ctx.w('>')\n            xml-dump-el-close( require )\n            r_cb()\n\n        async-md( model )\n            xml-dump-el-open( model )\n            xml-dump-attr( src )\n            xml-dump-attr( schema )\n            xml-dump-attr( format )\n            xml-dump-attr( dumpFile )\n            xml-dump-attr( exportName, last )\n            _md_gen_items( modelRefs, indent )\n                _md_gen_items( comments, indent )\n                    xml-dump-el-close( model )\n                    r_cb()\n        \n        async-md( modelRef )\n            xml-dump-el-open( modelRef )\n            xml-dump-attr( exportName, last )\n            _md_gen_items( transformers, indent )\n                _md_gen_items( modelCollections, indent )\n                    _md_gen_items( comments, indent )\n                        xml-dump-el-close( modelRef )\n                        r_cb()\n        \n        async-md( modelCollection )\n            xml-dump-el-open( modelCollection )\n            xml-dump-attr( itemName, last )\n            _md_gen_items( pathTemplateValues, indent )\n                _md_gen_items( comments, indent )\n                    xml-dump-el-close( modelCollection )\n                    r_cb()\n\n        async-md( pathTemplateValue )\n            xml-dump-el-open( pathTemplateValue )\n            xml-dump-attr( attribute )\n            xml-dump-attr( function )\n            xml-dump-attr( token, last )\n            _md_gen_items( comments, indent )\n                xml-dump-el-close( pathTemplateValue )\n                r_cb()\n\n        async-md( comment )\n            xml-dump-el-open( comment )\n            _ ctx.w('>')\n            xml-dump-el-close( comment )\n            r_cb()\n        \n        async-md( line )\n            xml-dump-el-open( line )\n            xml-dump-attr( cwdFolder )\n            xml-dump-attr( destFolder, last )\n            _md_gen_items( artifacts, indent )\n                _md_gen_items( comments, indent )\n                    xml-dump-el-close( line )\n                    r_cb()\n\n        async-md( artifact )\n            xml-dump-el-open( artifact )\n            xml-dump-attr( src )\n            xml-dump-attr( ignore )\n            xml-dump-attr( schema )\n            xml-dump-attr( format )\n            xml-dump-attr( isCompile )\n            xml-dump-attr( isWfJob )\n            xml-dump-attr( isWfModelType )\n            xml-dump-attr( generator )\n            xml-dump-attr( destPath )\n            xml-dump-attr( extension )\n            xml-dump-attr( collection )\n            xml-dump-attr( noOutput )\n            xml-dump-attr( noOutput, last )\n            _md_gen_items( transformers, indent )\n                _md_gen_items( modelRefs, indent )\n                    _md_gen_items( comments, indent )\n                        xml-dump-el-close( artifact )\n                        r_cb()\n\n        async-md( transformer )\n            xml-dump-el-open( transformer )\n            xml-dump-attr( type, last )\n            xml-dump-el-close( transformer )\n            r_cb()\n\n        async-md( production )\n            xml-dump-el-open( production )\n            xml-dump-attr( destFolder, last )\n            _md_gen_items( lineRefs, indent )\n                _md_gen_items( modelRefs, indent )\n                    _md_gen_items( comments, indent )\n                        xml-dump-el-close( production )\n                        r_cb()\n\n        async-md( lineRef )\n            xml-dump-el-open( lineRef )\n            _md_gen_items( comments, indent )\n                xml-dump-el-close( lineRef )\n                r_cb()\n\n        async-md( env )\n            xml-dump-el-open( env )\n            xml-dump-attr( __name )\n            xml-dump-attr( __value )\n            xml-dump-attr( type, last )\n            xml-dump-el-close( env )\n            r_cb()\n\n        async-md( arg )\n            xml-dump-el-open( arg )\n            xml-dump-attr( __name )\n            xml-dump-attr( __value )\n            xml-dump-attr( type, last )\n            xml-dump-el-close( arg )\n            r_cb()\n\n        async-md( execFile )\n            xml-dump-el-open( execFile )\n            xml-dump-attr( exePath )\n            xml-dump-attr( title )\n            xml-dump-attr( cwd )\n            xml-dump-attr( encoding )\n            xml-dump-attr( timeout, last )\n            xml-dump-el-open( options )\n            xml-dump-attr( cwd )\n            xml-dump-attr( encoding )\n            xml-dump-attr( timeout, last )\n            xml-dump-el-close( options )\n            _md_gen_items( args, indent )\n                _md_gen_items( env, indent )\n                    _md_gen_items( comments, indent )\n                        xml-dump-el-close( execFile )\n                        r_cb()\n\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n"
                },
                {
                    "name": "wzjob/document",
                    "schema": "wzjob",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzjob\\.wizzi-override\\lib\\artifacts\\wzjob\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.wzjob',\n            name: 'document',\n            schema: 'wzjob',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n        $append main\n            _ md.wzjob\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        async-md( wzjob )\n            _ ctx.w('<wzjob>')\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                {\n                    @ indent true\n                a_cb()\n                    _ ctx.w('</wzjob>')\n                    r_cb()\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n"
                }
            ],
            "transformations": [
                {
                    "name": "wfjob/extended",
                    "schema": "wfjob",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzjob\\.wizzi-override\\lib\\artifacts\\wfjob\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.wzjob',\n            name: 'extended',\n            schema: 'wfjob',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                },
                {
                    "name": "wzjob/extended",
                    "schema": "wzjob",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzjob\\.wizzi-override\\lib\\artifacts\\wzjob\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.wzjob',\n            name: 'extended',\n            schema: 'wzjob',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.wzschema",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.wzschema/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "wzschema",
                            "wfschema"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.wzschema-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [
                            "wzschema",
                            "wfschema"
                        ],
                        "globalContext": {
                            "wzConfigIsDevelopment": true
                        }
                    }
                }
            ],
            "schemas": [
                {
                    "name": "wzschema",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi-override\\lib\\wizzi\\schemas\\wzschema.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema wzschema\n    \n    $*\n    preserve-tags true\n    mtree-is-preprocessed true\n    unknown-element-replacer text\n    *$\n    \n    e wzschema\n        is-root\n        r element/s\n    \n    e jsInclude\n        tag ::script\n        include js module\n\n    e element\n        tag e\n        a super\n        a tag\n        a isRoot\n            tag is-root\n            type boolean\n            default false\n            default-when-declared true\n        r attribute/s\n        r relation/s\n\n    e relation\n        tag r\n        a type\n\n    e attribute\n        tag a\n        a tag\n        a type\n        a default\n        a defaultWhenDeclared\n            tag default-when-declared\n            type boolean\n            default false\n            default-when-declared true\n\n\n    \n"
                },
                {
                    "name": "wfschema",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi-override\\lib\\wizzi\\schemas\\wfschema.wfschema.ittf",
                    "genConfig": "wizzi.config.override.js",
                    "content": "wfschema wfschema\r\n\r\n\tmtree-is-preprocessed true\r\n    \r\n    e comment\r\n\t\t# A comment line for describing entities.\r\n\t\ttag #\r\n\t\tr comment/s\r\n\r\n\te schemaitem : comment\r\n\t\r\n\te wfschema : schemaitem\r\n\t\t# The root element of a wizzi factory schema.\r\n\t\tis-root\r\n\t\t\r\n\t\ta_tag_flag( preserveTags, preserve-tags )\r\n\t\t\t# If declared, the WizziModelLoader will preserve, in the loaded WizziModelInstance,\r\n\t\t\t# the tags used in the source IttfDocuments.\r\n\r\n\t\ta_tag_flag( mTreeIsPreprocessed, mtree-is-preprocessed )\r\n\t\t\t# If declared, the WizziModelLoader will preprocess the builded mTree \r\n\t\t\t# before loading the WizziModelInstance,\r\n\r\n\t\ta_tag( unknownElementReplacer, unknown-element-replacer )\r\n\t\t\t# v4 (pre-release) implementation\r\n\r\n\t\tr element/s\r\n\t\t# r include/s\r\n\t\t\r\n\t\tr exportTo/s\r\n\t\tr require/s\r\n\t\tr method/s\r\n\t\tr declare/s\r\n\r\n\te include : schemaitem\r\n\t\t# Represent the root node of another external schema.\r\n\t\t# The wzName contains a blank separated name-value pair:\r\n\t\t# - the name is the type name of the external wfschema\r\n\t\t# - the value is the wzTag of the root node of the external wfschema (defaults to name)\r\n\t\t# see wizzi/models/bootstrap/t/wfschema/include.js.ittf\r\n\t\t# examples\r\n\t\t#   include js module\r\n\t\t#   - js : the external wfschema\r\n\t\t#   - module : the wzTag of the root node of the js wfschema \r\n\t\t#   include css\r\n\t\t#   - css : the external wfschema\r\n\t\t#   - css : the wzTag of the root node of the css wfschema \r\n\t\t# Children nodes will be loaded by the model factory of the external schema,\r\n\t\t# whose plugin must be listed in the plugin configuration when creating\r\n\t\t# the wizzi.wizziFactory instance.\r\n\t\r\n\t$include wfschema/element\r\n\t$include wfschema/attribute\r\n\t$include wfschema/relation\r\n\t$include wfschema/restrict\r\n\t$include wfschema/code\r\n\t$include wfschema/statements"
                }
            ],
            "artifacts": [
                {
                    "name": "wfjob/document",
                    "schema": "wfjob",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi\\lib\\artifacts\\wfjob\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.wzschema',\n            name: 'document',\n            schema: 'wfjob',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n        $append main\n            _ md.wfjob\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        async-md( wfjob )\n            _ ctx.w('<wfjob>')\n            _ md.genItems\n                @ model.nodes\n                @ ctx\n                {\n                    @ indent true\n                a_cb()\n                    _ ctx.w('</wfjob>')\n                    r_cb()\n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n"
                },
                {
                    "name": "wfschema/document",
                    "schema": "wfschema",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi-override\\lib\\artifacts\\wfschema\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.wzschema',\n            name: 'document',\n            schema: 'wfschema',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n            var included_writers = require('./included_writers')\n        $append main\n            _ md.wfschema\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        \n        async-md( wfschema )\n            xml-dump-el-open( wfschema )\n            xml-dump-attr( preserveTags )\n            xml-dump-attr( mTreeIsPreprocessed )\n            xml-dump-attr( unknownElementReplacer, last )\n            _md_gen_items( exportTos, indent )\n                _md_gen_items( requires, indent )\n                    _md_gen_items( declares, indent )\n                        _md_gen_items( methods, indent )\n                            _md_gen_items( elements, indent )\n                                _md_gen_items_comments_and_r_cb.js( wfschema, indent )\n\n        async-md( exportTo )\n            xml-dump-el-open( exportTo )\n            _ ctx.w('>')\n            xml-dump-el-close( exportTo )\n            r_cb()\n\n        async-md( require )\n            xml-dump-el-open( require )\n            xml-dump-attr( kind )\n            xml-dump-attr( declareVar, last )\n            xml-dump-el-close( require )\n            r_cb()\n\n        async-md( declare )\n            xml-dump-el-open( declare )\n            _ ctx.w('>')\n            # _md_gen_items( statements, indent )\n            xml-dump-el-close( declare )\n            r_cb()\n\n        async-md( method )\n            xml-dump-el-open( method )\n            xml-dump-attr( emitkey, last )\n            _md_gen_items( params, indent )\n                _md_gen_items( requires, indent )\n                    # _md_gen_items( statements, indent )\n                    xml-dump-el-close( method )\n                    r_cb()\n        \n        async-md( param )\n            xml-dump-el-open( param )\n            _ ctx.w('>')\n            xml-dump-el-close( param )\n            r_cb()\n\n        async-md( element )\n            xml-dump-el-open( element )\n            xml-dump-attr( super )\n            xml-dump-attr( isAbstract )\n            xml-dump-attr( tagInternal )\n            xml-dump-attr( xmlTagInternal )\n            xml-dump-attr( tagType )\n            xml-dump-attr( acceptAnyTag )\n            xml-dump-attr( nameIsRequired )\n            xml-dump-attr( addToChildren )\n            xml-dump-attr( hasMTreeData )\n            xml-dump-attr( suppressCollectionEmit )\n            xml-dump-attr( isRoot, last )\n            _md_gen_items( attributes, indent )\n                _md_gen_items( relations, indent )\n                    _md_gen_items( restricts, indent )\n                        _md_gen_items( methods, indent )\n                            _md_gen_items( includes , indent )\n                                _md_gen_items_comments_and_r_cb.js( element, indent )\n\n        async-md( attribute )\n            xml-dump-el-open( attribute )\n            xml-dump-attr( tagInternal )\n            xml-dump-attr( type )\n            xml-dump-attr( default )\n            xml-dump-attr( isRequired )\n            xml-dump-attr( isDataType )\n            xml-dump-attr( isDataType )\n            xml-dump-attr( defaultWhenDeclared, last )\n            _md_gen_items( restricts, indent )\n                _md_gen_items( comments, indent )\n                    xml-dump-el-close( attribute )\n                    r_cb()\n        \n        async-md( restrict )\n            xml-dump-el-open( restrict )\n            _ ctx.w('>')\n            _md_gen_items( facets, indent )\n                xml-dump-el-close( restrict )\n                r_cb()\n\n        $\n            var facets = [\n                \"enum\",\n                \"maxLength\",\n                \"minLength\",\n                \"maxValue\",\n                \"minValue\",\n                \"regexp\",\n                \"element\",\n            ];\n\n        $foreach facet in facets\n            async-md( ${facet}Facet )\n                xml-dump-el-open( ${facet}Facet )\n                _ ctx.w('>')\n                xml-dump-el-close( ${facet}Facet )\n                r_cb()\n\t\n        async-md( relation )\n            xml-dump-el-open( relation )\n            xml-dump-attr( isOneToOne )\n            xml-dump-attr( noGetMethod )\n            xml-dump-attr( hasAddOnce, last )\n            _md_gen_items_comments_and_r_cb.js( relation, indent )\n\n        async-md( comment )\n            xml-dump-el-open( comment )\n            _ ctx.w('>')\n            _md_gen_items( comments, indent )\n                xml-dump-el-close( comment )\n                r_cb()\n\n        async-md( include )\n            xml-dump-el-open( include )\n            _ ctx.w('>')\n            _md_gen_items( comments, indent )\n                xml-dump-el-close( include )\n                r_cb()\n\n        $include includes\n        \n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        \n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        \n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n"
                },
                {
                    "name": "wzschema/document",
                    "schema": "wzschema",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi-override\\lib\\artifacts\\wzschema\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.wzschema',\n            name: 'document',\n            schema: 'wzschema',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n            var included_writers = require('./included_writers')\n        $append main\n            _ md.wzschema\n                @ model\n                @ ctx\n                a_cb( )\n                    if ctx.artifactGenerationErrors.length > 0\n                        r_cb_err( ctx.artifactGenerationErrors )\n                    else\n                        # generation OK\n                        r_cb( ctx )\n        \n        async-md( wzschema )\n            xml-dump-el-open( wzschema )\n            _ ctx.w('>')\n            _md_gen_items( elements, indent )\n                xml-dump-el-close( wzschema )\n                r_cb()\n        \n        async-md( element )\n            xml-dump-el-open( element )\n            xml-dump-attr( super )\n            xml-dump-attr( tag )\n            xml-dump-attr( isRoot, last )\n            _md_gen_items( attributes, indent )\n                _md_gen_items( relations, indent )\n                    xml-dump-el-close( element )\n                    r_cb()\n        \n        async-md( attribute )\n            xml-dump-el-open( attribute )\n            xml-dump-attr( tag )\n            xml-dump-attr( type )\n            xml-dump-attr( default )\n            xml-dump-attr( defaultWhenDeclared, last )\n            xml-dump-el-close( attribute )\n            r_cb()\n        \n        async-md( relation )\n            xml-dump-el-open( relation )\n            xml-dump-attr( type, last )\n            xml-dump-el-close( relation )\n            r_cb()\n        \n        $include includes\n        \n        var noattrs\n            [\n                @ 'wzTag'\n                @ 'wzName'\n                @ 'wzElement'\n                @ 'wzParent'\n                @ 'wzSourceLineInfo'\n                @ '___exportName'\n        function isAttrValue\n            param a\n            param v\n            if noattrs.indexOf(a) > -1\n                return false\n            if v == null || verify.isArray(v) || verify.isObject(v) || verify.isFunction(v)\n                return false\n            return true\n        function getAttrs\n            param e\n            var retval = []\n            for var a in e\n                if isAttrValue(a, e[a])\n                    _ retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] })\n                elif a.substr(0, 3) === 'ng-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'data-'\n                    _ retval.push({ name: a, value: e[a] })\n                elif a.substr(0, 5) === 'aria-'\n                    _ retval.push({ name: a, value: e[a] })\n            if e.attributes\n                foreach a in e.attributes\n                    var p = lineParser.parseNameValueRaw(a.wzName, a)\n                    if p.hasValue()\n                        _ retval.push({ name: p.name(), value: p.value() })\n                    else\n                        _ retval.push({ name: p.name() })\n            return retval\n"
                },
                {
                    "name": "wfschema/factory",
                    "schema": "wfschema",
                    "artifact": "factory",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi-override\\lib\\artifacts\\wfschema\\factory\\gen\\main.js.ittf",
                    "content": "module\r\n\tkind jsfile\r\n\r\n    var util = require('util')\r\n    var path = require('path')\r\n    var wizzi = require('wizzi')\r\n    var BootWizziSchema = require('../../bootstrap/wfschema-boot-model').WizziSchema\r\n    \r\n    var md = module.exports = {}\r\n    \r\n    var myname = 'wfschema.factory_darvin.main'\r\n\r\n    set md.gen\r\n        function\r\n            param model\r\n            param ctx\r\n            param callback\r\n\r\n            var bootWizziModel = new BootWizziSchema(model.wzName)\r\n            _ bootWizziModel.loadFromWizziModel\r\n                @ model\r\n                @ ctx\r\n                a_cb()\r\n                    var mTreeBuildupContext\r\n                        {\r\n                            @ schema bootWizziModel\r\n                            @ request\r\n                                {\r\n                                    @ emitKey ctx.emitKey || 'node-js'\r\n                                    @ toJson ctx.toJson || false\r\n                                    @ isWizziPackageSchema isWizziPackageSchema(model.wzName)\r\n\r\n                    _ wizzi.fsFactory\r\n                        {\r\n                            { plugins\r\n                                [ items\r\n                                    @ 'wizzi-core'\r\n                                    @ 'wizzi-web'\r\n                                    @ 'wizzi-js'\r\n                        a_cb( wf )\r\n                            _ wf.loadModelAndGenerateArtifact\r\n                                _ path.join\r\n                                    @ __dirname\r\n                                    @ 'ittf'\r\n                                    @ 'wfschema-factory.js.ittf'                            \r\n                                {\r\n                                    @ modelRequestContext mTreeBuildupContext\r\n                                    @ artifactRequestContext {}\r\n                                @ 'js/module'\r\n                                a_cb( artifactText )\r\n                                    # loog 'wfschema-factory.artifactText', artifactText\r\n                                    _ ctx.w(artifactText)\r\n                                    r_cb( ctx )\r\n\r\n    $include isWizziPackageSchema\r\n    \r\n"
                },
                {
                    "name": "wfschema/html_docs",
                    "schema": "wfschema",
                    "artifact": "html_docs",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi-override\\lib\\artifacts\\wfschema\\html_docs\\gen\\main.js.ittf",
                    "content": "module\r\n\tkind jsfile\r\n\r\n    var util = require('util')\r\n    var path = require('path')\r\n    var wizzi = require('wizzi')\r\n    var BootWizziSchema = require('../../bootstrap/wfschema-boot-model').WizziSchema\r\n\r\n    var md = module.exports = {}\r\n    var myname = 'wfschema.html.docs.main'\r\n\r\n    set md.gen\r\n        function\r\n            param model\r\n            param ctx\r\n            param callback\r\n\r\n            var bootWizziModel = new BootWizziSchema(model.wzName)\r\n            _ bootWizziModel.loadFromWizziModel\r\n                @ model\r\n                @ ctx\r\n                a_cb()\r\n                    var mTreeBuildupContext\r\n                        {\r\n                            @ schema bootWizziModel\r\n                            @ request\r\n                                {\r\n                    \r\n                    _ wizzi.fsFactory\r\n                        {\r\n                            { plugins\r\n                                [ items\r\n                                    @ 'wizzi-core'\r\n                                    @ 'wizzi-web'\r\n                                    @ 'wizzi-js'\r\n                        a_cb( wf )\r\n                            _ wf.loadModelAndGenerateArtifact\r\n                                _ path.join\r\n                                    @ __dirname\r\n                                    @ 'ittf'\r\n                                    @ 'wfschema-docs.html.ittf'\r\n                                {\r\n                                    @ modelRequestContext mTreeBuildupContext\r\n                                    @ artifactRequestContext {}\r\n                                @ 'html/document'\r\n                                a_cb( artifactText )\r\n                                    # loog 'wfschema-docs.html.ittf.artifactText', artifactText\r\n                                    _ ctx.w(artifactText)\r\n                                    r_cb( ctx )"
                },
                {
                    "name": "wfschema/json_schemaboot",
                    "schema": "wfschema",
                    "artifact": "json_schemaboot",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi-override\\lib\\artifacts\\wfschema\\json_schemaboot\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.wzschema',\n            name: 'json_schemaboot',\n            schema: 'wfschema',\n            checkSchema: true,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n            var wizzi = require('wizzi')\n            var BootWizziSchema = require('../../bootstrap/wfschema-boot-model').WizziSchema\n            var stringify = require('json-stringify-safe')\n\n        $append main\n            var bootWizziModel = new BootWizziSchema(model.wzName)\n            _ bootWizziModel.loadFromWizziModel\n                @ model\n                @ ctx\n                a_cb()\n                    var jsonObject\n                        _ bootWizziModel.toJson()\n                    _ ctx.w\n                        _ stringify\n                            @ jsonObject\n                            @ null\n                            @ 4\n                    r_cb( ctx )\n                \n"
                },
                {
                    "name": "wfschema/model",
                    "schema": "wfschema",
                    "artifact": "model",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi-override\\lib\\artifacts\\wfschema\\model\\gen\\main.js.ittf",
                    "content": "module\r\n\tkind jsfile\r\n\r\n    var util = require('util')\r\n    var path = require('path')\r\n    var wizzi = require('wizzi')\r\n    var md = module.exports = {}\r\n    var myname = 'wfschema.model.main'\r\n\r\n    var BootWizziSchema = require('../../bootstrap/wfschema-boot-model').WizziSchema\r\n\r\n    set md.gen\r\n        function\r\n            param model\r\n            param ctx\r\n            param callback\r\n            \r\n            # loog 'wizzi-core.wfschema.gen.model started', ittfDocumentPath\r\n            # loog 'wizzi-core.artifacts.wfschema.model.model', model\r\n\r\n            var bootWizziModel = new BootWizziSchema(model.wzName)\r\n            _ bootWizziModel.loadFromWizziModel\r\n                @ model\r\n                @ ctx\r\n                a_cb()\r\n                    var mTreeBuildupContext\r\n                        {\r\n                            @ schema bootWizziModel\r\n                            @ request\r\n                                {\r\n                                    @ emitKey ctx.emitKey || null\r\n                                    @ toJson bootWizziModel.exportToJson()\r\n                                    @ toXml bootWizziModel.exportToXml()\r\n                                    @ toPrettify bootWizziModel.exportToPrettify()\r\n                    _ wizzi.fsFactory\r\n                        {\r\n                            { plugins\r\n                                [ items\r\n                                    @ 'wizzi-core'\r\n                                    @ 'wizzi-web'\r\n                                    @ 'wizzi-js'\r\n                        a_cb( wf )\r\n                            _ wf.loadModelAndGenerateArtifact\r\n                                _ path.join\r\n                                    @ __dirname\r\n                                    @ 'ittf'\r\n                                    @ 'wfschema-model.js.ittf'                            \r\n                                {\r\n                                    @ modelRequestContext mTreeBuildupContext\r\n                                    @ artifactRequestContext {}\r\n                                @ 'js/module'\r\n                                a_cb( artifactText )\r\n                                    # loog 'wfschema-model.artifactText', artifactText\r\n                                    _ ctx.w(artifactText)\r\n                                    r_cb( ctx )\r\n\r\n\r\n"
                },
                {
                    "name": "wfschema/test",
                    "schema": "wfschema",
                    "artifact": "test",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi-override\\lib\\artifacts\\wfschema\\test\\gen\\main.js.ittf",
                    "content": "module\r\n\tkind jsfile\r\n\r\n    var util = require('util')\r\n    var path = require('path')\r\n    var legacy = require('../../../../../legacy')\r\n\r\n    var md = module.exports = {}\r\n    var myname = 'wizzischema.test.main'\r\n\r\n    set md.gen\r\n        function\r\n            param model\r\n            param ctx\r\n            param callback\r\n\r\n            # log myname + 'model', model\r\n\r\n            var ittfDocumentPath = path.join(__dirname, 'ittf', 'wizzischema-test.js.ittf')\r\n            var mTreeBuildupContext\r\n                {\r\n                    @ schema model\r\n                    @ request\r\n                        {\r\n                            @ emitKey ctx.emitKey || 'node-js'\r\n                            @ toJson ctx.toJson || false\r\n\r\n            _ legacy.jsModule\r\n                @ ittfDocumentPath\r\n                @ mTreeBuildupContext\r\n                function\r\n                    param err\r\n                    param result\r\n                    if err\r\n                        throw new Error(err)\r\n                    _ ctx.w(result)\r\n                    _ callback(null, ctx)\r\n"
                }
            ],
            "transformations": [
                {
                    "name": "wfjob/extended",
                    "schema": "wfjob",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi\\lib\\artifacts\\wfjob\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.wzschema',\n            name: 'extended',\n            schema: 'wfjob',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                },
                {
                    "name": "wfschema/extended",
                    "schema": "wfschema",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi-override\\lib\\artifacts\\wfschema\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.wzschema',\n            name: 'extended',\n            schema: 'wfschema',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                },
                {
                    "name": "wzschema/extended",
                    "schema": "wzschema",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi-override\\lib\\artifacts\\wzschema\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.wzschema',\n            name: 'extended',\n            schema: 'wzschema',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                },
                {
                    "name": "wfschema/json_docs",
                    "schema": "wfschema",
                    "artifact": "json_docs",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi-override\\lib\\artifacts\\wfschema\\json_docs\\trans\\main.js.ittf",
                    "content": "module\r\n\tkind jsfile\r\n\r\n    var util = require('util')\r\n    var _ = require('lodash')\r\n    var errors = require('../../../../../lib/errors')\r\n    var verify = require('../../../../../lib/util/verify')\r\n    var jsModelType = require('../../../../../legacy').jsModelType\r\n\r\n    var md = module.exports = {}\r\n    var myname = 'model.transformation.wfschema.html.docs.main'\r\n\r\n    set md.trans\r\n        function\r\n            param model\r\n            param ctx\r\n            param callback\r\n            if model.wzElement != 'wfschema'\r\n                _ errors.NodeError(myname + '.trans. Model wzElement must be wfschema. Found: ' + model.wzElement, model);\r\n            set ctx.result\r\n                {\r\n                    @ name model.wzName\r\n                    @ preserveTags model.preserveTags\r\n            _ md.wfschema(model, ctx)\r\n            _ callback(null, ctx.result)\r\n\r\n    tagoper( wfschema )\r\n        set ctx.result.requires = []\r\n        set ctx.result.exportTos = []\r\n        set ctx.result.elements = []\r\n        foreach exportTo in model.exportTos\r\n            _ md.exportTo(exportTo, ctx, ctx.result)\r\n        foreach element in model.elements\r\n            _ md.element(element, ctx, ctx.result)\r\n\r\n    tagoper( exportTo )\r\n        _ parent.exportTos.push(model.wzName)\r\n\r\n    tagoper( element )\r\n        var flags = ''\r\n        set flags += model.isAbstract ? 'is-abstract ' : ''\r\n        set flags += model.addToChildren ? 'add-to-children ' : ''\r\n        var tagEscaped = verify.replaceAll(model.tagName, '\\\\|', '__&%%&__')\r\n        var tagsEscaped = tagEscaped.split('|')\r\n        var tags = []\r\n        foreach tag in tagsEscaped\r\n            _ tags.push\r\n                _ verify.replaceAll(tag, '__&%%&__', '|')\r\n        var node\r\n            {\r\n                @ name model.wzId\r\n                @ super model.superId\r\n                @ isRoot model.isRoot\r\n                @ tags tags\r\n                @ flags flags\r\n                @ attributes\r\n                    [\r\n                @ relations\r\n                    [\r\n                @ derived\r\n                    [\r\n                @ restricts\r\n                    [\r\n                @ methods\r\n                    [\r\n                @ comments\r\n                    [\r\n        var flatAttributes = model.getFlatAttributes()\r\n        foreach attr in flatAttributes\r\n            _ node.attributes.push(attr)\r\n\r\n        var flatRelations = model.getFlatRelations()\r\n        foreach r in flatRelations\r\n            _ node.relations.push(r)\r\n\r\n        foreach d in model.derived\r\n            var tagEscaped = verify.replaceAll(d.tagName, '\\\\|', '__&%%&__')\r\n            var tagsEscaped = tagEscaped.split('|')\r\n            var tags = []\r\n            foreach tag in tagsEscaped\r\n                _ tags.push\r\n                    _ verify.replaceAll(tag, '__&%%&__', '|')\r\n            _ node.derived.push\r\n                {\r\n                    @ name d.wzId\r\n                    @ tags tags\r\n\r\n        foreach m in model.methods\r\n            var methodNode \r\n                {\r\n                    @ name m.wzName\r\n                    @ emitKey m.emitKey\r\n                    @ isStatic m.isStatic\r\n                    @ isKnownMethod m.isKnownMethod\r\n                    @ params\r\n                        [\r\n                    @ statements\r\n                        [\r\n                    @ comments\r\n                        [\r\n\r\n            foreach param in m.params\r\n                _ methodNode.params.push(param.wzName)\r\n\r\n            foreach stm in m.statements\r\n                foreach item in normalizeJST(stm.wzName)\r\n                    _ methodNode.statements.push(item)\r\n            \r\n            foreach comment in m.comments\r\n                _ methodNode.comments.push(comment.wzName)\r\n\r\n            _ node.methods.push(methodNode)\r\n\r\n        foreach restrict in model.restricts\r\n            _ node.restricts.push(getRestrictFill(restrict))\r\n\r\n        foreach comment in model.comments\r\n            _ node.comments.push(comment.wzName)\r\n\r\n        _ parent.elements.push(node)\r\n\r\n    function getRestrictFill\r\n        param model\r\n        var restrictCloned\r\n            {\r\n                @ facets\r\n                    [\r\n                @ comments\r\n                    [\r\n        foreach facet in model.facets\r\n            var facetCloned\r\n                {\r\n                    @ type facet.wzElement\r\n                    @ value facet.wzName\r\n                    @ comments\r\n                        [\r\n            foreach comment in facet.comments\r\n                _ facetCloned.comments.push(comment.wzName)\r\n\r\n            _ restrictCloned.facets.push(facetCloned)\r\n\r\n        foreach comment in model.comments\r\n            _ restrictCloned.comments.push(comment.wzName)\r\n\r\n        return restrictCloned\r\n\r\n    function normalizeJST\r\n        param stm\r\n        var json = JSON.parse(stm)\r\n        var ret = []\r\n        if verify.isArray(json)\r\n            foreach item in json\r\n                _ ret.push(normalizeJSTNode(item))\r\n        else\r\n            _ ret.push(normalizeJSTNode(json))\r\n        return ret\r\n\r\n    function normalizeJSTNode\r\n        param jstnode\r\n        var node\r\n            {\r\n                @ tag jstnode.n\r\n                @ name jstnode.n\r\n                @ value jstnode.v\r\n                @ statements\r\n                    [\r\n        \r\n        if jsModelType.__tagElementMapping[jstnode.n]\r\n            set node.name = jsModelType.__tagElementMapping[jstnode.n]\r\n        \r\n        if jstnode.children\r\n            foreach item in jstnode.children\r\n                _ node.statements.push(normalizeJSTNode(item))\r\n        \r\n        return node"
                },
                {
                    "name": "wfschema/schemaboot",
                    "schema": "wfschema",
                    "artifact": "schemaboot",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.wzschema\\.wizzi-override\\lib\\artifacts\\wfschema\\schemaboot\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.wzschema',\n            name: 'schemaboot',\n            schema: 'wfschema',\n            checkSchema: true\n        };\n    trans( &md )\n        $append imports\n            var wizzi = require('wizzi')\n            var BootWizziSchema = require('../../bootstrap/wfschema-boot-model').WizziSchema\n        $append main\n            set transformedModel = new BootWizziSchema(model.wzName)\n            _ bootWizziModel.loadFromWizziModel\n                @ model\n                @ ctx\n                a_cb()\n"
                }
            ]
        },
        {
            "name": "wizzi.plugin.yaml",
            "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.yaml",
            "hasWizziOverride": true,
            "wizziConfigFiles": [
                {
                    "name": "wizzi.config.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.yaml\\wizzi.config.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.yaml/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.yaml\\.wizzi\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.yaml",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                },
                {
                    "name": "wizzi.config.override.js",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.yaml\\wizzi.config.override.js",
                    "content": {
                        "wfjobName": "wizzi.plugin.yaml-override/job",
                        "wfjobPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.yaml\\.wizzi-override\\generate.wfjob.ittf",
                        "destPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.yaml",
                        "plugins": [
                            "./wizzi-core/index.js",
                            "./wizzi-js/index.js",
                            "./wizzi-web/index.js"
                        ],
                        "pluginsBaseFolder": "C:/My/wizzi/stfnbssl/wizzi/packages",
                        "schemas": [],
                        "globalContext": {
                            "wzConfigIsDevelopment": true,
                            "wzConfigIsPackageDeploy": false,
                            "wzConfigIsDocumentation": true
                        }
                    }
                }
            ],
            "schemas": [],
            "artifacts": [
                {
                    "name": "yaml/document",
                    "schema": "yaml",
                    "artifact": "document",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.yaml\\.wizzi-override\\lib\\artifacts\\yaml\\document\\gen\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.yaml',\n            name: 'document',\n            schema: 'yaml',\n            rootElement: '',\n            checkSchema: false,\n            isAsync: true,\n        };\n    gen( &md )\n        $append imports\n            var yaml = require('js-yaml')\n        $append main\n            delete model.___exportName\n            _ ctx.w\n                _ yaml.dump\n                    @ model\n                    {\n                        @ flowLevel 100\n                        { styles\n                            @ '!!null' 'camelcase' \n            r_cb( ctx )"
                }
            ],
            "transformations": [
                {
                    "name": "yaml/extended",
                    "schema": "yaml",
                    "artifact": "extended",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.yaml\\.wizzi-override\\lib\\artifacts\\yaml\\extended\\trans\\main.js.ittf",
                    "content": "module\n    kind es6\n    $\n        var md = {\n            plugin: 'wizzi.plugin.yaml',\n            name: 'extended',\n            schema: 'yaml',\n            rootElement: '',\n            checkSchema: true\n        };\n    trans( &md )\n        $append main\n            set transformedModel\n                {\n            foreach item in model.items\n                _ doitem\n                    @ item\n                    @ transformedModel\n    function doitem\n        param parent\n        param resultObj\n        var f = functors[parent.wzElement]\n        if f\n            _ f\n                @ parent\n                @ resultObj\n    var functors = {}\n"
                }
            ],
            "wizzifiers": [
                {
                    "name": "yaml",
                    "schema": "yaml",
                    "fullPath": "C:\\My\\wizzi\\stfnbssl\\wizzi.plugins\\packages\\wizzi.plugin.yaml\\.wizzi-override\\lib\\wizzifiers\\yaml\\wizzifier.js.ittf",
                    "content": "module\n    $\n        var schemaName = 'yaml';\n    kind es6\n    basewizzifier()\n        $append imports\n            var yaml_parser = require('js-yaml')\n            var cleanAST = require('./cleanAST')\n            +\n            function parseInternal\n                param tobeWizzified\n                param options\n                param callback\n                var syntax\n                try\n                    set syntax\n                        _ yaml_parser.load\n                        \t@ tobeWizzified\n                    _ cleanAST(syntax)\n                    log 'syntax', syntax\n                catch ex\n                    return\n                        _ callback\n                            @ ex\n                return\n                    _ callback\n                        @ null\n                        @ syntax\n        +\n        var analizeAstArray\n            function\n                param ast\n                param handler\n                foreach item in ast\n                    if verify.isObject(item)\n                        _ handler.onObject(true)\n                        _ analizeAstObject(item, handler)\n                        _ handler.onObject(false)\n                    elif verify.isArray(item)\n                        _ handler.onArray(true)\n                        _ analizeAstArray(item, handler)\n                        _ handler.onArray(false)\n                    else\n                        _ handler.onArrayValue(item)\n\n\n        var analizeAstObject\n            function\n                param ast\n                param handler\n                for var k in ast\n                    var item = ast[k]\n                    if verify.isObject(item)\n                        _ handler.onObject(true)\n                        _ analizeAstObject(item, handler)\n                        _ handler.onObject(false)\n                    elif verify.isArray(item)\n                        _ handler.onArray(true)\n                        _ analizeAstArray(item, handler)\n                        _ handler.onArray(false)\n                    else\n                        _ handler.onProp(k, item)\n        +\n        var format\n            function\n                param parent\n                param ast\n                param options\n                var wizziTree = parent\n                _ analizeAstObject\n                    @ ast\n                    { \n                        @ onObject\n                            function \n                                param open\n                                log  'onObject', open\n                                if open\n                                    var n\n                                        { \n                                            @ tag '{'\n                                            @ name ''\n                                            @ children\n                                                [ \n                                    set n.parent = wizziTree\n                                    _ wizziTree.children.push(n)\n                                    set wizziTree = n\n                                else\n                                    # log  \"onObject wizziTree.tag\", wizziTree.tag\n                                    set wizziTree = wizziTree.parent\n                                    # log  \"onObject wizziTree.tag\", wizziTree.tag\n                        @ onArray\n                            function\n                                param open\n                                log  'onArray', open\n                                if open\n                                    var n\n                                        { \n                                            @ tag '['\n                                            @ name ''\n                                            @ children\n                                                [ \n                                    set n.parent = wizziTree\n                                    _ wizziTree.children.push(n)\n                                    set wizziTree = n\n                                else\n                                    # FIXME\n                                    # log  \"onArray wizziTree.tag\", wizziTree.tag\n                                    set wizziTree = wizziTree.parent\n                                    # log  \"onArray wizziTree.tag\", wizziTree.tag\n                        @ onPropName\n                            function \n                                param name\n                                log  \"onPropName\", name\n                                var n\n                                    { \n                                        @ tag name\n                                        @ name ''\n                                        @ children\n                                            [ \n                                set n.parent = wizziTree\n                                _ wizziTree.children.push(n)\n                                # log  wizziTree.tag\n                                set wizziTree = n\n                                # log  wizziTree.tag\n                        @ onProp\n                            function \n                                param name\n                                param value\n                                log  \"onProp\", name, value\n                                var n\n                                    { \n                                        @ tag name\n                                        @ name value\n                                        @ children\n                                            [ \n                                set n.parent = wizziTree\n                                _ wizziTree.children.push(n)\n                        @ onObjectProp\n                            function \n                                param name\n                                log  \"onObjectProp\", name\n                                var n\n                                    { \n                                        @ tag '{'\n                                        @ name name\n                                        @ children\n                                            [ \n                                set n.parent = wizziTree\n                                _ wizziTree.children.push(n)\n                                set wizziTree = n\n                        @ onArrayProp\n                            function \n                                param name\n                                log  \"onObjectProp\", name\n                                var n\n                                    { \n                                        @ tag '['\n                                        @ name name\n                                        @ children\n                                            [ \n                                set n.parent = wizziTree\n                                _ wizziTree.children.push(n)\n                                set wizziTree = n\n                        @ onClosePropName\n                            function\n                                log  'onClosePropName'\n                                set wizziTree = wizziTree.parent\n                        @ onArrayValue\n                            function \n                                param value\n                                log  \"onArrayValue\", value\n                                var n\n                                    { \n                                        @ tag value\n                                        @ name ''\n                                        @ children\n                                            [ \n                                _ wizziTree.children.push(n)\n        +\n        function wizzify\n            param tobeWizzified\n            param options\n            param callback\n            set options = options || {};\n            set options.input = tobeWizzified\n            set options.stack = []\n            set options.formatTextNodes = []\n            set options.verbose = true\n            _ parseInternal\n                @ tobeWizzified\n                @ options\n                a_cb( syntax )\n                    # log stringify(syntax, null, 2)\n                    var root\n                        { \n                            @ tag 'yaml'\n                            @ children\n                                [ \n                    _ format(root, syntax, options)\n                    log stringify(root, null, 2)\n                    return\n                        _ callback\n                            @ null\n                            @ root$$.children[0]\n        $include helper_functions\n        +\n        function isKnownType\n            param type\n            return ['Int', 'Float', 'Boolean', 'String'].indexOf(type) > -1\n        +\n        function getTypeName\n            param type\n            return isKnownType(type) ? type.toLowerCase() : type\n        f( Name, name )\n            # name( value )\n            #\n                # loog 'Name.tag', ret.tag\n                # loog 'Name.name', ret.name\n                # loog 'Name.textified', ret.textified\n"
                }
            ]
        }
    ]
}